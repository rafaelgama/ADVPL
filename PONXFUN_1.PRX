#INCLUDE "PONXFUN.CH"
#INCLUDE "PONCALEN.CH"
#INCLUDE "PROTHEUS.CH"    
#INCLUDE "ARFF.CH"    

#DEFINE DPORT1510  "25/11/09"
/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Static Utilizadas na CriaCalend()  						   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды /*/
Static __dPerCalIni
Static __dPerCalFim
/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Static Utilizadas na CalendCria()  						   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static __aLstTabCal	:= {}
Static __aLstTabTno	:= {}	
Static __cKeyBldCal	:= "__cKeyBldCal"
Static __nFilTabTno	:= 0
Static __nFilTabTno2	:= 0
/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Static Utilizadas na fTabPadrao()  						   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static __nLstTabPadPos

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Static Utilizadas na fTabMarc()    						   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static __aLstTbMarc

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Static Utilizadas na ToScheduleOverTime()					   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static __aHeLastGera__
Static __cHeLastKey__

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Static Utilizadas na GetTabArred()					   	   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static __aTabArr
Static __aTabFilArr

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Static Utilizadas na GetTabExtra()					   	   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static __aTabEx
Static __lEscalonamento 
Static cFilStatic		//Para uso em DEFAULTFIL

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Static Utilizadas na fFeriado()   					   	   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static __aFeriadoStatic

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁDefine o Numero Maximo de Ordens para o P8_ORDEM             Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static __nTamP8Ordem	:= InitP8PgOrdSize(1)

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁDefine o Numero Maximo de Ordens para o PG_ORDEM             Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static __nTamPGOrdem	:= InitP8PgOrdSize(2)

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁStatic com as Eventos carregados pela fEventos()             Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static __aEvefEve__	:= {}

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁStatic para a fCargaId										  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static aCargaIdCache 	:= {}

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁStatic para a PutMarcAuto()								  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static _aSpaHeader
Static _aSr6Header

Static _cSr6LastTno
Static _cSpaLastReg
Static _cSpceFuncao
Static _cSpceGiro
Static _cSpceRelogi

Static _nSpaHeader
Static _nSr6Header

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁStatic para a PonLoadExec()								  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static _nVezes := 100

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁVerifica se a Execucao eh no AS/400                          Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
#IFDEF TOP
	Static lExInAs400 := ExeInAs400()
#ENDIF

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁVerifica a Existencia do Arquivo de Pre-Abonos.  ( Nao deveraЁ
Ёconstar em versoes Futuras )								  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static lRF0ChkTable

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Static Utilizadas na Calendcria e Turnos Opcionais	   	   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static __aAllTnoOpc
Static __lChkTnoOpc	

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁVariavel para uso em Query para preencher em branco		  Ё
Ёo campo Motivo do Abono 								  	  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static __cLimpaMotAbo	

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁVariavel para uso da Geracao Automatica de Marcacoes		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static lPnMcAut01	:= ExistBlock( "PNMCAUT01" )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁVariavel para manipulacao do calendario apos sua montagem	  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static lPnmTabCalen := ExistBlock( "PNMTABC01" )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁVariavel para alterar motivo de inclusao de marcacao auto.	  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static lPnmMotMarc := ExistBlock( "PNMMOTMARC" )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁVariavel para manipulacao da tabela de horas extras		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static lPnmTabHe := ExistBlock( "PNMTABHE" )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁVariavel para a gravaГЦo dos campos de auditoria do ponto	  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static __lCpoDataAlt	
Static __lCpoUsuaAlt

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁVerifica se Portaria 1510/2009 esta em vigor.				  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static lPort1510 := Port1510()    

//-- Campos da tabela SPC para atendimento a portaria 1.510
Static __lCpoTurno	
Static __lCpoSemana	
Static __lCpoTipoHE
Static __lCpoPercent	

Static aSr6Info		:= {}
Static aSr6Struct 	:= { "R6_INIHNOT", "R6_FIMHNOT", "R6_MINHNOT", "R6_APODFER", "R6_TPEXFER", "R6_TPEXFEN", "R6_AUTOHEF", "R6_ASFOLGA", "R6_TNOOPC" }
Static lSr6Ok		:= .T.
Static aSpaInfo		:= {}
Static aSpaStruct 	:= { "PA_PAGINT", "PA_FERIADO" }
Static lSpaOk		:= .T.

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁPonxFun   Ё Autor Ё *EQUIPE RH ADVANCED*  		 	Ё Data Ё02/02/1996Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o Ё Biblioteca de Fun┤■es Utilizadas no M╒dulo SigaPon        			  Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё Void                                                   			  Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       Ё Gen┌rico                                                  			  Ё
цддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё                     ATUALIZACOES SOFRIDAS DESDE A CONSTRU─AO INICIAL. 		  Ё
цддддддддддддбддддддддбддддддддддддддддбдддддддддддддддддддддддддддддддддддддддддд╢
ЁProgramador Ё Data   Ё FNC			   Ё  Motivo da Alteracao                     Ё
цддддддддддддеддддддддеддддддддддддддддедддддддддддддддддддддддддддддддддддддддддд╢
ЁMauricio MR Ё14/10/09Ё000000256232009 Ё Alteracao das funcoes abaixo para atenderЁ
Ё            Ё        Ё                Ё a portaria 1.510 do MTE (BRA): 		  Ё
Ё            Ё        Ё                Ё fGeraRes()								  Ё
Ё            Ё        Ё                Ё fGeraTot()								  Ё
Ё            Ё        Ё                Ё fGeraExtra()							  Ё
Ё            Ё        Ё                Ё ToScheduleOverTime()					  Ё
Ё            Ё        Ё                Ё fGeraRes()								  Ё
Ё            Ё        Ё                Ё Getmarcacoes - alteracao no uso diretiva Ё
Ё            Ё        Ё                Ё AMARC_SEQ para identificar a sequencia doЁ
Ё            Ё        Ё                Ё turno de trabalho.                       Ё
Ё            Ё        Ё                Ё AMARC_TNOPC - criada para identificar a  Ё
Ё            Ё        Ё                Ё sequencia do turno no caso de turno opcioЁ
Ё            Ё        Ё                Ё nal. No entanto, AMARC_SEQ deve ser refe-Ё
Ё            Ё        Ё                Ё renciada para obter a sequencia.		  Ё
Ё            Ё        Ё                Ё PutOrdMarc - Incluida a referencia a se- Ё
Ё            Ё        Ё                Ё quencia do turno.						  Ё
Ё            Ё        Ё                Ё PutMarcAuto -Incluida a referencia a se- Ё
Ё            Ё        Ё                Ё quencia do turno. O array aTdia utilizadoЁ
Ё            Ё        Ё                Ё no ponto de entrada PNMCAUT01 passa a terЁ
Ё            Ё        Ё                Ё GetTabExtra - Referenciado o campo de ho-Ё
Ё            Ё        Ё                Ё ra extra P4_PERCENT para usar na geracao Ё
Ё            Ё        Ё                Ё de horas extras.						  Ё
Ё            Ё        Ё                Ё GetLastApo - incluida referencia aos cam-Ё
Ё            Ё        Ё                Ё pos Turno/Semana/Tipo HE e Percentual.   Ё
Ё            Ё        Ё                Ё ValidArqPon() - controle de acesso das   Ё
Ё            Ё        Ё                Ё tabelas RFB X RFE.						  Ё
ЁMauricio MR Ё07/12/09Ё000000294392009 Ё Alteracao para nao efetivar a liberacao  Ё
Ё            Ё        Ё                Ё da portaria (fnc aprovada indevidamente) Ё
ЁMauricio MR Ё08/12/09Ё000000293702009 Ё Geracao de Dados (tabela RFF) para a o	  Ё
Ё            Ё        Ё                Ё arquivo ACJEF.							  Ё
ЁMauricio MR Ё18/12/09Ё000000304482009 Ё Alteracao para nao efetivar a liberacao  Ё
Ё            Ё        Ё                Ё da portaria (fnc aprovada indevidamente) Ё
ЁMauricio MR Ё29/12/09Ё000000304482009 Ё Alteracao para recomppilar com os chs    Ё
Ё            Ё        Ё                Ё atualizados							  Ё
ЁMauricio MR Ё29/01/10Ё000000001942010 Ё Alteracao inibir a acao de teclas sem usoЁ
Ё            Ё        Ё                Ё ao informar um motivo de manutencao.     Ё 
ЁMauricioMR  Ё05/02/10Ё000000015442010 Ё Ajuste para considerar as marcacoes pelo Ё
Ё            Ё        Ё                Ё periodo de apontamento no caso de turnos Ё
Ё            Ё        Ё                Ё opcionais.								  Ё
ЁBianca CL	 |11/05/10|00000009528/2010|Ajuste para efetuar verificaГЦo do tamanho| 
|			 |		  |				   |do array aOrd antes de incrementa-lo, para| 
|			 |		  |				   |que nЦo ocorra estouro do array           |
ЁAllyson M.	 |06/08/10|00000014699/2010|Ajuste para efetuar verificacao se modo de| 
|			 |		  |				   |acesso da SRA e SP0 sao iguais.			  | 
ЁAllyson M.	 |16/09/10|00000016699/2010|Criacao da funcao PonLoadExec p/ atualizar| 
|			 |		  |				   |empresas na tabela RFK, se a integracao	  | 
|			 |		  |				   |do SIGAPON x TSREP estiver ativa. 		  | 
ЁAllyson M.	 |03/03/11|00000005449/2011|Ajuste em PutMarcacoes(), criacao de para-| 
|			 |		  |				   |metro p/ indicar se eh executado por work-| 
|			 |		  |				   |flow.									  | 
ЁAllyson M.	 |17/05/11|00000009278/2011|Ajuste diversos para melhoria de perfor-  | 
|			 |		  |				   |mance do processamento e para diminiuir o | 
|			 |		  |				   |no. de requisicoes ao banco de dados.	  | 
ЁAllyson M.	 |30/05/11|00000012203/2011|Ajuste em GetTnoOpc() para nao fazer con- | 
|			 |		  |				   |sistencia de data, uma vez que uma jornada| 
|			 |		  |				   |pode comecar em um dia e terminar em outro| 
ЁAllyson M.	 |28/07/11|00000017826/2011|Ajuste em PonActModPer(0 para quando      | 
|			 |		  |				   |atualizar o periodo do ponto, nao atualize| 
|			 |		  |				   |o MV_PAPONTA, apenas o MV_PONMES.		  | 
ЁAldo Marini Ё08/08/11Ё00000019491/2011ЁPreparacao para integracao do SIGAPON com Ё
Ё            Ё        ЁTDLM50          Ёo TSA (Totvs Controle de Acesso) via Web  Ё
Ё            Ё        Ё  	           Ёservices, desenvolvidos pela Datasul.	  Ё
ЁAllyson M.	 |31/08/11|00000021854/2011|Ajuste em PerAponta(), para verificar     | 
|			 |		  |				   |config. correta do periodo qdo.inf.30 dias| 
ЁR.Berti     Ё15/09/11ЁTDNAVLЁNova funcao PVldCpoOK() para retirar caracteres     Ё
|			 |		  |	     |especiais do motivo de desconsid./inc. de marcacao  | 
ЁAldo Marini Ё15/09/11Ё00000023341/2011ЁAlteracao no metodo de envio das excecoes Ё
Ё            ЁTDQOG4--Ё                Ёpor turno e centro de custo para enviar deЁ
Ё            Ё        Ё                Ёuma so vez no webservice.                 Ё
ЁR.Berti     Ё05/10/11ЁTDTID2ЁCorrecao error log ao retornar a area origem (vazia)Ё
юддддддддддддаддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/



/*/
зддддддддддбдддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁInPonxFunExecЁ Autor ЁMarinaldo de Jesus   Ё Data Ё14/05/2003Ё
цддддддддддедддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁExecutar Funcoes Dentro de PONXFUN                           Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁInPonxFunExec( cExecIn , aFormParam )						 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁuRet                                                 	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico 													 Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function InPonxFunExec( cExecIn , aFormParam )
         
Local uRet

DEFAULT cExecIn		:= ""
DEFAULT aFormParam	:= {}

IF !Empty( cExecIn )
	cExecIn	:= BldcExecInFun( cExecIn , aFormParam )
	uRet	:= &( cExecIn )
EndIF

Return( uRet )

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁAbreArqRelЁ Autor Ё Equipe Advanced RH    Ё Data Ё29/02/1996Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Abre o arquivo gerado pelo rel╒gio.                        Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё                                                            Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ/*/
Function AbreArqRel(	cTipoArq	,;	//01 -> Tipo do Arquivo a ser Aberto. "T"ext File, "D"ata File
						cArquivo	,;	//02 -> Caminho completo do arquivo
						nHandle		,;	//03 -> Handle do Arquivo ( Quando Tipo = "T" )
						lEnchoice	,;	//04 -> Se esta sendo Executado aa partir da Enchoice
						lStop		,;	//05 -> Se deve Emitir Mensagens
						cArqSrv		,;	//06 -> Nome do arquivo no server
						lCpyT2Srv	,;	//07 -> Se o arquivo foi copiado para o server
						lForceCopy	 ;	//08 -> Forca copia do arquivo para o server
					 )
Local aAuxRelo		:= {}
Local aSvAlias		:= GetArea()
Local cExt			:= ""
Local cRdd			:= "DBFCDX"
Local cMsgAlert		:= ""
Local cPathSrv		:= Upper(GetPvProfString( GetEnvServer() , "StartPath" , "" , GetAdv97() ) )
Local lRet			:= .T.
Local nPos			:= 0
Local cPonArq		:= If( !Empty( SuperGetMv("MV_POARQ",.F.,"N") ), SuperGetMv("MV_POARQ",.F.,"N"), "2" )

DEFAULT cTipoArq	:= "T"
DEFAULT cArquivo	:= ""
DEFAULT nHandle		:= 0
DEFAULT lEnchoice	:= .F.
DEFAULT lStop	  	:= .T.
DEFAULT cArqSrv		:= "" 
DEFAULT lCpyT2Srv	:= .F. 
DEFAULT lForceCopy	:= .F.

cArquivo			:= Upper( AllTrim( cArquivo ) )
nHandle				:= 0
cArqSrv				:= ""
lCpyT2Srv			:= .F.

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁTratamento de acordo com o Tipo de Arquivo - R - REP		   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( cTipoArq == "R" )
	Return .T.
Endif

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Array com os alias dos arquivos abertos (s╒ para o PONA030)  Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( lEnchoice .and. cTipoArq == "D" )
	IF ( Type( "aAliasRelo" ) == "U" )
		_SetOwnerPrvt( "aAliasRelo" , {} )
	EndIF
	DEFAULT aAliasRelo := {}
EndIF

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Inicializa cTxtAlias uma Estancia Acima					   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( Type( "cTxtAlias" ) == "U" )
	_SetOwnerPrvt( "cTxtAlias" )
EndIF

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Obtem o Nome Real do Arquivo Sem Path e nem Extenso		   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
cTxtAlias := cArquivo


/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Alteracao solcitada pelo Andre Gentil para contornar a situa Ё
Ё cao de nao gravacao de arquivo do remote para o servidor.    Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
/*
IF ( ( nPos := At( ":" , cTxtAlias ) ) > 0 )
	cTxtAlias := SubStr( cTxtAlias , ++nPos )
EndIF
*/

While ( At( "\" , cTxtAlias ) > 0 )
	IF ( ( nPos := At( "\" , cTxtAlias ) ) > 0 )
		cTxtAlias := SubStr( cTxtAlias , ++nPos )
	EndIF
End While

While ( At( "." , cTxtAlias ) > 0 )
	IF ( ( nPos := At( "." , cTxtAlias ) ) > 0 )
		cTxtAlias := Left( cTxtAlias , --nPos )
	EndIF
End While

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Obtem a Extensao do Arquivo								   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( ( nPos := At( "." , cArquivo ) ) > 0 )
	cExt := Upper( AllTrim( SubStr( cArquivo , nPos ) ) )
EndIF

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁVerifica a Existencia de "\" ou "/" barras separadoras de diretorio  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF !( Subst( cPathSrv , 1 , 1 ) $ "\/" )
	cPathSrv := "\"+cPathSrv
EndIF
IF !( Subst( cPathSrv , -1	) $ "\/" )
	cPathSrv+= "\"
EndIF  

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁObtem o Nome do arquivo no Server 							   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
cArqSrv := Upper( AllTrim( ( cPathSrv + ( cTxtAlias + cExt ) ) ) )

                         
If lEnchoice
    If !Empty(aAliasRelo)   
       nPos:=0   
       For nPos:=1 To Len(aAliasRelo)
           fCloseArqRel(	aAliasRelo, nPos, 	aAliasRelo[nPos,01 ],  aAliasRelo[nPos,02 ], aAliasRelo[nPos,03 ],;
           										aAliasRelo[nPos,04 ],  aAliasRelo[nPos,05 ], aAliasRelo[nPos,06 ],;
           										cTxtAlias, cArquivo ;
           				)
       Next nPos                    
       aAuxRelo		:= Aclone(aAliasRelo)
       aAliasRelo	:= {}             
       //-- Nao considera arquivo marcados para delecao
       Aeval(aAuxRelo, {|x| If ( x[1] == "DEL", NIL, AADD(aAliasRelo,aClone(x)) ) } )
      				 
	   lCpyT2Srv	:= ( aScan( aAliasRelo , {|x| x[1] == cTxtAlias .AND. x[02] .and.    x[04 ]  == cTipoArq .and. x[06 ]  == cArquivo  } ) > 0 ) 
	Endif   
Endif		
	    
/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁcPonArq - indica que sС copia o arquivo para o StartPath caso Ё
Ёo parametro MV_POARQ esteja com valor NцO					   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
If (cPonArq != "1")
	If !lCpyT2Srv  .or. lForceCopy
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁCopia o arquivo para o Servidor							   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( lCpyT2Srv := !(;
								( cArquivo == StrTran( cArqSrv , "/" , "\" ) ) .and.;
								( cArquivo == StrTran( cArqSrv , "\" , "/" ) );
							);
			)  
			
			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁQuando o Arquivo Nao Estiver no Server     				   Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF ( lCpyT2Srv := !( Upper( StrTran( cArquivo , " " , "" ) ) == Upper( StrTran( cArqSrv , " " , "" ) ) ) )
		
				/*/
				здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				ЁCopia-o                                    				   Ё
				юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			    //lCpyT2Srv := __CopyFile( cArquivo , cArqSrv ) //__CopyFile() Recomendacao do Fernando Ramalho ao Inves do CpyT2S() 14/10/2002 16:38h. Naldo.
		
				/*/
				здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Alteracao solcitada pelo Andre Gentil para contornar a situa Ё
				Ё cao de nao gravacao de arquivo do remote para o servidor.    Ё
				юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		       
			   //	IF ( ( At( ":" , cArquivo ) ) > 0 )
			   //		lCpyT2Srv := CpyT2S( cArquivo , cPathSrv ) //CpyT2S() Recomendacao do Andre Gentil 13/12/2005 11:55h. Mauricio.
			  //	Else
					lCpyT2Srv := __CopyFile( cArquivo , cArqSrv ) //__CopyFile() Recomendacao do Fernando Ramalho ao Inves do CpyT2S() 14/10/2002 16:38h. Naldo.
			   //	Endif
		        
				/*/
				здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё No Ap7 Existe uma Nao  Conformidade com o Retorno da 	 funcaoЁ
				Ё __CopyFile(). Esta retornando NIL Quando deveria Retornar .T.Ё
				Ё ou .F. Caso Tenha Conseguido ou Nao Copiar o Arquivo. Ate queЁ
				Ё a Nao Conformidade Seja corrigida o valor DEFAULT da variavelЁ
				Ё de Retorno da __CopyFile ( lCpyT2Srv ) sera False (.F.)  CasoЁ
				Ё Contrario sera o Proprio retorno da Funcao				   Ё
				юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				DEFAULT lCpyT2Srv := .F.
		
			EndIF
		Endif
	EndIF
EndIf


/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁTratamento de acordo com o Tipo de Arquivo					   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( cTipoArq == "D" )
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁAbre o arquivo no padr└o DBASE								   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( !Empty( cTxtAlias ) .and. Select( cTxtAlias ) > 0 )
		( cTxtAlias )->( dbCloseArea() )
		RestArea( aSvAlias )
	EndIF
	IF ( lRet := MsFile( cArqSrv , NIL , cRdd ) )
		IF (;
				!( CheckExecForm( { || lRet := MsOpenDbf( .T. , cRdd , cArqSrv , cTxtAlias , .T. , .F. ) } , lStop , "NODBFFILE" ) );
				.or.;
				!( lRet );
			 )
			lRet		:= .F.
			cMsgAlert	:= ( STR0156 + " " + cArqSrv )	//'Nao foi possivel abrir o arquivo:'
		EndIF
	Else
		cMsgAlert := ( STR0058 + cArqSrv ) 				//"Arquivo do Relogio nao Encontrado no Servidor: "
	EndIF
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁInclui o Alias aberto para posterior fechamento			   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( lEnchoice .and. Select( cTxtAlias ) > 0 )
		IF  ( ( nPos := aScan( aAliasRelo , {|x| x[1] == cTxtAlias  .and.  x[04 ]  == cTipoArq .and. 	x[06] == cArquivo } )) == 0 )
			aAdd( aAliasRelo , { cTxtAlias , lCpyT2Srv , cArqSrv , cTipoArq , nHandle, cArquivo } )
		Else
			aAliasRelo[ nPos , 02 ] := lCpyT2Srv
			aAliasRelo[ nPos , 03 ]	:= cArqSrv
			aAliasRelo[ nPos , 04 ]	:= cTipoArq
			aAliasRelo[ nPos , 05 ]	:= nHandle
			aAliasRelo[ nPos , 06 ]	:= cArquivo
		EndIF
	EndIF
Else
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁAbre o arquivo no padr└o ASCII								   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( lRet := File( cArqSrv ) ) 
	   	nPos	:= 0 
   		IF ( Type( "aAliasRelo" ) <> "U" )
		   	//-- Verifica a necessidade de abrir o arquivo caso o mesmo nЦo esteja aberto.
		    nPos := aScan( aAliasRelo , {|x| x[1] == cTxtAlias  .and.  x[04 ]  == cTipoArq .and. 	x[06] == cArquivo } )
		Endif
		If nPos == 0
			nHandle := fOpen( cArqSrv )
			IF ( fError() # 0 .or. nHandle < 0 )
				cMsgAlert := ( STR0156 + " " + cArqSrv )	//'Nao foi possivel abrir o arquivo:'
				lRet := .F.
			EndIF
		Endif	
	Else
		cMsgAlert := ( STR0058 + cArqSrv )				//"Arquivo do Relogio nao Encontrado no Servidor:
	EndIF
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁInclui o Alias aberto para posterior fechamento			   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( lEnchoice .and. nHandle > 0 )
		IF  ( ( nPos := aScan( aAliasRelo , {|x| x[1] == cTxtAlias  .and.  x[04 ]  == cTipoArq .and. 	x[06] == cArquivo } )) == 0 )
			aAdd( aAliasRelo , { ALLTRIM(cTxtAlias) , lCpyT2Srv , cArqSrv , cTipoArq , nHandle, cArquivo } )
		Else
			aAliasRelo[ nPos , 02 ] := lCpyT2Srv
			aAliasRelo[ nPos , 03 ]	:= cArqSrv
			aAliasRelo[ nPos , 04 ]	:= cTipoArq
			aAliasRelo[ nPos , 05 ]	:= nHandle
			aAliasRelo[ nPos , 06 ]	:= cArquivo
		EndIF
	EndIF
EndIF

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁMensagens de Nao Abertura dos Arquivos             		   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( lStop .and. !lRet )
	IF !Empty( cMsgAlert )
		MsgAlert( cMsgAlert , STR0059 ) //"Alerta"
	Else
		Help( "" , 1 , "A030NOPEN" )
	EndIF
EndIF

Return( lRet )


/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁfCloseArqRelЁ Autor Ё Equipe Advanced RH  Ё Data Ё29/02/1996Ё╠╠
╠╠цддддддддддеддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Fecha o arquivo gerado pelo rel╒gio.                       Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё                                                            Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ/*/

Static Function fCloseArqRel(aAliasRelo, nFile, cTxtAlias, lCpyT2Srv, cArqSrv, cTipoArq, nHandle, cArq, cTxt, cArquivo)

//-- Quando o arquivo a ser consultado possuir o mesmo nome de algum arquivo anteriormente lido
//-- Fecha e elimina o arquivo anterior 
If ( cTxtAlias == cTxt)  .and. ( cArq  == cArquivo ) 
	 
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Fecha os Arquivos Abertos em AbreArqRel()					 			 Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( cTipoArq == "D" )
		TxtAliasClose( cTxtAlias )
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Se copiou para o server, Exclui                           			 Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( lCpyT2Srv )
			If ( fErase(Lower( cArqSrv ) ) < 0 )
					MsgAlert( fError() , STR0059 ) //"Alerta"
			Endif   
		EndIF
	ElseIF (;
				( cTipoArq == "T" );
				.and.;
				( nHandle > 0 );
			)	
		fClose( nHandle ) 
		If ( fErase(Lower( cArqSrv ) ) < 0 )
			MsgAlert( fError() , STR0059 ) //"Alerta"
		Endif   
	EndIF
	aAliasRelo[nFile, 1] := "DEL"
Endif
Return (NIL)

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁProcForm  Ё Autor Ё Wiliam                Ё Data Ё 29.02.96 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Rotina para tratamento da formula                          Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё Generico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ/*/
Function ProcForm( cFormula )

Local bErro       := ErrorBlock( { |e| ErrorForm( e ) } )
Local lResult     := .T.

IF ( ValType( cFormula ) == "C" )
	cFormula := AllTrim( cFormula )
	IF Len(cFormula) > 0
		lResult := ExecForm( cFormula )
	EndIF
Else
	lResult := ExecForm( cFormula )
EndIF	

ErrorBlock( bErro )

Return( lResult )

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁExecForm	Ё Autor Ё Wiliam                Ё Data Ё 29.02.96 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Executa a formula e retorna o resultado                    Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё Generico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ/*/
Static Function ExecForm( cFormula )

Local xRet
Begin Sequence
	xRet := &(cFormula)
	If !ValType( xRet ) == "C"
		Help(" ",1,"FNOCHAR" )
		xRet := .F.
	Else
		xRet := .T.
	Endif
	RECOVER
	Help(" ",1,"FORMINVAL" , , OemToAnsi( GetTitulo() ) , 5 , 0 )
	xRet := .F.
End Sequence

Return( xRet )
/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁGetTitulo Ё Autor Ё Mauricio MR           Ё Data Ё 16.09.02 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Obtem o Titulo em SX3 correspondente a variavel lida       Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё Generico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ/*/
Static Function GetTitulo()

Local aArea			:= GetArea()
Local aAreaSX3 		:= SX3->( GetArea() )   
Local aAreaSXA 		:= SXA->( GetArea() )   
Local cCampo		:= UPPER(StrTran(ReadVar(),"M->",""))
Local cTitulo		:= ''          
Local cAlias      	:= ''
Local cFolder   	:= ''

SX3->( dbSetOrder( 02 ) ) 

//-- Obtem informacoes sobre o campo 
IF SX3->( dbSeek(cCampo) )
   cTitulo		:=  STR0154 + X3TITULO(SX3->X3_TITULO)
   cAlias		:= SX3->(X3_ARQUIVO) 
   cFolder		:= SX3->(X3_FOLDER) 
    //-- Obtem Informacoes sobre o nome da Pasta se Existir
	If !Empty(cFolder)               
		IF SXA->( dbSeek(cAlias+cFolder) )
		   cTitulo:= STR0153+ALLTRIM(XADESCRIC()) + ' / ' +cTitulo
		Endif	
	Endif
Endif	

RestArea( aAreaSXA )
RestArea( aAreaSX3 ) 
RestArea( aArea) 

Return( cTitulo )

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁErrorForm Ё Autor Ё Wiliam                Ё Data Ё 29.02.96 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Rotina para tratamento de erros da formula                 Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё Generico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ/*/
Static Function ErrorForm( oError )

IF ( oError:gencode > 0 )
	Break
ENDIF

Return( NIL )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁfTabPadraoЁ Autor Ё Equipe Advanced RH    Ё Data Ё 15/03/96 Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna um array com a tabela de hor═rio padr└o do turno.   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁfTabPadrao( aTabTno , cFil , cTurno )						Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁaTab   - Array com os Dados da Tabela                       Ё
Ё          ЁcFil   - Filial Para Pesquisa                               Ё
Ё          ЁcTurno - Turno para Pesquisa                                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   Ё lRet                                                       Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       Ё Generico                                                   Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fTabPadrao( aTabTno , cFil , cTurno , lExecQryTop , bCond )

Local aArray		:= {}
Local cAlias		:= "SPJ"
Local cAliasQuery	:= cAlias
Local cCustoSpace   := Space( GetSx3Cache( "RA_CC" , "X3_TAMANHO" ) )
Local cFilTno		:= ""
Local lRet      	:= .T.
Local lSpjIntSrep	:= ( Type("SPJ->PJ_INTSREP") # "U" )
Local nPos			:= 0
Local nLenTab		:= 0
Local nRecno		:= 0

#IFDEF TOP

	Local cQuery	 		:= ""
	Local aSvAlias			:= GetArea()
	Local cCpoRecno 		:= ""
	Local lQueryOpened		:= .F.
	Local nX				:= 0

	Static aSpjFields
	Static cQrySpjFields
	Static nSpjFields

	DEFAULT lExecQryTop	:= .T.

	IF ( lExInAs400 )
		lExecQryTop	:= .F.
	EndIF	

	IF ( lExecQryTop )
		
		DEFAULT aSpjFields 	:= ( cAlias )->( dbStruct() )
		DEFAULT nSpjFields 	:= Len( aSpjFields )

		IF ( cQrySpjFields == NIL )
			cQrySpjFields := ""
			For nX := 1 To nSpjFields
				cQrySpjFields += aSpjFields[ nX , 01 ] + ", "
			Next nX
	    EndIF
	EndIF

#ENDIF

DEFAULT aTabTno			:= {}
DEFAULT cTurno			:= Space( GetSx3Cache( "RA_TNOTRAB" , "X3_TAMANHO" ) )
DEFAULT bCond			:= { || .T. }
DEFAULT __nLstTabPadPos	:= 0
                                       
cFil	:= xFilial( "SPJ" , cFil )
cFilTno := ( cFil + cTurno )

IF ( ( ( nLenTab := Len( aTabTno ) ) == 0 ) .or. ( __nLstTabPadPos > nLenTab ) )
	__nLstTabPadPos := 0
EndIF

IF ( ( __nLstTabPadPos == 0 ) .or. !( ( aTabTno[ __nLstTabPadPos , 01 ] + aTabTno[ __nLstTabPadPos , 02 ] ) == cFilTno ) )
	IF ( ( nPos := aScan( aTabTno , { |x| x[1]+x[2] == cFilTno } ) ) == 0 ) .AND. !Empty(cTurno) 
		( aAdd( aTabTno, { cFil , cTurno , aArray } ) , ( __nLstTabPadPos := ( nLenTab := Len( aTabTno ) ) ) )
		#IFDEF TOP
			IF ( lExecQryTop )
				cCpoRecno	:= IF( lExInAs400 , "RRN("+InitSqlName( cAlias )+")", "R_E_C_N_O_" )
				cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )
				cQuery := "SELECT "
				cQuery += cQrySpjFields
				cQuery += cCpoRecno + " RECNO "
				cQuery += " FROM "
				cQuery += InitSqlName( cAlias )
				cQuery += " WHERE "
				cQuery += "PJ_FILIAL='"+cFil+"'"
				cQuery += " AND "
				cQuery += "PJ_TURNO='"+cTurno+"'"
				cQuery += " AND "
				cQuery += "D_E_L_E_T_=' ' "
				cQuery += "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )
				cQuery := ChangeQuery( cQuery )
				IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
					For nX := 1 To nSpjFields
						IF !( aSpjFields[ nX , 02 ] == "C" )
							TcSetField(cAliasQuery,aSpjFields[nX,01],aSpjFields[nX,02],aSpjFields[nX,03],aSpjFields[nX,04])
						EndIF
					Next nX
					lRet := ( cAliasQuery )->( !Eof() )
				Else
					cAliasQuery	:= cAlias
					lRet := ( cAliasQuery )->( dbSeek( cFilTno ) )
				EndIF
			Else
				cAliasQuery	:= cAlias
				lRet := ( cAliasQuery )->( dbSeek( cFilTno ) )
			EndIF
		#ELSE
			lRet := ( cAliasQuery )->( dbSeek( cFilTno ) )
		#ENDIF
			IF ( lRet )
				While ( cAliasQuery )->( !Eof() .and. ( cFilTno == PJ_FILIAL+PJ_TURNO ) )
					IF !( cAliasQuery )->( Eval( bCond ) )
						( cAliasQuery )->( dbSkip() )
						Loop
					EndIF
					#IFNDEF TOP
						nRecno := ( cAliasQuery )->( Recno() )
					#ELSE
						IF ( ( lExecQryTop ) .and. ( lQueryOpened ) )
							nRecno := ( cAliasQuery )->( RECNO )
						Else
							nRecno := ( cAliasQuery )->( Recno() )
						EndIF
					#EndIF	
					( cAliasQuery )->( aAdd( aTabTno[nLenTab,3 ] , {	PJ_ENTRA1		,;	// 01 - Primeira Entrada
								   				       					PJ_SAIDA1		,;	// 02 - Primeira Saida
									       								PJ_ENTRA2		,;	// 03 - Segunda Entrada
																		PJ_SAIDA2		,;	// 04 - Segunda Saida
																		PJ_ENTRA3		,;	// 05 - Terceira Entrada
																		PJ_SAIDA3		,;	// 06 - Terceira Saida
																		PJ_ENTRA4		,;	// 07 - Quarta Entrada
																		PJ_SAIDA4		,;	// 08 - Quarta Saida
																		PJ_HRSTRAB		,;	// 09 - Numero de Horas Trabalhadas 1a. Jornada
																		PJ_HRSTRA2		,;	// 10 - Numero de Horas Trabalhadas	2a. Jornada
																		PJ_HRSTRA3		,;	// 11 - Numero de Horas Trabalhadas 3a. Jornada
																		PJ_HRSTRA4		,;	// 12 - Numero de Horas Trabalhadas 4a. Jornada
																		PJ_HRSINT1  	,;	// 13 - Numero de Horas 1o. Intervalo
																		PJ_HRSINT2		,;	// 14 - Numero de Horas 2o. Intervalo
																		PJ_HRSINT3		,;	// 15 - Numero de Horas 3o. Intervalo
																		""       		,;	// 16 - Marcacao Refere-se ao Proximo Dia
																		0				,;	// 17 - TabMarc("SPJ")	Numero de Marcacoes da Tabela
																		PJ_TPDIA		,;  // 18 - Tipo do Dia
																		PJ_SEMANA		,;	// 19 - Sequencia da Marcacao
																		Val(PJ_DIA)		,;  // 20 - Numero Correspondente ao Dia da Semana
																		"N"				,;  // 21 - Refere-se a Excecao
																		""				,;  // 22 - Motivo da Excecao
																		PJ_TPEXT		,;  // 23 - Tipo de Extra Normal
																		PJ_TPEXTN		,;	// 24 - Tipo de Extra Noturna
																		cCustoSpace	    ,;	// 25 - Centro de Custo Periodo 1
																		cCustoSpace	    ,;  // 26 - Centro de Custo Periodo 2
																		cCustoSpace	    ,;	// 27 - Centro de Custo Periodo 3
																		cCustoSpace	    ,;	// 28 - Centro de Custo Periodo 4
																		PJ_NONAHOR 	    ,;	// 29 - Aponta Nona Hora
																		PJ_HORMENO	    ,;	// 30 - Limite de Horario Inicial
																		PJ_HORMAIS	    ,;	// 31 - Limite de Horario Final
																		PJ_JND1CON	    ,;	// 32 - 1a. Jornada Continua
																		PJ_JND2CON	    ,;	// 33 - 2a. Jornada Continua
																		PJ_JND3CON	    ,;	// 34 - 3a. Jornada Continua
																		PJ_JND4CON	    ,;	// 35 - 4a. Jornada Continua
																		PJ_CODREF	    ,;	// 36 - Codigo da Refeicao
																		nRecno			,;	// 37 - Recno
																		If(lPort1510 .And. lSpjIntSrep, PJ_INTSREP, '');	// 38 - Intervalo para geracao do ACJEF
															     	};
											);
									  )		 
					( cAliasQuery )->( dbSkip() )
				End While
			EndIF
		#IFDEF TOP
			IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
				( cAliasQuery )->( dbCloseArea() )
				dbSelectArea( "SPJ" )
				RestArea( aSvAlias )
			EndIf
		#ENDIF
	Else
	   	If nPos > 0
			__nLstTabPadPos := nPos
		Endif
	EndIF
EndIF	

Return( lRet )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGetInfoPosTabЁAutorЁ Marinaldo de Jesus   Ё Data Ё17/10/2001Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRetorna o Conteudo da Tabela de Horario Padrao Conforme   osЁ
Ё          ЁParametros Passados											Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁPonto Eletronico                                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁnSerFim                            							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetInfoPosTab(	nPosTip 	,;	//01 -> Posicao em aTabCalend para Obtencao da Informacao
						cFlagMarc	,;	//02 -> Flag da Marcacao "1E,1S,..."
						dData		,;	//03 -> Data em aTabCalend
						aTabCalend	,;	//04 -> Calendario de Marcacoes
						aTabPadrao	,;	//05 -> Tabela de Horario Padrao
						dPerIni		,;	//06 -> Periodo Inicial de Apontamento
						dPerFim		,;	//07 -> Periodo Final de Apontamento	
						lFunc		,;	//08 -> Informacao Referente a Funcionario
						cTno		,;	//09 -> Turno de Trabalho
						cSeq		,;	//10 -> Sequencia
						cFil		,;	//11 -> Filial
						lExce		,;  //12 -> Carrega Excecoes 
						bAscan		,;	//13 -> Bloco para Pesquisa em aTabCalend
						nRetPosTab  ;	//14 -> Retorno da Posicao do aTabCalend 	
					   )

Local aSvTabsCal	:= {}
Local cOrdem		:= ""
Local lContinua		:= .T.
Local lLastMarc		:= .F.
Local nPosTab		:= 0
Local nLenCalend	:= 0
Local uRet			:= NIL

IF ( ( Type("aTnoGetInfoTab") == "U" ) .or. ( Type("aTnoGetInfoTab") != "A" ) )
	Private aTnoGetInfoTab := {}
EndIF	

DEFAULT nPosTip		:= CALEND_POS_TURNO
DEFAULT cFlagMarc	:= "1E"
DEFAULT dData		:= dDataBase
DEFAULT aTabCalend	:= {}
DEFAULT aTabPadrao	:= {}
DEFAULT dPerIni		:= Ctod("//")
DEFAULT dPerFim		:= Ctod("//")
DEFAULT lFunc		:= .T.
DEFAULT cTno		:= SRA->RA_TNOTRAB
DEFAULT cSeq		:= SRA->RA_SEQTURN
DEFAULT cFil		:= SRA->RA_FILIAL
DEFAULT lExce		:= .F.
DEFAULT bAscan		:= { |x| x[CALEND_POS_DATA] == dData .and. x[CALEND_POS_TIPO_MARC] == cFlagMarc }

IF ( lLastMarc := ( ( cFlagMarc := Upper( AllTrim( cFlagMarc ) ) ) == "__LASTMARC__" ) )
	cFlagMarc := "1E"
EndIF

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁVerifica se o Calendario foi passado como parametro		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF Empty( aTabCalend )
	IF ( Empty( dPerIni ) .or. Empty( dPerFim ) )
		lContinua := PerAponta( @dPerIni , @dPerFim , dData , NIL , cFil )
	EndIF
	IF ( lContinua )
        /*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Salva o Conteudo do Calendario por Turno        			  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		aSvTabsCal := GetTabCal()
        /*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Cria o Calendario de Marcacoes                  			  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		lContinua := CriaCalend(	dPerIni 								,;	//01 -> Data Inicial do Periodo
				   					Min( dPerFim , dData )					,;	//02 -> Data Final do Periodo
							   		cTno									,;	//03 -> Turno Para a Montagem do Calendario
							   		cSeq									,;	//04 -> Sequencia Inicial para a Montagem Calendario
							   		@aTabPadrao								,;	//05 -> Array Tabela de Horario Padrao
							   		@aTabCalend								,;	//06 -> Array com o Calendario de Marcacoes
							   		cFil     								,;	//07 -> Filial para a Montagem da Tabela de Horario
							   		IF(lFunc,SRA->RA_MAT,NIL)  				,;	//08 -> Matricula para a Montagem da Tabela de Horario
							   		IF(lFunc .and. lExce,SRA->RA_CC,NIL)	,;	//09 -> Centro de Custo para a Montagem da Tabela
							   		IF(lFunc,@aTnoGetInfoTab,NIL)	 		,;  //10 -> Array com as Trocas de Turno
							   		NIL										,;	//11 -> Array com Todas as Excecoes do Periodo
									NIL										,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
									.F.										,;	//13 -> Se executa a funcao se sincronismo do calendario
									NIL										 ;	//14 -> Se Forca a Criacao de Novo Calendario
							  	  )
	EndIF
EndIF

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁEfetua a Pesquisa e Retorna o Conteudo do Elemento Desejado  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( lContinua )
	IF ( ( nPosTab := aScan( aTabCalend , bAscan ) ) > 0 )
		IF ( ( nPosTip > 0 ) .and. nPosTip <= Len( aTabCalend[ nPosTab ] ) )
			IF ( lLastMarc )
				cOrdem		:= aTabCalend[ nPosTab , CALEND_POS_ORDEM ]
				nLenCalend	:= Len( aTabCalend )
				While ( nPosTab <= nLenCalend )
					IF !( cOrdem == aTabCalend[ nPosTab , CALEND_POS_ORDEM ] )
						--nPosTab
						Exit
					EndIF
					IF ( nPosTab < nLenCalend )
						++nPosTab
					Else
						Exit
					EndIF
				End While	
			EndIF
			IF ( ValType( aTabCalend[ nPosTab , nPosTip ] ) == "A" )
				uRet := aClone( aTabCalend[ nPosTab , nPosTip ] )
			Else
				uRet := aTabCalend[ nPosTab , nPosTip ]
			EndIF	
		EndIF
	EndIF
EndIF

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁSe nao Obteve retorno Carrega valores DEFAULT                Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( ( uRet == NIL ) .and. ( nPosTip > 0 ) )

	nRetPosTab	:= 0

	Do Case 
		Case nPosTip == CALEND_POS_DATA			; uRet := Ctod("//")
		Case nPosTip == CALEND_POS_ORDEM		; uRet := ""
		Case nPosTip == CALEND_POS_HORA			; uRet := 0
		Case nPosTip == CALEND_POS_TIPO_MARC	; uRet := ""
		Case nPosTip == CALEND_POS_NUM_MARC 	; uRet := 0
		Case nPosTip == CALEND_POS_TIPO_DIA 	; uRet := ""
		Case nPosTip == CALEND_POS_HRS_TRABA	; uRet := 0
		Case nPosTip == CALEND_POS_SEQ_TURNO	; uRet := ""
		Case nPosTip == CALEND_POS_HRS_INTER	; uRet := 0
		Case nPosTip == CALEND_POS_EXCECAO		; uRet := ""
		Case nPosTip == CALEND_POS_MOT_EXECAO	; uRet := ""
		Case nPosTip == CALEND_POS_TIPO_HE_NOR	; uRet := ""
		Case nPosTip == CALEND_POS_TIPO_HE_NOT	; uRet := ""
		Case nPosTip == CALEND_POS_TURNO		; uRet := ""
		Case nPosTip == CALEND_POS_CC			; uRet := ""
		Case nPosTip == CALEND_POS_PG_NONA_HORA	; uRet := ""
		Case nPosTip == CALEND_POS_LIM_MARCACAO	; uRet := { Ctod("//") , 0 }
		Case nPosTip == CALEND_POS_COD_REFEICAO	; uRet := ""
		Case nPosTip == CALEND_POS_FERIADO		; uRet := .F.
		Case nPosTip == CALEND_POS_TP_HE_FER_NR	; uRet := ""
		Case nPosTip == CALEND_POS_TP_HE_FER_NT	; uRet := ""
		Case nPosTip == CALEND_POS_DESC_FERIADO ; uRet := ""
		Case nPosTip == CALEND_POS_REGRA		; uRet := ""
		Case nPosTip == CALEND_POS_AFAST		; uRet := ""
		Case nPosTip == CALEND_POS_TIP_AFAST	; uRet := ""
		Case nPosTip == CALEND_POS_INI_AFAST	; uRet := Ctod("//")
		Case nPosTip == CALEND_POS_FIM_AFAST	; uRet := Ctod("//")
		Case nPosTip == CALEND_POS_INI_H_NOT	; uRet := 0
		Case nPosTip == CALEND_POS_FIM_H_NOT	; uRet := 0
		Case nPosTip == CALEND_POS_MIN_H_NOT	; uRet := 0
		Case nPosTip == CALEND_POS_TRAB_FERIADO	; uRet := .F.
		Case nPosTip == CALEND_POS_APON_FERIAS  ; uRet := .F.
		Case nPosTip == CALEND_POS_TP_HE_NR_FER ; uRet := ""
		Case nPosTip == CALEND_POS_TP_HE_NT_FER ; uRet := ""
		Case nPosTip == CALEND_POS_PAGINT		; uRet := ""
		Case nPosTip ==	CALEND_POS_TIPO_ORIG_DIA; uRet := "" 
		Case nPosTip ==	CALEND_POS_HE_AUTO_FER  ; uRet := .T. 
		Case nPosTip ==	CALEND_POS_CODFUNC		; uRet := "" 
		Case nPosTip ==	CALEND_POS_DEPTO		; uRet := "" 
		Case nPosTip ==	CALEND_POS_POSTO		; uRet := "" 
		Case nPosTip ==	CALEND_POS_PERIODO		; uRet := "" 
		Case nPosTip ==	CALEND_POS_ROTEIRO		; uRet := "" 
		Case nPosTip ==	CALEND_POS_PROCESSO		; uRet := "" 
		Case nPosTip ==	CALEND_POS_NUM_PAGTO	; uRet := "" 
		Case nPosTip ==	CALEND_POS_JORN			; uRet := "" 
		Case nPosTip ==	CALEND_POS_P2ID			; uRet := "" 
		Case nPosTip ==	CALEND_POS_R8ID			; uRet := "" 
		Case nPosTip ==	CALEND_POS_DATA_APO		; uRet := "" 
		Case nPosTip ==	CALEND_POS_JND_CON		; uRet := "" 
		Case nPosTip ==	CALEND_POS_LIE			; uRet := "" 
		Case nPosTip ==	CALEND_POS_LSE			; uRet := "" 
		Case nPosTip ==	CALEND_POS_LIS			; uRet := "" 
		Case nPosTip ==	CALEND_POS_LSS			; uRet := "" 
		Case nPosTip ==	CALEND_POS_INTSREP		; uRet := "" 		
	EndCase
Else
	nRetPosTab := nPosTab
EndIF

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Restaura o Conteudo do Calendario por Turno        		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF !Empty( aSvTabsCal )
	SetTabCal( aSvTabsCal )
EndIF	

Return( uRet )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁRstTabPadrao	ЁAutorЁMarinaldo de Jesus Ё Data Ё11/03/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁReinicializa as Staticas utilizadas em fTabPadrao()        	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RstTabPadrao()
Return( ( __nLstTabPadPos := NIL ) )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁCriaCalendЁ Autor Ё Marinaldo de Jesus    Ё Data Ё15/12/2003Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁAlimenta um Array com o Calend═rio de um Per║odo.           Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >								    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       Ё Generico                                                   Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function CriaCalend(	dDataIni	,; //01 -> Data Inicial do Periodo
		 				dDataFim	,; //02 -> Data Final do Periodo
						cTno		,; //03 -> Turno Para a Montagem do Calendario
						cSeq		,; //04 -> Sequencia Inicial para a Montagem Calendario
						aTabPadrao	,; //05 -> Array Tabela de Horario Padrao
						aTabCalend	,; //06 -> Array com o Calendario de Marcacoes
						cFil		,; //07 -> Filial para a Montagem da Tabela de Horario
						cMat		,; //08 -> Matricula para a Montagem da Tabela de Horario
						cCc			,; //09 -> Centro de Custo para a Montagem da Tabela
						aTurnos		,; //10 -> Array com as Trocas de Turno
						aExcePer	,; //11 -> Array com Todas as Excecoes do Periodo
						lExecQryTop ,; //12 -> Se executa Query para a Montagem da Tabela Padrao
						lSncMaMe	,; //13 -> Se executa a funcao se sincronismo do calendario
						lForceNew	,; //14 -> Se Forca a Criacao de Novo Calendario
						aMarcacoes  ;  //15 -> Array com marcacoes para tratamento de Turnos Opcionais
					)

Local lCriaCalOk	:= .T.
Local lNewCalend	:= .F.
Local lChkMat		:= ( cMat <> NIL )
Local lAcumulado	:= .F.
Local aTipo
Local dDataAux
Local dPerIni
Local dPerFim
Local dPerAuxIni
Local dPerAuxFim
Local dIniCalend
Local dFimCalend
Local bQualSeq
Local nPosTrcT
Local nLoop
Local nLoops

DEFAULT lSncMaMe	:= .F.
DEFAULT lForceNew	:= .T.
DEFAULT aMarcacoes	:= {}
DEFAULT __lChkTnoOpc	:= IF( ( ( SR6->(FIELDPOS( "R6_TNOOPC" )) != 0) .and.  ( SuperGetMv("MV_TNOOPC",NIL,"N") == "S" ) ) ,.T. , .F. )   // ATENCAO ALTERAR ESSA LINHA ANTES de SUBIR
DEFAULT lPnmTabCalen	:= ExistBlock( "PNMTABC01" )

Begin Sequence

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Garanto que dDataFim nunca sera menor que dDataIni          Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( dDataFim < dDataIni )
		dDataAux := dDataIni
		dDataIni := dDataFim
		dDataFim := dDataAux	
	EndIF

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Verifica se Devera Criar Novo Calendario                    Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( ( lChkMat ) .and. ( lForceNew ) )
		IF ( ( __dPerCalIni == NIL ) .or. ( __dPerCalFim == NIL ) )
			IF !( lCriaCalOk := GetPonMesDat( @__dPerCalIni , @__dPerCalFim , cFil ) )
				Break
			EndIF
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Garanto que __dPerCalFim nunca sera menor que __dPerCalIni  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF ( __dPerCalFim < __dPerCalIni )
				dDataAux 		:= __dPerCalIni
				__dPerCalIni	:= __dPerCalFim
				__dPerCalFim	:= dDataAux	
			EndIF
		EndIF	
		dPerIni := __dPerCalIni
		dPerFim := __dPerCalFim
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Forca a Criacao de um novo Calendario sempre que o   PeriodoЁ
		Ё for Diferente do Periodo Atual para que Busquemos o Turno	 eЁ
		Ё a Sequencia Referentes a Data Inicial de Geracao do  CalendaЁ
		Ё rio														  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		lNewCalend := ( dDataIni <> dPerIni )	
	Else
		dPerIni := dDataIni
		dPerFim := dDataFim
	EndIF					  

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Para Periodos Anteriores Criar novo Calendario apenas QuandoЁ
	Ё nao Existir Troca de Turno para o Inicio do Periodo         Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( ( lChkMat ) .and. ( lForceNew ) )
		IF !( lNewCalend ) 
			IF ( dDataFim < dPerIni )
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Remonta o Calendario Apenas se Nao Existir Troca de Turno paЁ
				Ё ra o Primeiro dia da Montagem do Calendario                 Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				fTrocaTno( Min( dPerIni , dDataIni ) , Max( dPerFim , dDataFim ) , @aTurnos , NIL , NIL , .F. )
				IF ( lNewCalend := ( ( nPosTrcT := aScan( aTurnos , { |x| x[2] == dDataIni } ) ) == 0 ) )
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Para Periodos Anteriores Criar novo Calendario apenas QuandoЁ
					Ё nao Existir Troca de Turno para o Inicio do Periodo         Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					IF ( Len( aTurnos ) > 0 )
						dPerIni	:= aTurnos[ 01 , 02 ]
						dPerFim := ( dPerIni + ( ( dDataFim - dDataIni ) + 1 ) )
						cTno	:= aTurnos[ 01 , 01 ]
						cSeq	:= aTurnos[ 01 , 03 ]
					EndIF
				Else
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Se Tiver Troca de Turno, os Turnos e Sequencias Serao  RetorЁ
					Ё nados pelo Proprio Calendario                               Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					dPerIni := dDataIni
					dPerFim := dDataFim
					cTno	:= aTurnos[ nPosTrcT , 01 ]
					cSeq	:= aTurnos[ nPosTrcT , 03 ]
				EndIF
			EndIF	
		Else
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Remonta o Calendario Apenas se Nao Existir Troca de Turno paЁ
			Ё ra o Primeiro dia da Montagem do Calendario                 Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			fTrocaTno( Min( dPerIni , dDataIni ) , Max( dPerFim , dDataFim ) , @aTurnos , NIL , NIL , .F. )
			IF !( lNewCalend := ( ( nPosTrcT := aScan( aTurnos , { |x| x[2] == dDataIni } ) ) == 0 ) )
				dPerIni	:= dDataIni
				dPerFim	:= dDataFim
				cTno	:= aTurnos[ nPosTrcT , 01 ]
				cSeq	:= aTurnos[ nPosTrcT , 03 ]
			EndIF
		EndIF
	EndIF

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Verifica a Data para a Montagem do 1o Calendario			  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( lNewCalend )
		IF ( dDataIni > dPerFim )
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Inicio do Periodo Solicitado Posterior ao Periodo em Aberto Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF ( aScan( aTurnos , { |x| x[2] > dPerFim .and. x[2] <= dDataFim } ) > 0 )
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Se Houver Troca de Turno, considera a Menor e a Maior   DataЁ
				Ё para a Montagem do Calendario para que sejam Consideradas asЁ
				Ё Trocas de Turno											  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				dIniCalend	:= Min( dPerIni , dDataIni )
				dFimCalend	:= Max( dPerFim , dDataFim )
			Else
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Caso Contrario o Turno e a Sequencia serao retornados   pelaЁ
				Ё fQualSeq()												  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				dIniCalend	:= dPerIni
				dFimCalend	:= dPerFim
			EndIF
		ElseIF ( dDataFim < dPerIni )
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Final do Periodo Solicitado Anterior ao Periodo em Aberto   Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			dIniCalend	:= dPerIni
			dFimCalend	:= dPerFim
		ElseIF ( dDataIni <> dPerIni )
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Periodo Solicitado Diferente do Periodo em Aberto			  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			dIniCalend	:= Min( dPerIni , dDataIni )
			dFimCalend	:= Max( dPerFim , dDataFim )
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Se Nao Tiver Troca de Turno no Inicio do Periodo para a GeraЁ
			Ё cao do Primeiro Calendario, Verifica o Periodo Anterior	  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF ( aScan( aTurnos , { |x| x[2] == dIniCalend } ) == 0 )
				dPerAuxIni := dPerIni
				dPerAuxFim := dPerFim
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Cria o Calendario do Periodo Anterior                       Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF !( lCriaCalOk := PerAponta( @dPerAuxIni , @dPerAuxFim , ( dPerIni - 1 ) , .F. , cFil , .T. , NIL , .F. , .T. ) )
					Break
				EndIF
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Carrega as Trocas de Turno a Partir do Inicio do Periodo  AnЁ
				Ё Terior													  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				fTrocaTno( dPerAuxIni , dFimCalend , @aTurnos , NIL , NIL , .F. )
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Busca a Primeira Troca inferior ao Periodo para a Geracao doЁ
				Ё Calendario          										  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF ( ( nPosTrcT := aScan( aTurnos , { |x| x[2] <= dIniCalend } ) ) > 0 )
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Busca a Troca mais Proxima                                  Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					nLoops := ( nPosTrcT + 1 )
					While ( ( nLoops := aScan( aTurnos , { |x| x[2] <= dIniCalend } , nLoops ) ) > 0 )
						nPosTrcT := nLoops
						++nLoops
					End While
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Adiciona a Troca de Turno para o Inicio do Periodo para a GeЁ
					Ё racao do Calendario										  Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					IF ( nPosTrcT > 0 )
						aAdd( aTurnos , aClone( aTurnos[ nPosTrcT ] ) )
						aTurnos[ Len( aTurnos ) , 02 ] := dIniCalend
						/*/
						зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Ordena as Trocas por Ordem de Data						  Ё
						юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						aSort( @aTurnos , NIL , NIL , { |x,y| ( x[2] < y[2] ) } )
					EndIF
				EndIF
			EndIF
		EndIF
	Else
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Neste Caso o Periodo Solicitado eh Equivalente ao Periodo emЁ
		Ё Aberto													  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		dIniCalend	:= dPerIni
		dFimCalend	:= dPerFim
	EndIF     
    
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Verifica Se Calendario e do Periodo Anterior			  	  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
    lAcumulado := ( dFimCalend < dPerIni )
	
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Cria o Calendario do Periodo Atual       				  	  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF !( lCriaCalOk := CalendCria(	dIniCalend								,; //01 -> Data Inicial do Periodo
		 		  					dFimCalend								,; //02 -> Data Final do Periodo
				  					cTno									,; //03 -> Turno Para a Montagem do Calendario
				  					cSeq									,; //04 -> Sequencia Inicial para a Montagem Calendario
					  				@aTabPadrao								,; //05 -> Array Tabela de Horario Padrao
					  				@aTabCalend								,; //06 -> Array com o Calendario de Marcacoes
					  				cFil									,; //07 -> Filial para a Montagem da Tabela de Horario
					  				cMat									,; //08 -> Matricula para a Montagem da Tabela de Horario
					  				cCc										,; //09 -> Centro de Custo para a Montagem da Tabela
				  					@aTurnos								,; //10 -> Array com as Trocas de Turno
				  					@aExcePer								,; //11 -> Array com Todas as Excecoes do Periodo
				  					lExecQryTop 							,; //12 -> Se executa Query para a Montagem da Tabela Padrao
				  					( ( lSncMaMe ) .and. !( lNewCalend ) )	,; //13 -> Se executa a funcao se sincronismo do calendario
				  					lAcumulado								,; //14 -> Se o Calendario eh do periodo anterior
				  					aMarcacoes								;  //15 -> Array de Marcacoes para tratamento de Turnos Opcionais
					  			);
		 )				  			
		Break
	EndIF

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Se nao for Criar novo Calendario, Abandona				  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF !( lNewCalend )
		Break
	EndIF

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Obtem o Turno para o Novo Calendario       			  	  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	cTno	:= GetInfoPosTab(	CALEND_POS_TURNO	,;	//01 -> Posicao em aTabCalend para Obtencao da Informacao
								"1E"				,;	//02 -> Flag da Marcacao "1E,1S,..."
								dDataIni			,;	//03 -> Data em aTabCalend
								aTabCalend			 ;	//04 -> Calendario de Marcacoes
				   		 	)
	IF Empty( cTno )
		IF ( dDataFim < dPerIni )
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Pode Ocorrer Turno em Branco para Periodo Anterior		  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			cTno := GetInfoPosTab(	CALEND_POS_TURNO	,;	//01 -> Posicao em aTabCalend para Obtencao da Informacao
									"1E"				,;	//02 -> Flag da Marcacao "1E,1S,..."
									dIniCalend			,;	//03 -> Data em aTabCalend
									aTabCalend			 ;	//04 -> Calendario de Marcacoes
					   		 	 )
		Else
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Ou Quando a Existe Jornada Continua e a Data Inicial nao corЁ
			Ё responte ao Inicio da Jornada								  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			aTipo	:= { "1E" , "1S" , "2E" , "2S" , "3E" , "3S" , "4E" , "4S" }
			nLoops	:= Len( aTipo )
			For nLoop := 2 To nLoops
				cTno := GetInfoPosTab(	CALEND_POS_TURNO	,;	//01 -> Posicao em aTabCalend para Obtencao da Informacao
										aTipo[ nLoop ]		,;	//02 -> Flag da Marcacao "1E,1S,..."
										dDataIni			,;	//03 -> Data em aTabCalend
										aTabCalend			 ;	//04 -> Calendario de Marcacoes
					 	 			  )
				IF !Empty( cTno )
					Exit
				EndIF
			Next nLoop
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Se ainda assim nao achou o turno, procura a Partir do  PerioЁ
			Ё do Final do Periodo em Aberto                               Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF Empty( cTno )
				dPerIni := ( dPerFim - 1 )
				While ( Empty( cTno ) .and. ( ( ++dPerIni ) < dDataFim ) )
					For nLoop := 1 To nLoops
						cTno := GetInfoPosTab(	CALEND_POS_TURNO	,;	//01 -> Posicao em aTabCalend para Obtencao da Informacao
												aTipo[ nLoop ]		,;	//02 -> Flag da Marcacao "1E,1S,..."
												dPerIni				,;	//03 -> Data em aTabCalend
												aTabCalend			 ;	//04 -> Calendario de Marcacoes
							 	 			  )
						IF !Empty( cTno )
							Exit
						EndIF
					Next nLoop
				End While
			EndIF
		EndIF
	EndIF					   		 	

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Obtem a Sequencia para o Novo Calendario       			  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	cSeq	:= GetInfoPosTab(	CALEND_POS_SEQ_TURNO	,;	//01 -> Posicao em aTabCalend para Obtencao da Informacao
								"1E"					,;	//02 -> Flag da Marcacao "1E,1S,..."
								dDataIni				,;	//03 -> Data em aTabCalend
								aTabCalend				 ;	//04 -> Calendario de Marcacoes
				   		 	)

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Retorna a Sequencia do Proximo Periodo 					  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	bQualSeq	:= { || IF( Empty( cSeq ) , fQualSeq( aClone( aTabCalend ) , @aTabPadrao , dDataIni , cTno, aClone( aTurnos ) ) , cSeq ) }

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Cria o Calendario do Periodo Selecionado					  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF !( lCriaCalOk := CalendCria(	dDataIni			,; //01 -> Data Inicial do Periodo
		 		  					dDataFim			,; //02 -> Data Final do Periodo
					  				cTno				,; //03 -> Turno Para a Montagem do Calendario
					  				Eval( bQualSeq )	,; //04 -> Sequencia Inicial para a Montagem Calendario
					  				@aTabPadrao			,; //05 -> Array Tabela de Horario Padrao
					  				@aTabCalend			,; //06 -> Array com o Calendario de Marcacoes
					  				cFil				,; //07 -> Filial para a Montagem da Tabela de Horario
				  					cMat				,; //08 -> Matricula para a Montagem da Tabela de Horario
				  					cCc					,; //09 -> Centro de Custo para a Montagem da Tabela
				  					@aTurnos			,; //10 -> Array com as Trocas de Turno
					  				@aExcePer			,; //11 -> Array com Todas as Excecoes do Periodo
					  				lExecQryTop 		,; //12 -> Se executa Query para a Montagem da Tabela Padrao
					  				lSncMaMe			 ; //13 -> Se executa a funcao se sincronismo do calendario
					  			);
		 )				  			
		Break
	EndIF			  			
	
End Sequence

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Ponto de Entrada para edicao do array aTabCalend             Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( lPnmTabCalen )
	IF ( ValType( uRet := ExecBlock("PNMTABC01",.F.,.F., { aTabCalend, lCriaCalOk }) ) == "A" )
		aTabCalend := aClone(uRet)
		uRet	   := NIL
	EndIF
EndIF
Return( lCriaCalOk )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁRstCriaCalend	ЁAutorЁMarinaldo de Jesus Ё Data Ё11/03/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁReinicializa as Staticas utilizadas em CriaCalend()        	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RstCriaCalend()

__dPerCalIni	:= NIL
__dPerCalFim	:= NIL

Return( NIL )

/*/
зддддддддддбддддддддддбддддддддддбддддддддддддддддддддддбддддбдддддддддд©
ЁFun┤└o    ЁCalendCriaЁAutores   Ё                      Ё    Ё          Ё
Ё          Ё          ЁVersao I  ЁEquipe Advanced RH    ЁDataЁ24/11/1997Ё
Ё          Ё          ЁVersao II ЁMarinaldo de Jesus    ЁDataЁ18/09/2003Ё
цддддддддддеддддддддддаддддддддддаддддддддддддддддддддддаддддадддддддддд╢
ЁDescri┤└o ЁAlimenta um Array com o Calend═rio de um Per║odo.           Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >								    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function CalendCria(	dDataIni	,; //01 -> Data Inicial do Periodo
		 				dDataFim	,; //02 -> Data Final do Periodo
						cTno		,; //03 -> Turno Para a Montagem do Calendario
						cSeq		,; //04 -> Sequencia Inicial para a Montagem Calendario
						aTabPadrao	,; //05 -> Array Tabela de Horario Padrao
						aTabCalend	,; //06 -> Array com o Calendario de Marcacoes
						cFil		,; //07 -> Filial para a Montagem da Tabela de Horario
						cMat		,; //08 -> Matricula para a Montagem da Tabela de Horario
						cCc			,; //09 -> Centro de Custo para a Montagem da Tabela
						aTurnos		,; //10 -> Array com as Trocas de Turno
						aExcePer	,; //11 -> Array com Todas as Excecoes do Periodo
						lExecQryTop ,; //12 -> Se executa Query para a Montagem da Tabela Padrao
						lSncMaMe	,; //13 -> Se executa a funcao se sincronismo do calendario
						lAcumulado	,; //14 -> Se o Calendario eh do Periodo anterior 
						aMarcacoes  ;  //15 -> Array de marcacoes para tratamento de Turnos Opcionais
					)

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Variaveis de Inicializacao Obrigatoria					  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Local aMarcId	 		:= { NIL , NIL }
Local aTipo				:= { "1E" , "1S" , "2E" , "2S" , "3E" , "3S" , "4E" , "4S" }
Local aOrdens			:= {}
Local cOrdem			:= ""
Local dDataApo			:= Ctod("")
Local lCriaCalOk		:= .T.
Local lForceSinc		:= .F.
Local lExistTrcTno 		:= .F.
Local lBldNewOrd		:= .F. 
Local lPerAcum			:= .F.
Local nDias				:= 0 
Local nSeq				:= 0
Local nFornY			:= Len( aTipo )
Local nOrdem			:= 0                                          

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Variaveis que serao inicializadas para Turnos Opcionais	  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/     
Local aDiaTurnoOK
/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Variaveis que serao inicializadas no Corpo da Funcao		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/     
Local aExcecoes
Local aSpaReturn	:= {}
Local aSr6Return	:= {}
Local aTabTno
Local aTabOrig
Local aAfasta   
Local aSvAlias		:= {}

Local bAsc

Local cFilSP3
Local cFilSRA
Local cFilSPJ
Local cFilSR6
Local cFilSPA
Local cReg
Local cRegOrig
Local cTipoDia
Local cTipAfas 
Local cTnoOpc
Local cTpExNorFer
Local cTpExNotFer
Local cPagInt
Local cKeyAtu
Local cNewTno
Local cNewReg
Local cCcCal

Local dData
Local dIniAfas
Local dFimAfas

Local lExce
Local lExceData
Local lJndC
Local lFeriado
Local lIncrementa	:= .F.  //Incremento do dia de apontamento para jornada continua
Local lChkMat
Local lChkCc
Local lAfastper
Local lAfast
Local lAponFer
Local lTrbFeriado 
Local lHeAutoFer
Local lTrocaTno  
Local lTnoOpcData
Local lAllTnoOpc
Local lBldCalTnoSeq
Local lNewTno
Local lNewReg

Local nPos
Local nX
Local nFornX
Local nY  
Local nTno
Local nLenCalend
Local nPosOrdem
Local nSerial
Local nIniHnot
Local nFimHnot
Local nMinHNot
Local nHrTrab
Local nHrInte
Local nPosRg		:= 0 
Local nPosTr		:= 0

DEFAULT cTno			:= IF( Type( "SRA->RA_TNOTRAB" ) != "U" , SRA->RA_TNOTRAB	,  "" )
DEFAULT cSeq			:= IF( Type( "SRA->RA_SEQTURN" ) != "U" , SRA->RA_SEQTURN	,  "" )
DEFAULT aTabPadrao		:= {}
DEFAULT cFil			:= IF( Type( "SRA->RA_FILIAL" ) != "U" , SRA->RA_FILIAL		,  "" )
DEFAULT lSncMaMe		:= .F.
DEFAULT lAcumulado		:= .F. 
DEFAULT aMarcacoes		:= {}

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Obtem a Filial Para a Pesquisa das Excecoes                 Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
cFilSRA := cFil

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Obtem a Filial Para a Pesquisa dos Feriados                 Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
cFilSP3	:= xFilial( "SP3" , cFil )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Obtem a Filial Para a Montagem do Calendario                Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
cFilSPJ := xFilial( "SPJ" , cFil )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Obtem a Filial do SR6                                       Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
cFilSR6 := xFilial( "SR6" , cFil )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Obtem a Filial do SPA                                       Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
cFilSPA	:= xFilial( "SPA" , cFil )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Verifica se Passou Centro de Custo e Matricula              Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
lChkMat := !( cMat == NIL )
lChkCc	:= !( cCc  == NIL )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Se passou a Matricula Carrega as Trocas de Tuno do Periodo  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( lChkMat )
	IF Empty( aTurnos )
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Carrega as Trocas de Turno/Regra do Periodo				  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		DEFAULT aTurnos := {}
		lTrocaTno := fTrocaTno( dDataIni , dDataFim , @aTurnos , NIL , cSeq )
	Else
		lTrocaTno := .T.
	EndIF
	IF ( ( nPos := aScan( aTurnos , { |x| x[2] == dDataIni } ) ) > 0 )
		cTno 	:= aTurnos[ nPos , 01 ]
		cSeq	:= aTurnos[ nPos , 03 ]
		cReg 	:= aTurnos[ nPos , 05 ]
	Else
		cReg	:= SRA->RA_REGRA
	EndIF	
Else
	cReg	:= IF( Type( "SRA->RA_REGRA" ) != "U" , SRA->RA_REGRA , cReg )
EndIF

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Salva Turno, Sequencia e Regra Iniciais                     Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
cNewTno	:= cTno
cNewReg	:= cReg

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Obtem a Sequencia Inicial do Turno                          Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
nSeq := Val( cSeq )

#IFDEF TOP
	IF !( lExInAs400 )
		aExcePer := {}
		IF ( lExce := ( lChkCc .and. lChkMat ) )
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Carrega Todas as Excecoes do Periodo Quando o RDD for TOP   Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			lExce := GetExceTop( cFilSRA , cMat , cCc , aTurnos , dDataIni , dDataFim , @aExcePer )
		EndIF
	Else
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Neste Caso o Array aExcePer foi Passado como Parametro      Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( lExce := ( lChkCc .and. lChkMat ) )
			lExce := !( ( ValType( aExcePer ) == "A" ) .and. Empty( aExceper ) )
		EndIF
	EndIF
#ELSE
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Neste Caso o Array aExcePer foi Passado como Parametro      Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( lExce := ( lChkCc .and. lChkMat ) )
		lExce := !( ( ValType( aExcePer ) == "A" ) .and. Empty( aExceper ) )
	EndIF	
#ENDIF	

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Carrega os Afastamentos Referente ao Periodo                Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( lAfastper := ( lChkMat ) )
	lAfastper := fAfastaPer( @aAfasta , dDataIni , dDataFim , cFilSRA , cMat )
EndIF	

Begin Sequence

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Monta a Chave Atual                                         Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	DEFAULT cNewReg := "__cNewReg__"
	cKeyAtu := ( cEmpAnt + cFil + Dtos( dDataIni ) + Dtos( dDataFim ) + cNewTno + cSeq + cNewReg + AllToChar( lSncMaMe ) )
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Verifica se Houve alteracao ou se o Calendario para o  TurnoЁ
	Ё esta vazio e Recria										  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( lBldCalTnoSeq := ( !( cKeyAtu == __cKeyBldCal ) .or. Empty( __aLstTabCal ) ) )
		aTabCalend		:= {}	
		aTabTno			:= {}
		__aLstTabCal	:= {}
		__aLstTabTno	:= {}
		__cKeyBldCal	:= cKeyAtu
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Monta o Calendario de Marcacoes padrao para o   Turno/SequenЁ
		Ё cia Corrente												  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF !( lCriaCalOk := BldCalTnoSeq(	dDataIni		,;	//01 -> Data Inicial do Periodo
											dDataFim		,;	//02 -> Data Final do Periodo
											aTipo			,;	//03 -> Tipos de Marcacoes Possiveis
											cNewTno			,;	//04 -> Turno Para a Montagem do Calendario
											cSeq			,;	//05 -> Sequencia Inicial para a Montagem Calendario
											cNewReg			,;	//06 -> Regra do Funcionario
											@aTabPadrao		,;	//07 -> Array Tabela de Horario Padrao
											@aTabCalend		,;	//08 -> Array com o Calendario de Marcacoes
											@aTabTno		,;	//09 -> Tabela do Turno Corrente
											cFil			,;	//10 -> Filial para a Montagem da Tabela de Horario
											lExecQryTop 	,;	//11 -> Se executa Query para a Montagem da Tabela Padrao
											lSncMaMe		 ;	//12 -> Se executa a funcao se sincronismo do calendario	
										);
			)							 	
			Break
		EndIF
		__aLstTabCal	:= aClone( aTabCalend )
		__aLstTabTno	:= aClone( aTabTno )
	EndIF

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Inicializa o Array aTabCalend ( Calendario das Marcacoes )  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	aTabCalend := aClone( __aLstTabCal )

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Carrega Informacoes Especificas do Funcionario              Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( lChkMat )

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Carrega a Tabela do Turno Corrente				  		  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		aTabTno := aClone( __aLstTabTno )    
		
		/*
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Obtem todos os Turnos Opcionais			                   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/    
		lAllTnoOpc := .F.
		If __lChkTnoOpc
			If lTrocaTno                     
				For nTno:= 1 To Len(aTurnos)               
					//-- Carrega todos os horarios opcionais do turno
			    	If LoadTnoOpc(cFilSPJ, aTurnos[nTno, 1],__aAllTnoOpc, @aTabPadrao)
			    	   lAllTnoOpc := .T.
			    	Endif   
			    Next
			Else
				//-- Carrega todos os horarios opcionais do turno
			    If LoadTnoOpc(cFilSPJ, cNewTno,__aAllTnoOpc, @aTabPadrao)
		    	   lAllTnoOpc := .T.
		    	Endif   
			Endif  
        Endif
        
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Carrega as Marcacoes do Funcionario para Ajustar os Turnos  Ё
		Ё em funcao da existencia de turnos opcionais				  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/	        
		If lAllTnoOpc 
			If Empty(aMarcacoes) 
				GetMarcOpc(	@aMarcacoes						,;	//01 -> Marcacoes dos Funcionarios
							dDataIni 						,;	//02 -> Periodo Inicial
							dDataFim 						,;	//03 -> Periodo Final
							cFil							,;	//04 -> Filial
							cMat							,;	//05 -> Matricula
							cTno							,;	//06 -> Turno
							cSeq							,;	//07 -> Sequencia de Turno
							cCc								,;	//08 -> Centro de Custo 
							If(lAcumulado, "SPG", "SP8")     ; //09 -> Obtem as marcacoes do Alias conforme o periodo considerado.
						  )         
			Endif  		  
	    Endif    

	    /*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Loop For/Next para a Carga das Marcacoes do Periodo         Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		aDiaTurnoOk:= {}
		nFornX := ( dDataFim - dDataIni )
		For nX := 0 To nFornX
		
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Data a ser verificada										  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			dData := ( dDataIni + nX )
			
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё A Sequencia eh incrementada a Cada Segunda Feira			  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF ( ( nX != 0 ) .and. ( Dow( dData ) == 2 ) )
				nSeq++
			EndIF 
			
			IF ( lIncrementa ) 
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Verifica se a Sequ┬ncia atual est═ cadastrada na Tabela. PesЁ
				Ё quisa a Sequencia Primeiro com o StrZero( n , 1 ) "0" e   DeЁ
				Ё pois com StrZero( n , 2 ) "00"						      Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				bAsc := { |x| AllTrim( x[19] ) == StrZero( nSeq , IF( nSeq < 10 , 1 , 2 ) ) .or. AllTrim( x[19] ) == StrZero( nSeq , 2 ) }
				nSeq := IF( aScan( aTabTno , bAsc ) == 0 , 1 , nSeq )

				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Para Jornada Continua corre todas as datas para que seja    Ё
				Ё verificada se alguma segunda-feira ocorre durante a jornada Ё
				Ё e, assim, incrementarmos a sequencia.						  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			    If nDias > 0
			      --nDias 
			      Loop
			    Endif   
			    lIncrementa := .F.
			EndIF 
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Ordem da Marcacao     									  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			nOrdem++
			cOrdem		:= StrZero( nOrdem , Max( __nTamP8Ordem , Len( AllTrim( Str( nOrdem ) ) ) ) )
			dDataApo	:= dData
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Procura a Ordem no Calendario Generico					  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF (; 
					(;
						nPosOrdem := aScan( __aLstTabCal , { |x|;
																( x[ CALEND_POS_ORDEM ] == cOrdem ) .and.;
																( x[ CALEND_POS_TIPO_MARC ] == "1E" );
														    };
							     		  );
					) == 0 ;
				)
				Loop
			EndIF													     		  

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Se houver Sincronismo, adiciona a Ordem          		  	  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF ( lSncMaMe )
				aAdd( aOrdens , cOrdem )
			EndIF	

			//-- Prepara tabela de verificacao de turnos
			If lAllTnoOpc
				AADD(aDiaTurnoOK, {dData, SPACE(1) })
			Endif

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Pesquisa as Trocas de Turno/Sequencia/Regra Durante o  PerioЁ
			Ё do														  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF (;
					( lTrocaTno );
					.and.;
					( dDataIni != dData );
					.and.;
					( ( nPos := aScan( aTurnos , { |x| x[2] == dData } ) ) > 0 );
				)	
				lExistTrcTno	:= .T.
				cNewTno 		:= aTurnos[ nPos , 01 ]
				cSeq	 		:= aTurnos[ nPos , 03 ]
				cNewReg 		:= aTurnos[ nPos , 05 ]
				nSeq			:= Val( cSeq )
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Carrega a Tabela Para o Novo Turno de Acordo com as Trocas  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				fTabPadrao( @aTabPadrao , @cFilSPJ , cNewTno , lExecQryTop )
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Pesquisa e Carrega a Tabela do Turno Corrente				  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF ( lCriaCalOk := ( nPos := aScan( aTabPadrao, { |x| x[2] == cNewTno .and. ( x[1] == cFilSPJ .or. Empty( x[1] ) ) } ) ) > 0 )
					aTabTno := aClone( aTabPadrao[ nPos , 3 ] )
				Else
					Break
				EndIF
			EndIF
	
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Verifica se a Sequ┬ncia atual est═ cadastrada na Tabela. PesЁ
			Ё quisa a Sequencia Primeiro com o StrZero( n , 1 ) "0" e   DeЁ
			Ё pois com StrZero( n , 2 ) "00"						      Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			bAsc := { |x| AllTrim( x[19] ) == StrZero( nSeq , IF( nSeq < 10 , 1 , 2 ) ) .or. AllTrim( x[19] ) == StrZero( nSeq , 2 ) }
			nSeq := IF( aScan( aTabTno , bAsc ) == 0 , 1 , nSeq )
	
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁVerifica se o Dia da Semana da Sequencia e equivalente ao DiaЁ
			Ёda Data a Ser Pesquisada. Pesquisa a Sequencia  Primeiro  comЁ
			Ёo StrZero( n , 1 ) "0" e Depois com o StrZero( n , 2 ) "00"  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			bAsc := { |x| (	AllTrim( x[19] ) == StrZero( nSeq , IF( nSeq < 10 , 1 , 2 ) ) .or. AllTrim( x[19] ) == StrZero( nSeq , 2 ) ) ;
						  .and. x[20] == Dow(dData);
					 }
			IF !( lCriaCalOk := ( nPos := aScan( aTabTno , bAsc ) ) > 0 )
				Break
			EndIF

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Verifica se na Data Houve Excecao e Substitui os Horarios daЁ
			Ё Tabela      												  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			lExceData := .F.
			IF (;
					( lExce );
					.and.;
					( lChkCc );
				)
				aExcecoes := {}
				cTipoDia  := aTabTno[nPos,18]
				IF (;
						( lExce );
						.and.;
						GetExcecoes( @aExcecoes , cNewTno , cCC , cFilSRA , cMat , dData , @cTipoDia , aExcePer );
					 )
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Salva a Tabela Padrao/Regra da Semana Que Serao  ModificadosЁ
					Ё em Funcao de Excecoes										  Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					aTabOrig  := aClone( aTabTno )
					cRegOrig  := cNewReg
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Se Houver Excecoes na Data Substitui os Horarios/Regra pelosЁ
					Ё da Excecao  												  Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					IF (;
							lExceData := (;
											!Empty( aExcecoes ) .and. ;
											(;
												Empty( aExcecoes[ 01 , 33 ] ) .or.;
												( aExcecoes[ 01 , 33 ] == cTipoDia );
											);
										);
						)
						IF ( aExcecoes[01,46] <> "S" )					// Assume o Horario das Excecooes
							aTabTno[nPos,01] 	:= aExcecoes[01,05]		// 01 - 1a Entrada
							aTabTno[nPos,02] 	:= aExcecoes[01,06]		// 02 - 1a Saida
							aTabTno[nPos,03] 	:= aExcecoes[01,07]		// 03 - 2a Entrada
							aTabTno[nPos,04] 	:= aExcecoes[01,08]		// 04 - 2a Saida
							aTabTno[nPos,05] 	:= aExcecoes[01,09]		// 05 - 3a Entrada
							aTabTno[nPos,06] 	:= aExcecoes[01,10]		// 06 - 3a Saida
							aTabTno[nPos,07] 	:= aExcecoes[01,11]		// 07 - 4a Entrada
							aTabTno[nPos,08] 	:= aExcecoes[01,12]		// 08 - 4a Saida
							aTabTno[nPos,09] 	:= aExcecoes[01,16]		// 09 - Horas Trabalhadas 1a. Jornada
							aTabTno[nPos,10] 	:= aExcecoes[01,17]		// 10 - Horas Trabalhadas 2a. Jornada
							aTabTno[nPos,11] 	:= aExcecoes[01,18]		// 11 - Horas Trabalhadas 3a. Jornada
							aTabTno[nPos,12] 	:= aExcecoes[01,19]		// 12 - Horas Trabalhadas 4a. Jornada
							aTabTno[nPos,13] 	:= aExcecoes[01,26]		// 13 - Horas de Intervalo 1S
							aTabTno[nPos,14] 	:= aExcecoes[01,27]		// 14 - Horas de Intervalo 2S
							aTabTno[nPos,15] 	:= aExcecoes[01,28]		// 15 - Horas de Intervalo 3S
							aTabTno[nPos,16] 	:= ""					// 16 - Marcacao e do dia seguinte ?
							aTabTno[nPos,17] 	:= aExcecoes[01,20]		// 17 - Numero de Marcacoes
							aTabTno[nPos,29] 	:= aExcecoes[01,34]		// 29 - Aponta Nona Hora
							aTabTno[nPos,30] 	:= aExcecoes[01,35]		// 30 - Limite de Horario Inicial
							aTabTno[nPos,31] 	:= aExcecoes[01,36]		// 31 - Limite de Horario Final
							aTabTno[nPos,32] 	:= aExcecoes[01,37]		// 32 - 1a. Jornada Continua
							aTabTno[nPos,33] 	:= aExcecoes[01,38]		// 33 - 2a. Jornada Continua
							aTabTno[nPos,34]	:= aExcecoes[01,39]		// 34 - 3a. Jornada Continua
							aTabTno[nPos,35]	:= aExcecoes[01,40]		// 35 - 4a. Jornada Continua
							aTabTno[nPos,36]	:= aExcecoes[01,41]		// 36 - Codigo da Refeicao
						EndIF
						aTabTno[nPos,18] 	:= aExcecoes[01,23]		// 18 - Tipo do Dia
						aTabTno[nPos,19] 	:= aTabTno[ nPos, 19 ]	// 19 - Sequencia da Marcacao
						aTabTno[nPos,20] 	:= Dow( dData )      	// 20 - Numero Correspondente ao Dia da Semana
						aTabTno[nPos,21] 	:= "E"					// 21 - Flag Indicador de Excecao
						aTabTno[nPos,22] 	:= aExcecoes[01,21]		// 22 - Motivo da Excecao
						aTabTno[nPos,23] 	:= aExcecoes[01,22]		// 23 - Codigo Hora Extra Normal
						aTabTno[nPos,24] 	:= aExcecoes[01,24]		// 24 - Codigo Hora Extra Noturna
						aTabTno[nPos,25] 	:= aExcecoes[01,29]		// 25 - Centro de Custo Periodo 1 (1a.E-1a.S)
						aTabTno[nPos,26] 	:= aExcecoes[01,30]		// 26 - Centro de Custo Periodo 2 (2a.E-2a.S)
						aTabTno[nPos,27] 	:= aExcecoes[01,31]		// 27 - Centro de Custo Periodo 3 (3a.E-3a.S)
						aTabTno[nPos,28] 	:= aExcecoes[01,32]		// 28 - Centro de Custo Periodo 4 (4a.E-4a.S)
						
						cNewReg		  	 	:= aExcecoes[01,42]		// Regra de Apontamento
						nIniHnot	  	 	:= aExcecoes[01,43]		// Inicio da Hora Noturna
						nFimHnot	  	 	:= aExcecoes[01,44]		// Final da Hora Noturna
						nMinHnot	  		:= aExcecoes[01,45]		// Minutos da Hora Noturna
					EndIF
				EndIF 
			Endif  
			      
		   /*/
		   здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		   Ё Checa a Existencia de Turnos Opcionais				          Ё
		   юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/    
			lTnoOpcData := .F.
			If ! lExceData
			 	If lAllTnoOpc
				   	/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Salva a Tabela Padrao/Regra da Semana Que Serao  ModificadosЁ
					Ё em Funcao de Excecoes										  Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					aTabOrig  := aClone( aTabTno )
					cRegOrig  := cNewReg
				   ( lTnoOpcData:=GetTnoOpc( cNewTno, dData, @aDiaTurnoOK, aTabPadrao, @aTabTno[nPos], cFilSPJ, @aMarcacoes))
                Endif
			EndIF

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Verificar se o Funcionario Esta Afastado na Data			  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			dIniAfas	:= Ctod("//")
			dFimAfas	:= Ctod("//")
			cTipAfas	:= __aLstTabCal[ nPosOrdem , CALEND_POS_TIP_AFAST ]
			IF ( lAfast := ( lAfastper ) )
				lAfast := fAfasta( cFilSRA , cMat , dData , @dIniAfas , @dFimAfas , @cTipAfas , aAfasta )
			EndIF

			IF !( lBldNewOrd )
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Verifica se Teve Alguma Alteracao                		  	  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF ( lBldNewOrd := (;
										( lExistTrcTno ) .or. ;	//Troca de Turno na Data
										( lExceData	   ) .or. ;	//Excecao na Data
										( lTnoOpcData  ) .or. ;	//Turno Opcional
										( lAfast	   )  	  ;	//Afastamento na Data
									 );
					)
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Verifica se Deve Re-Sincronizar o Calendario     		  	  Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					lForceSinc := lBldNewOrd
				Else
					Loop
				EndIF
			EndIF        
	
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Carrega os Valores DEFAULT para o Dia            		  	  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			lAponFer	:= __aLstTabCal[ nPosOrdem	,	CALEND_POS_APON_FERIAS	]
			cTpExNorFer	:= __aLstTabCal[ nPosOrdem	,	CALEND_POS_TP_HE_NR_FER	]
			cTpExNotFer	:= __aLstTabCal[ nPosOrdem	,	CALEND_POS_TP_HE_NT_FER	]
			cPagInt 	:= __aLstTabCal[ nPosOrdem	,	CALEND_POS_PAGINT		]
			lFeriado 	:= __aLstTabCal[ nPosOrdem	, 	CALEND_POS_FERIADO		]
       		lTrbFeriado	:= __aLstTabCal[ nPosOrdem	,	CALEND_POS_TRAB_FERIADO	] 
       		lHeAutoFer	:= __aLstTabCal[ nPosOrdem	,	CALEND_POS_HE_AUTO_FER	] 
       		

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Define o Tipo do Dia                                    	  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			cTipoDia := aTabTno[ nPos , 18 ]

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Verifica se Teve Alteracao no Turno              		  	  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF( lNewTno	:= ( cNewTno <> cTno ) )
				cTno := cNewTno
			EndIF

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Verifica se Teve Alteracao na Regra              		  	  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF( lNewReg	:= ( cNewReg <> cReg ) )
				cReg := cNewReg
			EndIF

			IF ( nPosRg := aScan( aSpaInfo , { |x| x[1] == cFilSPA .and. x[2] == cNewReg } ) ) == 0
				#IFDEF TOP
					aSvAlias := GetArea()
						
					cCondSPA := "% PA_FILIAL = '"+cFilSPA+"' AND "
					cCondSPA += "PA_CODIGO = '"+cNewReg+"' %"
									
					cQrySPA := GetNextAlias()

					BeginSql alias cQrySPA
						SELECT PA_PAGINT, PA_FERIADO, R_E_C_N_O_ RECNO
						FROM %table:SPA% SPA
						WHERE
						%exp:cCondSPA% AND SPA.%NotDel%
					EndSql
					
					If (cQrySpa)->(!Eof())
						aAdd( aSpaInfo, { cFilSPA, cNewReg, (cQrySpa)->(PA_PAGINT), (cQrySpa)->(PA_FERIADO), (cQrySpa)->RECNO } )
						lCriaCalOk	:= .T.
						lSpaOk 		:= .T.						
						SPA->( MsGoto( (cQrySpa)->RECNO ) )						
						(cQrySPA)->(dbCloseArea())
					Else
						lCriaCalOk	:= .F.
						lSpaOk 		:= .F.
						(cQrySPA)->(dbCloseArea())
						Break
					EndIf
					
					RestArea( aSvAlias )
				#ELSE				
				
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Verifica se a Regra de Apontamento eh Valida                Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					IF !( lSpaOk := PosSPA( cNewReg , cFilSPA , NIL , 01 , .F. ) )
						lCriaCalOk	:= .F.
						lSpaOk 		:= .F.
						Break
					EndIF
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Obtem as Informacoes em Cache da Regra de Apontamento       Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					aSpaReturn := PosSPA( cNewReg , cFilSPA , aSpaStruct , 01 , .F. )
                    aAdd( aSpaInfo, { cFilSPA, cNewReg, aSpaReturn[1], aSpaReturn[2], SPA->( RECNO() ) } )

				#ENDIF
				
				nPosRg 	:= aScan( aSpaInfo , { |x| x[1] == cFilSPA .and. x[2] == cNewReg } )
				cPagInt := aSpaInfo[nPosRg, 3]

			Else
				lCriaCalOk	:= .T.
				lSpaOk 		:= .T.										
				cPagInt := aSpaInfo[nPosRg, 3]
				SPA->( MsGoto( aSpaInfo[nPosRg, 5] ) )
			EndIf

			If !lSpaOk
				lCriaCalOk	:= .F.
				Break
			EndIf

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Verifica Se o Dia em Questao eh um Feriado				  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			lTrbFeriado := .F.
			IF ( lFeriado := __aLstTabCal[ nPosOrdem , CALEND_POS_FERIADO ] )
				lTrbFeriado := ( aSpaInfo[nPosRg, 4] == "S" )
       		EndIF

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё As horas extras para funcionario em ferias sao por padrao	  Ё
			Ё autorizadas.												  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/			
			lHeAutoFer	:= .T.
			
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Se nao Existir Excecao na Data Redefine o Tipo do Dia   	  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF !( lExceData )

				IF ( nPosTr := aScan( aSr6Info , { |x| x[1] == cFilSPJ .and. x[2] == cTno } ) ) == 0
					#IFDEF TOP
						aSvAlias := GetArea()
							
						cCondSR6 := "% R6_FILIAL = '"+cFilSPJ+"' AND "
						cCondSR6 += "R6_TURNO  = '"+cTno+"' %"
										
						cQrySR6 := GetNextAlias()
						
						BeginSql alias cQrySR6
							SELECT R6_INIHNOT, R6_FIMHNOT, R6_MINHNOT, R6_APODFER, R6_TPEXFER, R6_TPEXFEN, R6_AUTOHEF, R6_ASFOLGA, R6_TNOOPC, R_E_C_N_O_ RECNO
							FROM %table:SR6% SR6
							WHERE
							%exp:cCondSR6% AND SR6.%NotDel%
						EndSql
						
						If (cQrySr6)->(!Eof())
							aAdd( aSr6Info, { cFilSPJ, cTno, (cQrySr6)->(R6_INIHNOT), (cQrySr6)->(R6_FIMHNOT), (cQrySr6)->(R6_MINHNOT), (cQrySr6)->(R6_APODFER), (cQrySr6)->(R6_TPEXFER), (cQrySr6)->(R6_TPEXFEN), (cQrySr6)->(R6_AUTOHEF), (cQrySr6)->RECNO, (cQrySr6)->(R6_ASFOLGA), (cQrySr6)->(R6_TNOOPC) } )
							lCriaCalOk	:= .T.
							lSr6Ok 		:= .T.						
							SR6->( MsGoto( (cQrySR6)->RECNO ) )						
							(cQrySR6)->(dbCloseArea())
						Else
							lCriaCalOk	:= .F.
							lSr6Ok 		:= .F.						
							(cQrySR6)->(dbCloseArea())
							Break
						EndIf
												
						RestArea( aSvAlias )
					#ELSE
						/*/
						зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Verifica se o Turno de Trabalho eh valido                   Ё
						юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						IF !( lSr6Ok := PosSR6( cTno , cFilSPJ , NIL , 01 , .F. ) )
							lCriaCalOk	:= .F.
							lSr6Ok 		:= .F.		
							Break
						EndIF
						/*/
						зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Obtem as Informacoes em Cache do Turno de Trabalho          Ё
						юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						aSr6Return := PosSR6( cTno , cFilSPJ , aSr6Struct , 01 , .F. )
						aAdd( aSr6Info, { cFilSPJ, cTno, aSr6Return[1], aSr6Return[2], aSr6Return[3], aSr6Return[4], aSr6Return[5], aSr6Return[6], aSr6Return[7], SR6->( Recno() ), aSr6Return[8], aSr6Return[9] } )

					#ENDIF
				
					nPosTr := aScan( aSr6Info , { |x| x[1] == cFilSPJ .and. x[2] == cTno } )

				Else
					lCriaCalOk	:= .T.
					lSr6Ok 		:= .T.						
					SR6->( MsGoto( aSr6Info[nPosTr, 10] ) )
				EndIf
				
				If !lSr6Ok
					lCriaCalOk	:= .F.
					Break
				EndIf
				
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Obtem a Hora Noturna de Acordo com o Turno                  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				nIniHnot := aSr6Info[nPosTr, 3]	// Inicio da Hora Noturna
				nFimHnot := aSr6Info[nPosTr, 4]	// Final da Hora Noturna
				nMinHnot := aSr6Info[nPosTr, 5]	// Minutos da Hora Noturna

				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Se estiver Afastado Define o Dia como Nao Trabalhado        Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF ( lAfast )
					cTipoDia := "N"	//Nao Trabalhado
				EndIF

				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Verifica se Aponta para Funcionario em Ferias            	  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF ( cTipAfas == "F" )
					IF ( lAponFer := ( aSr6Info[nPosTr, 6] == "S" ) )
					
						/*/
						зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Se funcionario em Ferias com Direito a Apontamento       	  Ё
						юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						cTpExNorFer	:= aSr6Info[nPosTr, 7]	//Normal Ferias
						cTpExNotFer	:= aSr6Info[nPosTr, 8]	//Noturna Ferias      
						
						/*/
						зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Verifica se horas extras sao autorizadas para funcionario   Ё
						Ё em ferias.												  Ё
						юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						lHeAutoFer := If ( aSr6Info[nPosTr, 9] == "1" .or. Empty( aSr6Info[nPosTr, 9] ), .T. , .F. )	 // 1 ou branco - Autorizadas (Padrao) , 2- Nao Autorizadas
						
					EndIF
				Else
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Se funcionario nao Trabalha em Feriado e dia For Feriado 	  Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					IF (;
					 		( lFeriado );			//Dia eh Feriado	
					 		.and.;
					 		!( lTrbFeriado );		//Funcionario Nao Trabalha em Feriado
					 	)
						cTipoDia := "F" //Feriado
					EndIF
				EndIF
			
			EndIF

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Garante que os Minutos da Hora Nunca Sera Menor que Zero	  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			nMinHnot := IF( nMinHnot <= 0 , 60 , nMinHNot )	// Minutos da Hora Noturna

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Carrega Informacoes do Feriado                          	  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			cP3TpExt	:= __aLstTabCal[ nPosOrdem	,	CALEND_POS_TP_HE_FER_NR	]
			cP3TpExtN	:= __aLstTabCal[ nPosOrdem	,	CALEND_POS_TP_HE_FER_NT	]
			cP3Desc		:= __aLstTabCal[ nPosOrdem	,	CALEND_POS_DESC_FERIADO	]

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Exclui a Ordem Existente para Inclusao de Nova Ordem    	  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF ( ( nY := nPosOrdem ) > 0 )
				nLenCalend := Len( aTabCalend )
				While (;
							( nY <= nLenCalend )  .and. ;
							( nLenCalend > 0 )	  .and.	;
							( aTabCalend[ nY , CALEND_POS_ORDEM ] >= __aLstTabCal[ nPosOrdem , CALEND_POS_ORDEM ] );
					   )
					aDel( aTabCalend , nY )
					aSize( aTabCalend , --nLenCalend )
				End While
			EndIF

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Loop For/Next para a Carga das Marcacoes do Dia             Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/  
			For nY := 1 To nFornY

				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Abandona Quando as Marcacoes estiverem Vazias e Nao For  JorЁ
				Ё nada Continua												  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF (;
						( ( nY == 3 ) .and. ( ( aTabTno[ nPos , 03 ] + aTabTno[ nPos , 04 ] ) == 0 ) .and. ( aTabTno[ nPos , 33 ] != "S" ) ) .or. ;
				   		( ( nY == 5 ) .and. ( ( aTabTno[ nPos , 05 ] + aTabTno[ nPos , 06 ] ) == 0 ) .and. ( aTabTno[ nPos , 34 ] != "S" ) ) .or. ;
				   		( ( nY == 7 ) .and. ( ( aTabTno[ nPos , 07 ] + aTabTno[ nPos , 08 ] ) == 0 ) .and. ( aTabTno[ nPos , 35 ] != "S" ) )      ;
				   	)	
					Exit
				EndIF
		
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Carrega Informacoes Especificas para a Nova Ordem           Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF ( lBldNewOrd )
			
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Incrementa dData e nDias Quando Marcacao for do Dia SeguinteЁ
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					IF ( aTabTno[ nPos , nY ] <  aTabTno[ nPos , IF( nY == 1 , nY , nY-1 ) ] )
						++dData
						++nDias
					EndIF
			
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Incrementa dData e nDias Caso Jornada Continua			  Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					IF (;
							lJndC := (;
										( ( nY == 2 ) .and. ( aTabTno[ nPos , 32 ] == "S" ) ) .or. ;
					   		  	    	( ( nY == 4 ) .and. ( aTabTno[ nPos , 33 ] == "S" ) ) .or. ;
					   			    	( ( nY == 6 ) .and. ( aTabTno[ nPos , 34 ] == "S" ) ) .or. ;
					   			    	( ( nY == 8 ) .and. ( aTabTno[ nPos , 35 ] == "S" ) )	   ;
					   			 	 );
					   	)
					   	lIncrementa	:= .T.
						++dData
						++nDias
					EndIF

					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					ЁVerifica Centro de Custo, Horas Trabalhadas e Horas de  InterЁ
					ЁValo														  Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					cCcCal	:= ""
					nHrTrab := 0
					nHrInte := 0
					Do Case
						Case ( aTipo[ nY ] $ "1E*1S" )
							cCcCal := aTabTno[ nPos , 25 ]
							IF ( aTipo[ nY ] == "1E" )
								nHrTrab := aTabTno[ nPos , 09 ]
							Else
								nHrInte := aTabTno[ nPos , 13 ]
							EndIF
						Case ( aTipo[ nY ] $ "2E*2S" )
							cCcCal := aTabTno[ nPos , 26 ]
							IF ( aTipo[ nY ] == "2E" )
								nHrTrab := aTabTno[ nPos , 10 ]
							Else
								nHrInte := aTabTno[ nPos , 14 ]
							EndIF	
						Case ( aTipo[ nY ] $ "3E*3S" )
							cCcCal := aTabTno[ nPos , 27 ]
							IF ( aTipo[ nY ] == "3E" )
								nHrTrab := aTabTno[ nPos , 11 ]
							Else
								nHrInte := aTabTno[ nPos , 15 ]
							EndIF	
						Case ( aTipo[ nY ] $ "4E*4S" )
							cCcCal := aTabTno[ nPos , 28 ]
							IF ( aTipo[ nY ] == "4E" )
								nHrTrab := aTabTno[ nPos , 12 ]
							EndIF	
					EndCase			
		
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Carrega Novo Elemento no Calendario   					  Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					aAdd( aTabCalend, Array( ELEMENTOS_ATABCALEND ) )
					nLenCalend := Len( aTabCalend )
					aTabCalend[	nLenCalend	,	CALEND_POS_DATA				] := dData																					// 01 - Data
					aTabCalend[	nLenCalend	,	CALEND_POS_DATA_APO			] := dDataApo																				// 48 - Data de Apontamento
					aTabCalend[	nLenCalend	,	CALEND_POS_ORDEM			] := cOrdem																					// 02 - Ordem
					aTabCalend[	nLenCalend	,	CALEND_POS_HORA				] := aTabTno[ nPos , nY ]      																// 03 - Hora
					aTabCalend[	nLenCalend	,	CALEND_POS_TIPO_MARC		] := aTipo[ nY ]          																	// 04 - Tipo Marc
					aTabCalend[	nLenCalend	,	CALEND_POS_NUM_MARC			] := aTabTno[ nPos , 17 ]     																// 05 - No Marc.
					aTabCalend[	nLenCalend	,	CALEND_POS_TIPO_DIA			] := cTipoDia     																			// 06 - Tipo Dia
					aTabCalend[	nLenCalend	,	CALEND_POS_HRS_TRABA		] := nHrTrab																				// 07 - Horas Trabalhada no Periodo
					aTabCalend[	nLenCalend	,	CALEND_POS_SEQ_TURNO		] := aTabTno[ nPos , 19 ]   																// 08 - Sequ┬ncia de Turno
					aTabCalend[	nLenCalend	,	CALEND_POS_HRS_INTER		] := nHrInte																				// 09 - Horas de Intervalo
					aTabCalend[	nLenCalend	,	CALEND_POS_EXCECAO			] := aTabTno[ nPos , 21 ]																	// 10 - Excecao ( E-Excecao, # E - nao e excecao )
					aTabCalend[	nLenCalend	,	CALEND_POS_MOT_EXECAO		] := aTabTno[ nPos , 22 ]																	// 11 - Motivo da Excecao
					aTabCalend[	nLenCalend	,	CALEND_POS_TIPO_HE_NOR		] := aTabTno[ nPos , 23 ]																	// 12 - Tipo de hora extra normal
					aTabCalend[	nLenCalend	,	CALEND_POS_TIPO_HE_NOT		] := aTabTno[ nPos , 24 ]																	// 13 - Tipo de hora extra noturna
					aTabCalend[	nLenCalend	,	CALEND_POS_TURNO			] := cNewTno																				// 14 - Turno de Trabalho
					aTabCalend[	nLenCalend	,	CALEND_POS_CC				] := cCcCal																					// 15 - Centro de Custo do Periodo 
					aTabCalend[	nLenCalend	,	CALEND_POS_PG_NONA_HORA		] := aTabTno[ nPos , 29 ]																	// 16 - Pagamento de Nona Hora
					IF ( nY == 1 )
						nSerial		:= ( __fDhToNS( dData , aTabTno[ nPos , nY ] ) - __fDhToNS( NIL , aTabTno[ nPos , 30 ] ) )
						aMarcId[1]	:= __fNsToDh( nSerial , "D" )
						aMarcId[2]	:= __fNsToDh( nSerial , "H" )
					Else
						aMarcId[1] := Ctod("//")
						aMarcId[2] := 0
					EndIF
					aTabCalend[	nLenCalend	,	CALEND_POS_LIM_MARCACAO		] := aClone( aMarcId )																		// 17 - Limite de Marcacao Inicial
					aTabCalend[	nLenCalend	,	CALEND_POS_COD_REFEICAO		] := IF(Empty(aTabTno[nPos,36]).and.!Empty(aTabOrig),aTabOrig[nPos,36],aTabTno[nPos,36])	// 18 - Codigo da Refeicao
					aTabCalend[	nLenCalend	,	CALEND_POS_FERIADO			] := lFeriado																				// 19 - Dia e Feriado
					aTabCalend[	nLenCalend	,	CALEND_POS_TP_HE_FER_NR		] := cP3TpExt																				// 20 - Tipo de Hora Extra Feriado Normal
					aTabCalend[	nLenCalend	,	CALEND_POS_TP_HE_FER_NT 	] := cP3TpExtN																				// 21 - Tipo de Hora Extra Feriado Noturna
					aTabCalend[	nLenCalend	,	CALEND_POS_DESC_FERIADO		] := cP3Desc																				// 22 - Descricao do Feriado
					aTabCalend[	nLenCalend	,	CALEND_POS_REGRA			] := cNewReg																				// 23 - Regra de Apontamento
					aTabCalend[	nLenCalend	,	CALEND_POS_AFAST			] := lAfast																					// 24 - Funcionario Afastado
					aTabCalend[	nLenCalend	,	CALEND_POS_TIP_AFAST		] := cTipAfas																				// 25 - Tipo de Afastamento
					aTabCalend[	nLenCalend	,	CALEND_POS_INI_AFAST		] := dIniAfas																				// 26 - Data Inicial do Afastamento
					aTabCalend[	nLenCalend	,	CALEND_POS_FIM_AFAST		] := dFimAfas																				// 27 - Data Final do Afastamento
					aTabCalend[	nLenCalend	,	CALEND_POS_INI_H_NOT		] := nIniHnot																				// 28 - Inicio da Hora Noturna
					aTabCalend[	nLenCalend	,	CALEND_POS_FIM_H_NOT		] := nFimHnot																				// 29 - Final da Hora Noturna
					aTabCalend[	nLenCalend	,	CALEND_POS_MIN_H_NOT		] := nMinHnot																				// 30 - Minutos da Hora Noturna
					aTabCalend[	nLenCalend	,	CALEND_POS_TRAB_FERIADO		] := lTrbFeriado																			// 31 - Se funcionario Trabalha em Dias Feriados
					aTabCalend[	nLenCalend	,	CALEND_POS_APON_FERIAS		] := lAponFer																				// 32 - Se Aponta Quando Afastamento em Ferias
					aTabCalend[	nLenCalend	,	CALEND_POS_TP_HE_NR_FER		] := cTpExNorFer																			// 33 - Tipo de hora extra normal (Ferias)
					aTabCalend[	nLenCalend	,	CALEND_POS_TP_HE_NT_FER		] := cTpExNotFer																			// 34 - Tipo de hora extra noturna (Ferias)	
					aTabCalend[	nLenCalend	,	CALEND_POS_PAGINT			] := cPagInt																				// 35 - Tipos de Intervalos Que sao Pagos conforme Regra
					aTabCalend[ nLenCalend	,   CALEND_POS_TIPO_ORIG_DIA    ] := aTabTno[nPos,18]																		// 36 - Tipo Original do Dia conforme excecao mas sem considerar a regra e/ou afastamentos
					aTabCalend[ nLenCalend	,   CALEND_POS_HE_AUTO_FER      ] := lHeAutoFer																				// 37 - Se H.Extras sЦo autorizadas para funcionario em ferias				
					aTabCalend[ nLenCalend	,   CALEND_POS_INTSREP 		    ] := aTabTno[nPos,38]																		// 38 - Intervalo para geracao do ACJEF
				EndIF

				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Define a Posicao do Calendario quando nao Remontar Ordem    Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/  
				IF !( lBldNewOrd )
					IF ( ( ++nLenCalend ) > Len( aTabCalend )  )
						Exit
					EndIF
				EndIF

			Next nY

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Quando inserir nova ordem verifica o Sincronismo            Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/  
			IF ( lBldNewOrd )
				nSerial		:= ( __fDhToNS( aTabCalend[ nLenCalend , CALEND_POS_DATA ] , aTabCalend[ nLenCalend , CALEND_POS_HORA ] ) + __fDhToNS( NIL ,aTabTno[ nPos , 31 ]) )
				aMarcId[1]	:= __fNsToDh( nSerial , "D" )
				aMarcId[2]	:= __fNsToDh( nSerial , "H" )
				
				aTabCalend[	nLenCalend	,	CALEND_POS_LIM_MARCACAO	] := aClone( aMarcId )																		// 17 - Limite de Marcacao Final
			EndIF				

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Se Houve Alteracao na Tabela Padrao/Regra em Funcao das ExceЁ
			Ё coes, Restaura os Padroes								      Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF ( !Empty( aTabOrig ) )
				aTabTno		:= aClone( aTabOrig )
				aTabOrig	:= {}
				cNewReg		:= cRegOrig
				cRegOrig	:= ""
			EndIF
	
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Se Nao eh jornada continua, os dias acrescidos no dia de    Ё
			Ё apontamento nao serao considerados.					      Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		    If !lIncrementa
		       nDias	:= 0
			Else
			   //-- Desconsidera o ultimo incremento para considerar a ultima data incrementada
			   -- nDias
		    Endif
	
		Next nX                  
    
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁReordena Calendario conforme Ordem							  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( lForceSinc )
			aSort( aTabCalend , NIL , NIL , { |x,y|	;
														(;
															x[ CALEND_POS_ORDEM 	] + ;
															x[ CALEND_POS_TIPO_MARC	]	;
														) < ;
														(;
															y[ CALEND_POS_ORDEM 	] + ;
															y[ CALEND_POS_TIPO_MARC	]	;
														);
											 };
				  )
		EndIF

	EndIF
	
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁSincroniza horarios iniciais da tabela para evitar intervalosЁ
	Ёentre os limites inicial do dia corrente e final do dia  anteЁ
	Ёrior.														  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( ( lSncMaMe ) .and. ( lForceSinc ) )
		CalSncMaMe(	@aTabCalend	,;	//01 -> Calendario de Marcacoes
					@aTabPadrao	,;	//02 -> Tabela de Horario Padrao
					aOrdens		,;	//03 -> Array com as Ordens do Calendario
					dDataIni	,;	//04 -> Inicio do Periodo de Apontamento
					dDataFim	,; 	//05 -> Final do Periodo de Apontamento
					cTno		,;	//06 -> Turno de Trabalho
					cSeq		,;	//07 -> Sequencia de Turno
					cFil     	,;	//08 -> Filial do Funcionario
					cMat   		,;	//09 -> Matricula do Funcionario
					cCc   		,;	//10 -> Centro de Custo do Funcionario
					.F.			,;	//11 -> Marcacoes Sendo carregadas pela Ordem
					lChkMat		 ;	//12 -> Se o Calendario esta sendo Montado por Funcionario
		   		   )
	EndIF	   		   

End Sequence

Return( lCriaCalOk )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁBldCalTnoSeq	ЁAutorЁMarinaldo de Jesus Ё Data Ё17/09/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁCria Calendario de Marcacoes Padrao Para o Turno/Sequencia  Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function BldCalTnoSeq(	dDataIni		,;	//01 -> Data Inicial do Periodo
								dDataFim		,;	//02 -> Data Final do Periodo
								aTipo			,;	//03 -> Tipos de Marcacoes Possiveis
								cTno			,;	//04 -> Turno Para a Montagem do Calendario
								cSeq			,;	//05 -> Sequencia Inicial para a Montagem Calendario
								cReg			,;	//06 -> Regra do Funcionario
								aTabPadrao		,;	//07 -> Array Tabela de Horario Padrao
								aTabCalend		,;	//08 -> Array com o Calendario de Marcacoes
								aLstTabTno		,;	//09 -> Tabela do Turno Corrente
								cFil			,;	//10 -> Filial para a Montagem da Tabela de Horario
								lExecQryTop 	,;	//11 -> Se executa Query para a Montagem da Tabela Padrao
								lSncMaMe		 ;	//12 -> Se executa a funcao se sincronismo do calendario
							)
/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Variaveis de Inicializacao Obrigatoria					  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Local aMarcId	 	:= { NIL , NIL }
Local aTabTno		:= {}
Local aOrdens		:= {}
Local lCriaCalOk	:= .T.
Local lAponFer		:= .F.
Local nOrdem		:= 0
Local nFornY		:= Len( aTipo )
Local nSeq			:= Val( cSeq )
Local nDias			:= 0
Local lChkReg		:= ( !Empty( cReg ) .and. ( cReg <> "__cNewReg__" ) )
Local lHeAutoFer	:= .T.

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Variaveis que serao inicializadas no Corpo da Funcao		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Local aSpaReturn	:= {}
Local aSr6Return	:= {}
Local aSvAlias		:= {}

Local bAsc

Local cOrdem
Local dDataApo	:= Ctod("")
Local cFilSP3
Local cFilSPJ
Local cFilSR6
Local cFilSPA
Local cPagInt
Local cP3TpExt
Local cP3TpExtN
Local cP3Desc
Local cCcCal

Local dData

Local lJndC
Local lFeriado 
Local lIncrementa	:= .F. //Incrementa dia de periodo de apontamento para jornada continua
Local lTrbFeriado

Local nIniHnot
Local nFimHnot
Local nMinHNot
Local nSerial
Local nLenTabPad
Local nLenCalend
Local nX
Local nY
Local nFornX
Local nPos
Local nHrTrab
Local nHrInte
Local nPosRg		:= 0

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Obtem a Filial Para a Pesquisa dos Feriados                 Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
cFilSP3	:= xFilial( "SP3" , cFil )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Obtem a Filial Para a Montagem do Calendario                Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
cFilSPJ := xFilial( "SPJ" , cFil )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Obtem a Filial do SR6                                       Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
cFilSR6 := xFilial( "SR6" , cFil )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Obtem a Filial do SPA                                       Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
cFilSPA	:= xFilial( "SPA" , cFil )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Carrega as Tabelas de Horario Padrao da Filial/Turno        Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
fTabPadrao( @aTabPadrao , @cFilSPJ , cTno , lExecQryTop )
IF ( ( ( nLenTabPad := Len( aTabPadrao ) ) == 0 ) .or. ( __nFilTabTno > nLenTabPad ) )
	__nFilTabTno := 0
EndIF	

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Se nao Verificar a Regra carrega os Espacos correspondentes Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF !( lChkReg )
	cReg := Space( GetSx3Cache( "PA_CODIGO" , "X3_TAMANHO" ) )
EndIF

Begin Sequence

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Pesquisa e Carrega a Tabela do Turno Corrente				  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( ( __nFilTabTno > 0 ) .and. ( __nFilTabTno <= nLenTabPad ) .and. ( ( cFilSPJ + cTno ) == ( aTabPadrao[ __nFilTabTno , 01 ] + aTabPadrao[ __nFilTabTno , 02 ] ) ) )
		aTabTno := aClone( aTabPadrao[ __nFilTabTno , 3 ] )
	Else
		IF ( lCriaCalOk := ( ( nPos := aScan( aTabPadrao , { |x| x[1] == cFilSPJ .and. x[2] == cTno } ) ) > 0 ) )
			aTabTno := aClone( aTabPadrao[ nPos , 3 ] )
			__nFilTabTno := nPos
		Else
			Break
		EndIF
	EndIF	

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Salva a Tabela do Turno Corrente              			  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	aLstTabTno := aClone( aTabTno )
	
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Inicializa o Array aTabCalend ( Calendario das Marcacoes )  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	aTabCalend := {}

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Loop For/Next para a Carga das Marcacoes do Periodo         Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	nFornX := ( dDataFim - dDataIni )
	For nX := 0 To nFornX
		
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Data a ser verificada										  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		dData := ( dDataIni + nX )

	
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё A Sequencia eh incrementada a Cada Segunda Feira			  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( ( nX != 0 ) .and. ( Dow( dData ) == 2 ) )
			nSeq++
		EndIF

		IF ( lIncrementa ) 
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Verifica se a Sequ┬ncia atual est═ cadastrada na Tabela. PesЁ
			Ё quisa a Sequencia Primeiro com o StrZero( n , 1 ) "0" e   DeЁ
			Ё pois com StrZero( n , 2 ) "00"						      Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			bAsc := { |x| AllTrim( x[19] ) == StrZero( nSeq , IF( nSeq < 10 , 1 , 2 ) ) .or. AllTrim( x[19] ) == StrZero( nSeq , 2 ) }
			nSeq := IF( aScan( aTabTno , bAsc ) == 0 , 1 , nSeq )

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Para Jornada Continua corre todas as datas para que seja    Ё
			Ё verificada se alguma segunda-feira ocorre durante a jornada Ё
			Ё e, assim, incrementarmos a sequencia.						  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		    If nDias > 0
		      --nDias 
		      Loop
		    Endif   
		    lIncrementa := .F.
		EndIF
	
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Ordem da Marcacao     									  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		nOrdem++
		cOrdem := StrZero( nOrdem , Max( __nTamP8Ordem , Len( AllTrim( Str( nOrdem ) ) ) ) )
		
		dDataApo	:= dData
		
		IF ( lSncMaMe )
			aAdd( aOrdens , cOrdem )
		EndIF


		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica se a Sequ┬ncia atual est═ cadastrada na Tabela. PesЁ
		Ё quisa a Sequencia Primeiro com o StrZero( n , 1 ) "0" e   DeЁ
		Ё pois com StrZero( n , 2 ) "00"						      Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		bAsc := { |x| AllTrim( x[19] ) == StrZero( nSeq , IF( nSeq < 10 , 1 , 2 ) ) .or. AllTrim( x[19] ) == StrZero( nSeq , 2 ) }
		nSeq := IF( aScan( aTabTno , bAsc ) == 0 , 1 , nSeq )

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁVerifica se o Dia da Semana da Sequencia e equivalente ao DiaЁ
		Ёda Data a Ser Pesquisada. Pesquisa a Sequencia  Primeiro  comЁ
		Ёo StrZero( n , 1 ) "0" e Depois com o StrZero( n , 2 ) "00"  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		bAsc := { |x| (	AllTrim( x[19] ) == StrZero( nSeq , IF( nSeq < 10 , 1 , 2 ) ) .or. AllTrim( x[19] ) == StrZero( nSeq , 2 ) ) ;
					  .and. x[20] == Dow(dData);
				 }
		IF !( lCriaCalOk := ( nPos := aScan( aTabTno, bAsc ) ) > 0 )
			Break
		EndIF

		IF ( nPosTr := aScan( aSr6Info , { |x| x[1] == cFilSPJ .and. x[2] == cTno } ) ) == 0
			#IFDEF TOP
				aSvAlias := GetArea()
				
				cCondSR6 := "% R6_FILIAL = '"+cFilSPJ+"' AND "
				cCondSR6 += "R6_TURNO  = '"+cTno+"' %"
								
				cQrySR6 := GetNextAlias()
				
				BeginSql alias cQrySR6
					SELECT R6_INIHNOT, R6_FIMHNOT, R6_MINHNOT, R6_APODFER, R6_TPEXFER, R6_TPEXFEN, R6_AUTOHEF, R6_ASFOLGA, R6_TNOOPC, R_E_C_N_O_ RECNO
					FROM %table:SR6% SR6
					WHERE
					%exp:cCondSR6% AND SR6.%NotDel%
				EndSql
				
				If (cQrySr6)->(!Eof())
					aAdd( aSr6Info, { cFilSPJ, cTno, (cQrySr6)->(R6_INIHNOT), (cQrySr6)->(R6_FIMHNOT), (cQrySr6)->(R6_MINHNOT), (cQrySr6)->(R6_APODFER), (cQrySr6)->(R6_TPEXFER), (cQrySr6)->(R6_TPEXFEN), (cQrySr6)->(R6_AUTOHEF), (cQrySr6)->RECNO, (cQrySr6)->(R6_ASFOLGA), (cQrySr6)->(R6_TNOOPC) } )
					lCriaCalOk	:= .T.
					lSr6Ok 		:= .T.						
					SR6->( MsGoto( (cQrySR6)->RECNO ) )						
					(cQrySR6)->(dbCloseArea())				
				Else
					lCriaCalOk	:= .F.
					lSr6Ok 		:= .F.						
					(cQrySR6)->(dbCloseArea())
					Break
				EndIf
				
				RestArea( aSvAlias )
			#ELSE
			
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Verifica se o Turno de Trabalho eh valido                   Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF !( lSr6Ok := PosSR6( cTno , cFilSPJ , NIL , 01 , .F. ) )
					Break
				EndIF
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Obtem as Informacoes em Cache do Turno de Trabalho          Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				aSr6Return:= PosSR6( cTno , cFilSPJ , aSr6Struct , 01 , .F. )
				aAdd( aSr6Info, { cFilSPJ, cTno, aSr6Return[1], aSr6Return[2], aSr6Return[3], aSr6Return[4], aSr6Return[5], aSr6Return[6], aSr6Return[7], SR6->( Recno() ), aSr6Return[8], aSr6Return[9] } )				

			#ENDIF

			nPosTr := aScan( aSr6Info , { |x| x[1] == cFilSPJ .and. x[2] == cTno } )

		Else
			lCriaCalOk	:= .T.
			lSr6Ok 		:= .T.						
			SR6->( MsGoto( aSr6Info[nPosTr, 10] ) )			
		EndIf		
				
		If !lSr6Ok
			lCriaCalOk	:= .F.
			Break
		EndIf
		
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Obtem a Hora Noturna de Acordo com o Turno                  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		nIniHnot := aSr6Info[nPosTr, 3]	// Inicio da Hora Noturna
		nFimHnot := aSr6Info[nPosTr, 4]	// Final da Hora Noturna
		nMinHnot := aSr6Info[nPosTr, 5]	// Minutos da Hora Noturna

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Garante que os Minutos da Hora Nunca Sera Menor que Zero	  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		nMinHnot := IF( nMinHnot <= 0 , 60 , nMinHNot )				// Minutos da Hora Noturna

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica Quais Intervalos Sao Pagos             			  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		cPagInt := ""
		IF ( lChkReg )
			IF ( nPosRg := aScan( aSpaInfo , { |x| x[1] == cFilSPA .and. x[2] == cReg } ) ) == 0			
				
				#IFDEF TOP
					aSvAlias := GetArea()
						
					cCondSPA := "% PA_FILIAL = '"+cFilSPA+"' AND "
					cCondSPA += "PA_CODIGO  = '"+cReg+"' %"
									
					cQrySPA := GetNextAlias()

					BeginSql alias cQrySPA
						SELECT PA_PAGINT, PA_FERIADO,  R_E_C_N_O_ RECNO
						FROM %table:SPA% SPA
						WHERE
						%exp:cCondSPA% AND SPA.%NotDel%
					EndSql
					
					If (cQrySpa)->(!Eof())
						aAdd( aSpaInfo, { cFilSPA, cReg, (cQrySpa)->(PA_PAGINT), (cQrySpa)->(PA_FERIADO), (cQrySpa)->RECNO } )
						lCriaCalOk	:= .T.
						lSpaOk 		:= .T.
						SPA->( MsGoto( (cQrySpa)->RECNO ) )
						(cQrySPA)->(dbCloseArea())
					Else
						lCriaCalOk	:= .F.
						lSpaOk 		:= .F.
						(cQrySPA)->(dbCloseArea())
						Break
					EndIf
					
					RestArea( aSvAlias )
				#ELSE								
				
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Verifica se a Regra de Apontamento eh Valida                Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					IF !( lSpaOk := PosSPA( cReg , cFilSPA , NIL , 01 , .F. ) )
						lCriaCalOk	:= .F.
						lSpaOk 		:= .F.
						Break
					EndIF
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Obtem as Informacoes em Cache da Regra de Apontamento       Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					aSpaReturn := PosSPA( cReg , cFilSPA , aSpaStruct , 01 , .F. )
                    aAdd( aSpaInfo, { cFilSPA, cReg, aSpaReturn[1], aSpaReturn[2], SPA->( Recno() ) } )					
				
				#ENDIF
				
				nPosRg 	:= aScan( aSpaInfo , { |x| x[1] == cFilSPA .and. x[2] == cReg } )
				cPagInt := aSpaInfo[nPosRg, 3]				
				
			Else
				lCriaCalOk	:= .T.
				lSpaOk 		:= .T.	
				cPagInt := aSpaInfo[nPosRg, 3]				
				SPA->( MsGoto( aSpaInfo[nPosRg, 5] ) )
			EndIf

		EndIF

		If !lSpaOk
			lCriaCalOk	:= .F.
			Break
		EndIf
		
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica Se o Dia em Questao eh um Feriado				  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		lTrbFeriado := .F.
		IF ( lFeriado := fFeriado( cFilSP3 , dData, Nil, dDataIni, dDataFim ) )
			cP3TpExt		:= SP3->P3_TPEXT
			cP3TpExtN		:= SP3->P3_TPEXTN
			cP3Desc			:= SP3->P3_DESC
			IF ( lChkReg )
				lTrbFeriado := ( aSpaInfo[nPosRg, 4] == "S" )
			EndIF
		Else
			cP3TpExt	:= ""
			cP3TpExtN	:= ""
			cP3Desc		:= ""
		EndIF		

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Define o Tipo do Dia                                    	  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		cTipoDia := aTabTno[ nPos , 18 ]

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Se funcionario nao Trabalha em Feriado e dia For Feriado 	  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( ( lFeriado ) .and. !( lTrbFeriado ) )
			cTipoDia := "F" //Feriado
		EndIF 
		
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Loop For/Next para a Carga das Marcacoes do Dia             Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/  
		For nY := 1 To nFornY

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Abandona Quando as Marcacoes estiverem Vazias e Nao For  JorЁ
			Ё nada Continua												  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF (;
					( ( nY == 3 ) .and. ( ( aTabTno[ nPos , 03 ] + aTabTno[ nPos , 04 ] ) == 0 ) .and. ( aTabTno[ nPos , 33 ] != "S" ) ) .or. ;
			   		( ( nY == 5 ) .and. ( ( aTabTno[ nPos , 05 ] + aTabTno[ nPos , 06 ] ) == 0 ) .and. ( aTabTno[ nPos , 34 ] != "S" ) ) .or. ;
			   		( ( nY == 7 ) .and. ( ( aTabTno[ nPos , 07 ] + aTabTno[ nPos , 08 ] ) == 0 ) .and. ( aTabTno[ nPos , 35 ] != "S" ) )      ;
			   	)	
				Exit
			EndIF

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Incrementa dData e nDias Quando Marcacao for do Dia SeguinteЁ
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF ( aTabTno[ nPos , nY ] <  aTabTno[ nPos , IF( nY == 1 , nY , nY-1 ) ] )
				++dData
				++nDias
			EndIF

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Incrementa dData e nDias Caso Jornada Continua			  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF (;
					lJndC := (;
								( ( nY == 2 ) .and. ( aTabTno[ nPos , 32 ] == "S" ) ) .or. ;
			   		  	    	( ( nY == 4 ) .and. ( aTabTno[ nPos , 33 ] == "S" ) ) .or. ;
			   			    	( ( nY == 6 ) .and. ( aTabTno[ nPos , 34 ] == "S" ) ) .or. ;
			   			    	( ( nY == 8 ) .and. ( aTabTno[ nPos , 35 ] == "S" ) )	   ;
			   			 	 );
			   	)
				++dData
				++nDias
				lIncrementa	:= .T.
			EndIF

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁVerifica Centro de Custo, Horas Trabalhadas e Horas de  InterЁ
			ЁValo														  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			cCcCal	:= ""
			nHrTrab := 0
			nHrInte := 0
			Do Case
				Case ( aTipo[ nY ] $ "1E*1S" )
					cCcCal := aTabTno[ nPos , 25 ]
					IF ( aTipo[ nY ] == "1E" )
						nHrTrab := aTabTno[ nPos , 09 ]
					Else
						nHrInte := aTabTno[ nPos , 13 ]
					EndIF
				Case ( aTipo[ nY ] $ "2E*2S" )
					cCcCal := aTabTno[ nPos , 26 ]
					IF ( aTipo[ nY ] == "2E" )
						nHrTrab := aTabTno[ nPos , 10 ]
					Else
						nHrInte := aTabTno[ nPos , 14 ]
					EndIF	
				Case ( aTipo[ nY ] $ "3E*3S" )
					cCcCal := aTabTno[ nPos , 27 ]
					IF ( aTipo[ nY ] == "3E" )
						nHrTrab := aTabTno[ nPos , 11 ]
					Else
						nHrInte := aTabTno[ nPos , 15 ]
					EndIF	
				Case ( aTipo[ nY ] $ "4E*4S" )
					cCcCal := aTabTno[ nPos , 28 ]
					IF ( aTipo[ nY ] == "4E" )
						nHrTrab := aTabTno[ nPos , 12 ]
					EndIF	
			EndCase			

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Carrega Novo Elemento no Calendario   					  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			aAdd( aTabCalend, Array( ELEMENTOS_ATABCALEND ) )
			nLenCalend := Len( aTabCalend )
			aTabCalend[	nLenCalend	,	CALEND_POS_DATA				] := dData																			// 01 - Data
			aTabCalend[	nLenCalend	,	CALEND_POS_DATA_APO			] := dDataApo			                                                            // 48 - Data de Apontamento
			aTabCalend[	nLenCalend	,	CALEND_POS_ORDEM			] := cOrdem																			// 02 - Ordem
			aTabCalend[	nLenCalend	,	CALEND_POS_HORA				] := aTabTno[ nPos , nY ]      														// 03 - Hora
			aTabCalend[	nLenCalend	,	CALEND_POS_TIPO_MARC		] := aTipo[ nY ]          															// 04 - Tipo Marc
			aTabCalend[	nLenCalend	,	CALEND_POS_NUM_MARC			] := aTabTno[ nPos , 17 ]     														// 05 - No Marc.
			aTabCalend[	nLenCalend	,	CALEND_POS_TIPO_DIA			] := cTipoDia     																	// 06 - Tipo Dia
			aTabCalend[	nLenCalend	,	CALEND_POS_HRS_TRABA		] := nHrTrab									 							 		// 07 - Horas Trabalhada no Periodo
			aTabCalend[	nLenCalend	,	CALEND_POS_SEQ_TURNO		] := aTabTno[ nPos , 19 ]   														// 08 - Sequ┬ncia de Turno
			aTabCalend[	nLenCalend	,	CALEND_POS_HRS_INTER		] := nHrInte																		// 09 - Horas de Intervalo
			aTabCalend[	nLenCalend	,	CALEND_POS_EXCECAO			] := aTabTno[ nPos , 21 ]															// 10 - Excecao ( E-Excecao, # E - nao e excecao )
			aTabCalend[	nLenCalend	,	CALEND_POS_MOT_EXECAO		] := aTabTno[ nPos , 22 ]															// 11 - Motivo da Excecao
			aTabCalend[	nLenCalend	,	CALEND_POS_TIPO_HE_NOR		] := aTabTno[ nPos , 23 ]															// 12 - Tipo de hora extra normal
			aTabCalend[	nLenCalend	,	CALEND_POS_TIPO_HE_NOT		] := aTabTno[ nPos , 24 ]															// 13 - Tipo de hora extra noturna
			aTabCalend[	nLenCalend	,	CALEND_POS_TURNO			] := cTno																			// 14 - Turno de Trabalho
			aTabCalend[	nLenCalend	,	CALEND_POS_CC				] := cCcCal										 							 		// 15 - Centro de Custo do Periodo 
			aTabCalend[	nLenCalend	,	CALEND_POS_PG_NONA_HORA		] := aTabTno[ nPos , 29 ]															// 16 - Pagamento de Nona Hora
			IF ( nY == 1 )
				nSerial		:= ( __fDhToNS( dData , aTabTno[ nPos , nY ] ) - __fDhToNS( NIL , aTabTno[ nPos , 30 ] ) )
				aMarcId[1]	:= __fNsToDh( nSerial , "D" )
				aMarcId[2]	:= __fNsToDh( nSerial , "H" )
			Else
				aMarcId[1] := Ctod("//")
				aMarcId[2] := 0
			EndIF
			aTabCalend[	nLenCalend	,	CALEND_POS_LIM_MARCACAO		] := aClone( aMarcId )																// 17 - Limite de Marcacao Inicial
			aTabCalend[	nLenCalend	,	CALEND_POS_COD_REFEICAO		] := aTabTno[ nPos , 36 ]															// 18 - Codigo da Refeicao
			aTabCalend[	nLenCalend	,	CALEND_POS_FERIADO			] := lFeriado																		// 19 - Dia e Feriado
			aTabCalend[	nLenCalend	,	CALEND_POS_TP_HE_FER_NR		] := cP3TpExt																		// 20 - Tipo de Hora Extra Feriado Normal
			aTabCalend[	nLenCalend	,	CALEND_POS_TP_HE_FER_NT 	] := cP3TpExtN																		// 21 - Tipo de Hora Extra Feriado Noturna
			aTabCalend[	nLenCalend	,	CALEND_POS_DESC_FERIADO		] := cP3Desc																		// 22 - Descricao do Feriado
			aTabCalend[	nLenCalend	,	CALEND_POS_REGRA			] := cReg																			// 23 - Regra de Apontamento
			aTabCalend[	nLenCalend	,	CALEND_POS_AFAST			] := .F.																			// 24 - Funcionario Afastado
			aTabCalend[	nLenCalend	,	CALEND_POS_TIP_AFAST		] := ""																				// 25 - Tipo de Afastamento
			aTabCalend[	nLenCalend	,	CALEND_POS_INI_AFAST		] := Ctod("//")																		// 26 - Data Inicial do Afastamento
			aTabCalend[	nLenCalend	,	CALEND_POS_FIM_AFAST		] := Ctod("//")																		// 27 - Data Final do Afastamento
			aTabCalend[	nLenCalend	,	CALEND_POS_INI_H_NOT		] := nIniHnot																		// 28 - Inicio da Hora Noturna
			aTabCalend[	nLenCalend	,	CALEND_POS_FIM_H_NOT		] := nFimHnot																		// 29 - Final da Hora Noturna
			aTabCalend[	nLenCalend	,	CALEND_POS_MIN_H_NOT		] := nMinHnot																		// 30 - Minutos da Hora Noturna
			aTabCalend[	nLenCalend	,	CALEND_POS_TRAB_FERIADO		] := lTrbFeriado																	// 31 - Se funcionario Trabalha em Dias Feriados
			aTabCalend[	nLenCalend	,	CALEND_POS_APON_FERIAS		] := lAponFer																		// 32 - Se Aponta Quando Afastamento em Ferias
			aTabCalend[	nLenCalend	,	CALEND_POS_TP_HE_NR_FER		] := ""																				// 33 - Tipo de hora extra normal (Ferias)
			aTabCalend[	nLenCalend	,	CALEND_POS_TP_HE_NT_FER		] := ""																				// 34 - Tipo de hora extra noturna (Ferias)	
			aTabCalend[	nLenCalend	,	CALEND_POS_PAGINT			] := cPagInt																		// 35 - Tipos de Intervalos Que sao Pagos conforme Regra
			aTabCalend[ nLenCalend	,   CALEND_POS_TIPO_ORIG_DIA    ] := aTabTno[nPos,18]																// 36 - Tipo Original do Dia conforme excecao mas sem considerar a regra e/ou afastamentos
			aTabCalend[ nLenCalend	,   CALEND_POS_HE_AUTO_FER      ] := lHeAutoFer	
			aTabCalend[ nLenCalend	,   CALEND_POS_INTSREP 		    ] := aTabTno[nPos,38]																// 38 - Intervalo para geracao do ACJEF
		Next nY

		nSerial		:= ( __fDhToNS( aTabCalend[ nLenCalend , CALEND_POS_DATA ] , aTabCalend[ nLenCalend , CALEND_POS_HORA ] ) + __fDhToNS( NIL ,aTabTno[ nPos , 31] ) )
		aMarcId[1]	:= __fNsToDh( nSerial , "D" )
		aMarcId[2]	:= __fNsToDh( nSerial , "H" )

		aTabCalend[	nLenCalend	,	CALEND_POS_LIM_MARCACAO	] := aClone( aMarcId )																		// 17 - Limite de Marcacao Final

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Se Nao eh jornada continua, os dias acrescidos no dia de    Ё
		Ё apontamento nao serao considerados.					      Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	    If !lIncrementa
	       nDias	:= 0
		Else
		   //-- Desconsidera o ultimo incremento para considerar a ultima data incrementada
		   -- nDias
	    Endif

	Next nX                  

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁSincroniza horarios iniciais da tabela para evitar intervalosЁ
	Ёentre os limites inicial do dia corrente e final do dia  anteЁ
	Ёrior.														  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( lSncMaMe )
		CalSncMaMe(	@aTabCalend	,;	//01 -> Calendario de Marcacoes
					@aTabPadrao	,;	//02 -> Tabela de Horario Padrao
					aOrdens		,;	//03 -> Array com as Ordens do Calendario
					dDataIni	,;	//04 -> Inicio do Periodo de Apontamento
					dDataFim	,; 	//05 -> Final do Periodo de Apontamento
					cTno		,;	//06 -> Turno de Trabalho
					cSeq		,;	//07 -> Sequencia de Turno
					cFil     	,;	//08 -> Filial do Funcionario
					NIL   		,;	//09 -> Matricula do Funcionario
					NIL   		,;	//10 -> Centro de Custo do Funcionario
					.F.			,;	//11 -> Marcacoes Sendo carregadas pela Ordem
					.F.			 ;	//12 -> Se o Calendario esta sendo Montado por Funcionario
		   		   )
	EndIF	   		   

End Sequence

Return( lCriaCalOk )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁRstCalendCria	ЁAutorЁMarinaldo de Jesus Ё Data Ё11/03/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁReinicializa as Staticas utilizadas em CalendCria()        	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RstCalendCria()

__aLstTabCal	:= {}
__aLstTabTno	:= {}
__cKeyBldCal	:= "__cKeyBldCal"
__nFilTabTno	:= 0  
__aAllTnoOpc	:= {}

Return( NIL )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGetTabCal		ЁAutorЁMarinaldo de Jesus Ё Data Ё18/09/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna Array contendo __aLstTabCal e __aLstTabTno			Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetTabCal()

Local aTabsCal := Array( 03 )

aTabsCal[ 01 ] := aClone( __aLstTabCal )
aTabsCal[ 02 ] := aClone( __aLstTabTno )
aTabsCal[ 03 ] := __cKeyBldCal

Return( aClone( aTabsCal ) )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁSetTabCal		ЁAutorЁMarinaldo de Jesus Ё Data Ё18/09/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRestaura  __aLstTabCal e __aLstTabTno que foram salvos  pelaЁ
Ё          ЁGetTabCal()													Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function SetTabCal( aTabsCal )

__aLstTabCal	:= aClone( aTabsCal[ 01 ] )
__aLstTabTno	:= aClone( aTabsCal[ 02 ] )
__cKeyBldCal	:= aTabsCal[ 03 ]

Return( NIL )

/*/
зддддддддддбддддддддддддбдддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁCalSncMaMe  ЁAutorЁ Marinaldo de Jesus    Ё Data Ё28/08/2003Ё
цддддддддддеддддддддддддадддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁSincroniza o HorMais e HorMenos do Calendario de Marcacoes  Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>	                                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>	                                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function CalSncMaMe(	aTabCalend	,;	//01 -> Calendario de Marcacoes
							aTabPadrao	,;	//02 -> Tabela de Horario Padrao
							aOrdens		,;	//03 -> Array com as ordens do Calendario
							dPerIni		,;	//04 -> Inicio do Periodo de Apontamento
							dPerFim		,; 	//05 -> Final do Periodo de Apontamento
							cTno		,;	//06 -> Turno de Trabalho
							cSeq		,;	//07 -> Sequencia de Turno
							cFil     	,;	//08 -> Filial do Funcionario
							cMat   		,;	//09 -> Matricula do Funcionario
							cCc   		,;	//10 -> Centro de Custo do Funcionario
							lMarcOrder	,;	//11 -> Marcacoes Sendo carregadas pela Ordem
							lCalendFunc	 ;	//12 -> Se o Calendario esta sendo Montado por Funcionario
				   		   )

Local aMarcId		:= {}
Local bHrsAtu		:= { |x| NIL }
Local bHrsAnt		:= { |x| NIL }
Local cOrdemAtu		:= ""
Local cOrdemAnt		:= ""
Local nPosCalAtu	:= 0
Local nPosCalAnt	:= 0
Local nPosCalUlt	:= 0
Local nLoop			:= 0
Local nLoops		:= Len( aOrdens )
Local nSerial		:= 0
Local nHrsAtu		:= 0
Local nHrsAnt		:= 0
Local nDifHrs		:= 0
Local nHorMeno		:= 0
Local nHorMais		:= 0
Local nFator		:= 0

IF ( nLoops >= 2.00 )
	bHrsAtu		:= { |x| IF(;
								( x[ CALEND_POS_ORDEM ] == cOrdemAtu ) ,;
								nHrsAtu := SomaHoras( nHrsAtu , x[ CALEND_POS_HRS_TRABA ] ),;
								NIL;
							);
					}
	bHrsAnt		:= { |x| IF(;
								( x[ CALEND_POS_ORDEM ] == cOrdemAnt ) ,;
								nHrsAnt := SomaHoras( nHrsAnt , x[ CALEND_POS_HRS_TRABA ] ),;
								NIL;
							);
					}
	For nLoop := 1 To nLoops
		cOrdemAtu	:= aOrdens[ nLoop ]
		nPosCalAtu	:= aScan( aTabCalend , { |x|;
													( x[ CALEND_POS_ORDEM ] == cOrdemAtu ) .and.;
													( x[ CALEND_POS_TIPO_MARC ] == "1E" );
											},;
							  ++nPosCalAtu;
							)
		IF ( nLoop == 1 )
			IF ( nPosCalAtu > 0 )
				nSerial := RetSerIni(	aClone( aTabCalend )	,;	//01 -> Copia do Calendario de Marcacoes
										@aTabPadrao				,;	//02 -> Tabela de Horario Padrao
										dPerIni					,;	//03 -> Inicio do Periodo de Apontamento
										dPerFim					,; 	//04 -> Final do Periodo de Apontamento
										cTno					,;	//05 -> Turno de Trabalho
										cSeq					,;	//06 -> Sequencia de Turno
										cFil     				,;	//07 -> Filial do Funcionario
										cMat   					,;	//08 -> Matricula do Funcionario
										cCc   					,;	//09 -> Centro de Custo do Funcionario
										lMarcOrder				,;	//10 -> Marcacoes Sendo carregadas pela Ordem
										lCalendFunc	 			 ;	//11 -> Se o Calendario esta sendo Montado por Funcionario
					   				 )
		  		aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 01	] := __fNsToDh( nSerial , "D" )
				aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 02	] := __fNsToDh( nSerial , "H" )
			EndIF	
		ElseIF ( nLoop == nLoops )
			IF (;
					(;
						nPosCalUlt := aScan(;
												aTabCalend , { |x|;
																	( x[ CALEND_POS_ORDEM ] == cOrdemAtu ) .and.;
																	!Empty( x[ CALEND_POS_LIM_MARCACAO , 01 ] ) .and.;
																	( x[ CALEND_POS_TIPO_MARC ] <> "1E" );
														 	  },;
												++nPosCalAtu;
									 		);
					) > 0;
				)	
				cOrdemAnt	:= aOrdens[ nLoop-1]
		   		nPosCalAnt	:= aScan( aTabCalend , { |x| ( x[ CALEND_POS_ORDEM ] == cOrdemAnt ) .and.;
													 !Empty( x[ CALEND_POS_LIM_MARCACAO , 01 ] ) .and.;
													 ( x[ CALEND_POS_TIPO_MARC ] <> "1E" );
											   },;
								  ++nPosCalAnt;
								 )
				nHrsAnt		:= 0
				aEval( aTabCalend , bHrsAnt )
				IF ( nHrsAnt > 0 )
					nSerial := (;
									__fDhToNS(;
												aTabCalend[ nPosCalAnt , CALEND_POS_LIM_MARCACAO , 01 ] ,;
												aTabCalend[ nPosCalAnt , CALEND_POS_LIM_MARCACAO , 02 ]	;
											  ) + ;
								   __fDhToNS( NIL , 0.01  );
								)         
				
					nPosCalAnt := aScan(;
												aTabCalend , { |x|;
																	( x[ CALEND_POS_ORDEM ] == cOrdemAtu ) .and.;
																	!Empty( x[ CALEND_POS_LIM_MARCACAO , 01 ] ) .and.;
																	( x[ CALEND_POS_TIPO_MARC ] == "1E" );
														 	  },;
												++nPosCalAnt;
									 		)
					aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 01	] := __fNsToDh( nSerial , "D" )
					aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 02	] := __fNsToDh( nSerial , "H" )
				Endif		
				nSerial := RetSerFim(	aClone( aTabCalend )	,;	//01 -> Copia do Calendario de Marcacoes
										@aTabPadrao				,;	//02 -> Tabela de Horario Padrao
										dPerIni					,;	//03 -> Inicio do Periodo de Apontamento
										dPerFim					,; 	//04 -> Final do Periodo de Apontamento
										cTno					,;	//05 -> Turno de Trabalho
										cSeq					,;	//06 -> Sequencia de Turno
										cFil     				,;	//07 -> Filial do Funcionario
										cMat   					,;	//08 -> Matricula do Funcionario
										cCc   					,;	//09 -> Centro de Custo do Funcionario
										lMarcOrder				,;	//10 -> Marcacoes Sendo carregadas pela Ordem
										lCalendFunc	 			 ;	//11 -> Se o Calendario esta sendo Montado por Funcionario
					   				 )
		  		aTabCalend[	nPosCalUlt , CALEND_POS_LIM_MARCACAO , 01	] := __fNsToDh( nSerial , "D" )
				aTabCalend[	nPosCalUlt , CALEND_POS_LIM_MARCACAO , 02	] := __fNsToDh( nSerial , "H" )
			EndIF
		Else
			cOrdemAnt	:= aOrdens[ nLoop - 1 ]
			nPosCalAnt	:= aScan( aTabCalend , { |x| ( x[ CALEND_POS_ORDEM ] == cOrdemAnt ) .and.;
													 !Empty( x[ CALEND_POS_LIM_MARCACAO , 01 ] ) .and.;
													 ( x[ CALEND_POS_TIPO_MARC ] <> "1E" );
											   },;
								  ++nPosCalAnt;
								 )
			IF ( ( nPosCalAtu > 0 ) .and. ( nPosCalAnt > 0 ) )
				nHrsAtu		:= 0
				nHrsAnt		:= 0
				aEval( aTabCalend , bHrsAtu )
				aEval( aTabCalend , bHrsAnt )
				IF ( nHrsAnt > 0 )
					nSerial := (;
									__fDhToNS(;
												aTabCalend[ nPosCalAnt , CALEND_POS_LIM_MARCACAO , 01 ] ,;
												aTabCalend[ nPosCalAnt , CALEND_POS_LIM_MARCACAO , 02 ]	;
											  ) + ;
								   __fDhToNS( NIL , 0.01  );
								)
					aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 01	] := __fNsToDh( nSerial , "D" )
					aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 02	] := __fNsToDh( nSerial , "H" )
				ElseIF ( ( nHrsAnt == 0 ) .and. ( nHrsAtu == 0 ) )
					nHorMais	:= DataHora2Val(;
												aTabCalend[ nPosCalAnt , CALEND_POS_DATA ],;
												aTabCalend[ nPosCalAnt , CALEND_POS_HORA ],;
												aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 01 ],;
												aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 02 ],;
												"H";
											)
					nHorMeno	:= DataHora2Val(;
												aTabCalend[ nPosCalAtu , CALEND_POS_DATA ],;
												aTabCalend[ nPosCalAtu , CALEND_POS_HORA ],;
												aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 01 ],;
												aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 02 ],;
												"H";
											)
					nDifHrs := DataHora2Val(;
												aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 01 ],;
												aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 02 ],;
												aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 01 ],;
												aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 02 ] ;
											)
					nFator	:= ( nHorMais / ( nHorMais + nHorMeno ) )
					nDifHrs *= nFator
					nDifHrs := __NoRound( nDifHrs , 0 )
					nDifHrs := __Min2Hrs( nDifHrs )
					aMarcId := RetFimTab(	aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 01 ]	,;	//01 -> Data da Primeira Marcacao
											aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 02 ]	,;	//02 -> Hora da Primeira Marcacao
											nDifHrs									 				 ;	//03 -> Total de Horas a Trabalhar
										)										
					aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 01 ] := aMarcId[1]
					aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 02 ] := aMarcId[2]
					aMarcId := RetFimTab(	aMarcId[1]	,;	//01 -> Data da Primeira Marcacao
											aMarcId[2]	,;	//02 -> Hora da Primeira Marcacao
											0.01		 ;	//03 -> Total de Horas a Trabalhar
										)										
					aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 01 ] := aMarcId[1]
					aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 02 ] := aMarcId[2]
				Else
					nSerial := (;
									__fDhToNS(;
												aTabCalend[ nPosCalAtu , CALEND_POS_LIM_MARCACAO , 01 ] ,;
												aTabCalend[ nPosCalAtu , CALEND_POS_LIM_MARCACAO , 02 ]	;
											  ) - ;
								   __fDhToNS( NIL , 0.01  );
								)
					aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 01 ] := __fNsToDh( nSerial , "D" )
					aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 02 ] := __fNsToDh( nSerial , "H" )
				EndIF
			EndIF
		EndIF
	Next nLoop
EndIF

Return( NIL )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁTabMarc   Ё Autor Ё Marinaldo de Jesus    Ё Data Ё12/03/2003Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna numero de Elementos Permitidos para o Calendario    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>	                                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>	                                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function TabMarc( cAlias , aMarcs )

Local cCampo  	:= ""
Local cCampoE 	:= ""
Local cCampoS 	:= ""
Local cPrefixo	:= ""
Local nX      	:= 0
Local nCtaMarc	:= 0
Local nCampos 	:= 0

DEFAULT cAlias			:= Alias()
DEFAULT __aLstTbMarc	:= {}

cAlias	:= Upper( AllTrim( cAlias ) )
aMarcs	:= {}

IF ( ( nX := aScan( __aLstTbMarc , { |x| x[1] == cAlias } ) ) > 0 )

	aMarcs		:= aClone( __aLstTbMarc[ nX , 02 ] )
	nCtaMarc	:= __aLstTbMarc[ nX , 03 ]

Else

	cPrefixo := PrefixoCpo( cAlias )

	cCampoE := ( cPrefixo + "_ENTRA" )
	cCampoS := ( cPrefixo + "_SAIDA" )

	nCampos := ( cAlias )->( fCount() )
	For nX := 1 To nCampos
		cCampo := ( cAlias )->( FieldName( nX ) )
		IF ( SubStr( cCampo , 1 , 8 ) == cCampoE ) .or. ( SubStr( cCampo , 1 , 8 ) == cCampoS )
			aAdd( aMarcs , SubStr( cCampo , 9 , 1 ) + SubStr( cCampo , 4 , 1 ) )
		EndIF
	Next nX

	aSort( @aMarcs )
	aAdd( __aLstTbMarc , { cAlias , aClone( aMarcs ) , ( nCtaMarc := Len( aMarcs ) ) } )

EndIF

Return( nCtaMarc )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    Ё GravaSPC Ё Autor Ё Equipe Advanced RH    Ё Data Ё10/04/1996Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o Ё Grava o resultado no SPC.                                  Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё GravaSPC()                                                 Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ                                                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       Ё Generico                                                   Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GravaSPC(	aResult		,;	//01 -> Array com os Resultados a serem Gravados
					cFil		,;	//02 -> Filial do Funcionario
					cMat		,;	//03 -> Matricula do Funcionario
					cEveMesA	,;	//04 -> Eventos do Mes Anterior que nao poderao ser apagados
					dPerIni		,;	//05 -> Periodo Inicial
					dPerFim		,;	//06 -> Periodo Final
					aAbonosPer	 ;	//07 -> Array com Todos os Abonos no Periodo
				)

Local aSPC			:= {}
Local cFilMat		:= ( cFil + cMat )
Local cAlias		:= "SPC"
Local cAliasQuery	:= cAlias
Local cSvFilAnt		:= cFilAnt
Local nOrder		:= RetOrdem( "SPC" , "PC_FILIAL+PC_MAT+PC_PD+DTOS(PC_DATA)+PC_TPMARCA+PC_CC" )
Local nSvOrder		:= SPC->( IndexOrd() )

Local aAbonos
Local aInfAbonos
Local aPreAbonos
Local aNewAbonos
Local cCodAbono
Local cMsgErr
Local nPos
Local nX
Local nFornX
Local nLenSPC
Local nHrsAbono
Local nHrsPreAbono


#IFDEF TOP

	Local aTamQuantC		:= {}
	Local aTamAbonos		:= {}
	Local cIniData	 		:= ""
	Local cFimData			:= ""
	Local cQuery	 		:= ""
	Local aSvAlias			:= GetArea()
	Local cTableName		:= ""
	Local cCpoRecno			:= ""
	Local lQueryOpened		:= .F.

	Static aSpcFields
	Static cQrySpcFields
	Static nSpcFields

	IF !( lExInAs400 )
	
		DEFAULT aSpcFields := ( cAlias )->( dbStruct() )
		DEFAULT nSpcFields := Len( aSpcFields )

		IF ( cQrySpcFields == NIL )
			cQrySpcFields := ""
			For nX := 1 To nSpcFields
				cQrySpcFields += aSpcFields[ nX , 01 ] + ", "
			Next nX
	    EndIF

	EndIF	    

#ENDIF

DEFAULT cEveMesA		:= ""
DEFAULT lRF0ChkTable	:= fVerTabRF0()  	//Verifica a Existencia da Tabela de Pre-Abonos e se a mesm possui registro
DEFAULT __cLimpaMotAbo	:= Space( TamSx3("PC_ABONO")[1] )	//Variavel auxiliar para preencher em branco o campo Motivo do Abono
DEFAULT __lCpoDataAlt	:= IF( ( ( SPC->(FIELDPOS( "PC_DATAALT" )) != 0 ) .and. ( SPK->(FIELDPOS( "PK_DATAALT" )) != 0 ) .and. ( SuperGetMv("MV_PONLOG",NIL,"N") == "S" ) ) ,.T. , .F. )   
DEFAULT __lCpoUsuaAlt	:= IF( ( ( SPC->(FIELDPOS( "PC_USUARIO" )) != 0 ) .and. ( SPK->(FIELDPOS( "PK_USUARIO" )) != 0 ).and. ( SuperGetMv("MV_PONLOG",NIL,"N") == "S" ) ) ,.T. , .F. )   

//-- Portaria 1.510
DEFAULT __lCpoTurno		:= IF( ( SPC->(FIELDPOS( "PC_TURNO" 	)) != 0 )  ,.T. , .F. 	)   
DEFAULT __lCpoSemana	:= IF( ( SPC->(FIELDPOS( "PC_SEMANA" 	)) != 0 )  ,.T. , .F. 	)   
DEFAULT __lCpoTipoHE	:= IF( ( SPC->(FIELDPOS( "PC_TIPOHE" 	)) != 0 )  ,.T. , .F. 	)   
DEFAULT __lCpoPercent	:= IF( ( SPC->(FIELDPOS( "PC_PERCENT" 	)) != 0 )  ,.T. , .F. 	)   

cFilAnt	:= IF( !Empty( cFil ) , cFil , cFilAnt )

bAsc   := { |x|	x[1] == aResult[ nX , ARESULT_DATA		];
				.and.;
				x[2] == aResult[ nX , ARESULT_EVENTO	];
				.and.;
				x[5] == aResult[ nX , ARESULT_CC		];
				.and.;
				x[6] == aResult[ nX , ARESULT_TPMARCA	];
		  } 

IF !( nSvOrder == nOrder )
	( cAlias )->( dbSetOrder( nOrder ) )
EndIF


#IFNDEF TOP

	IF SPC->( dbSeek( cFilMat  , .F. ) )

#ELSE

	IF ( lExInAs400 )

		SPC->( dbSeek( cFilMat  , .F. ) )

	Else

		aTamQuantC	:= TamSx3("PC_QUANTC")
		aTamAbonos	:= TamSx3("PC_QTABONO")
		cTableName	:= InitSqlName( cAlias )
		cCpoRecno	:= IF( lExInAs400 , "RRN("+cTableName+")", "R_E_C_N_O_" )
		cIniData	:= Dtos( dPerIni )
		cFimData	:= Dtos( dPerFim )
		cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )
		cQuery := "SELECT "
		cQuery += cQrySpcFields
		cQuery += "R_E_C_N_O_ RECNO"
		cQuery += " FROM "
		cQuery += cTableName
		cQuery += " WHERE "
		cQuery += "PC_FILIAL='"+cFil+"'"
		cQuery += " AND "
		cQuery += "PC_MAT='"+cMat+"'"
		cQuery += " AND "
		cQuery += "( "
		cQuery += 		"PC_DATA>='"+cIniData+"' AND "
		cQuery += 		"PC_DATA<='"+cFimData+"'"
		cQuery += " )"
		cQuery += " AND "
		cQuery += "D_E_L_E_T_=' ' "
		cQuery += "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )
		cQuery := ChangeQuery( cQuery )
		IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
			For nX := 1 To nSpcFields
				IF !( aSpcFields[ nX , 02 ] == "C" )
					TcSetField(cAliasQuery,aSpcFields[nX,01],aSpcFields[nX,02],aSpcFields[nX,03],aSpcFields[nX,04])
				EndIF
			Next nX
			cQuery := ""
		Else
			cAliasQuery	:= cAlias
			( cAliasQuery )->( dbSeek( cFilMat  , .F. ) )
		EndIF
	
    EndIF

#ENDIF

		While ( cAliasQuery )->( !Eof() .and. ( PC_FILIAL + PC_MAT ) == cFilMat )
			IF ( cAliasQuery )->( ( PC_DATA >= dPerIni ) .and. ( PC_DATA <= dPerFim ) )
				aAdd( aSPC , Array( 13 ) )
				nLenSPC := Len( aSPC )
				aSPC[ nLenSPC , 01 ] := ( cAliasQuery )->( PC_DATA		)
				aSPC[ nLenSPC , 02 ] := ( cAliasQuery )->( PC_PD		)
				aSPC[ nLenSPC , 03 ] := ( cAliasQuery )->( PC_QUANTC	)
				aSPC[ nLenSPC , 04 ] := ( cAliasQuery )->( PC_QUANTI	)
				aSPC[ nLenSPC , 05 ] := ( cAliasQuery )->( PC_CC		)
				aSPC[ nLenSPC , 06 ] := ( cAliasQuery )->( PC_TPMARCA	)
				#IFNDEF TOP
					aSPC[ nLenSPC , 07 ] := ( cAliasQuery )->( Recno() )
				#ELSE
					IF !( lQueryOpened )
						aSPC[ nLenSPC , 07 ] := ( cAliasQuery )->( Recno() )
					Else
						aSPC[ nLenSPC , 07 ] := ( cAliasQuery )->( RECNO )
					EndIF
				#ENDIF
				aSPC[ nLenSPC , 08 ] := ( cAliasQuery )->( PC_ABONO 	)
				aSPC[ nLenSPC , 09 ] := ( cAliasQuery )->( PC_QTABONO 	) 
				
				//-- Portaria 1.510
				IF __lCpoTurno .and. __lCpoSemana .and. __lCpoTipoHE .and. __lCpoPercent
					aSPC[ nLenSPC , 10 ] := ( cAliasQuery )->( PC_TURNO 	)
					aSPC[ nLenSPC , 11 ] := ( cAliasQuery )->( PC_SEMANA	)
					aSPC[ nLenSPC , 12 ] := ( cAliasQuery )->( PC_TIPOHE	)
					aSPC[ nLenSPC , 13 ] := ( cAliasQuery )->( PC_PERCENT	)
				Endif	
			EndIF
			( cAliasQuery )->( dbSkip() )
		End While

#IFNDEF TOP

	EndIF

#ELSE

	IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
		( cAliasQuery )->( dbCloseArea() )
		RestArea( aSvAlias )
	EndIF	

#ENDIF	

nLenSPC := Len( aSPC )

nFornX := Len( aResult )
For nX := 1 To nFornX

	IF ( ( aResult[ nX , ARESULT_DATA ] >= dPerIni ) .and. ( aResult[ nX , ARESULT_DATA ] <= dPerFim ) )

		nHrsAbono	:= fAbonos( aResult[ nX , ARESULT_DATA ] , aResult[ nX , ARESULT_EVENTO ] , NIL , @aAbonos , aResult[ nX , ARESULT_TPMARCA ] , aResult[ nX , ARESULT_CC ] , aAbonosPer )
		fFiltAbo( aAbonos , { |x| x[ AABONOS_FLAG ] == "P" } , { |x| x[ AABONOS_FLAG ] <> "P" } , @aInfAbonos )
		cCodAbono	:= IF( !Empty( aInfAbonos ) , aInfAbonos[ 01 , AABONOS_CODIGO ] , __cLimpaMotAbo )
        aNewAbonos	:= {}

	    IF ( ( lRF0ChkTable ) .and. Empty( aInfAbonos ) )

			aNewAbonos	:= aResult[ nX , ARESULT_RESULT_APO ]
			nHrsPreAbono := fFiltAbo( aAbonos , { |x| x[ AABONOS_FLAG ] <> "P"} , { |x| x[ AABONOS_FLAG ] == "P"} , @aPreAbonos )
		    
		    nHrsAbono	:= SubHoras( nHrsAbono , nHrsPreAbono )
		    nHrsAbono	:= SomaHoras( nHrsAbono ,  aResult[ nX , ARESULT_NUM_ABO_HRS]) //01 -> Array com as Horas Abonadas para o Evento do Dia (Evento + Tipo Marc + C.Custo)
			
			cCodAbono	:= IF( !Empty( aInfAbonos ) , aInfAbonos[ 01 , AABONOS_CODIGO ] , IF( !Empty( aNewAbonos ) , aNewAbonos[ 01 , AABONOS_CODIGO ] , __cLimpaMotAbo ) )

        EndIF
		
       	cCodAbono	:= IF( !Empty( cCodAbono ) , cCodAbono , __cLimpaMotAbo )
		IF ( ( nPos := aScan( aSPC , bAsc ) ) > 0 )
			IF ( aSPC[ nPos , 7 ] == 0 ) //Eof()
				Loop //Existem Apontamentos Duplicados.... Isso nao Pode Ocorrer....
			EndIF
			IF (;
					( aSPC[ nPos , 3 ] <> aResult[ nX , ARESULT_HORAS ] );
					.or.;
					( aSPC[ nPos , 8 ] <> cCodAbono );
					.or.;
					( aSPC[ nPos , 9 ] <> nHrsAbono );
					.or.;
					( aSPC[ nPos , 10 ] <> aResult[ nX , ARESULT_TURNO ] );
					.or.;
					( aSPC[ nPos , 11 ] <> aResult[ nX , ARESULT_SEMANA ] );					
					.or.;
					( aSPC[ nPos , 12 ] <> aResult[ nX , ARESULT_TIPOHE ] );					
					.or.;
					( aSPC[ nPos , 13 ] <> aResult[ nX , ARESULT_PERCENT ] );					
				)	
				( cAlias )->( dbGoTo( aSPC[ nPos , 7 ] ) )
				#IFNDEF TOP
					IF RecLock( cAlias , .F. , .F. )
						( cAlias )->( PC_QUANTC		)	:= aResult[ nX , ARESULT_HORAS		]
						( cAlias )->( PC_CC			)	:= aResult[ nX , ARESULT_CC			]
						( cAlias )->( PC_TPMARCA	)	:= aResult[ nX , ARESULT_TPMARCA	]
						( cAlias )->( PC_QTABONO	)	:= nHrsAbono
						( cAlias )->( PC_ABONO		)	:= cCodAbono
						If __lCpoDataAlt .And. __lCpoUsuaAlt
						   	( cAlias )->( PC_DATAALT )	:= MsDate()
							( cAlias )->( PC_USUARIO )	:= __cUserId
						EndIf                                                        
						
						//-- Portaria 1.510
						IF __lCpoTurno .and. __lCpoSemana .and. __lCpoTipoHE .and. __lCpoPercent
					 		( cAlias )->( PC_TURNO 	) 	:= aResult[ nX , ARESULT_TURNO ]
							( cAlias )->( PC_SEMANA	)  	:= aResult[ nX , ARESULT_SEMANA]
							( cAlias )->( PC_TIPOHE	)  	:= aResult[ nX , ARESULT_TIPOHE]
							( cAlias )->( PC_PERCENT)  	:= aResult[ nX , ARESULT_PERCENT]
						Endif	
						( cAlias )->( MsUnLock() )
					EndIF	
				#ELSE
					IF ( lExInAs400 )
						IF RecLock( cAlias , .F. , .F. )
							( cAlias )->( PC_QUANTC		)	:= aResult[ nX , ARESULT_HORAS 		]
							( cAlias )->( PC_CC			)	:= aResult[ nX , ARESULT_CC 		]
							( cAlias )->( PC_TPMARCA	)	:= aResult[ nX , ARESULT_TPMARCA	]
							( cAlias )->( PC_QTABONO	)	:= nHrsAbono
							( cAlias )->( PC_ABONO		)	:= cCodAbono
							If __lCpoDataAlt .And. __lCpoUsuaAlt
							   	( cAlias )->( PC_DATAALT )	:= MsDate()
								( cAlias )->( PC_USUARIO )	:= __cUserId
							EndIf                 
							                               
							//-- Portaria 1.510
							IF __lCpoTurno .and. __lCpoSemana .and. __lCpoTipoHE .and. __lCpoPercent
						 		( cAlias )->( PC_TURNO 	)  	:= aResult[ nX , ARESULT_TURNO ]
								( cAlias )->( PC_SEMANA	)  	:= aResult[ nX , ARESULT_SEMANA]
								( cAlias )->( PC_TIPOHE	)  	:= aResult[ nX , ARESULT_TIPOHE]
								( cAlias )->( PC_PERCENT) 	:= aResult[ nX , ARESULT_PERCENT]								
							Endif
							( cAlias )->( MsUnLock() )
						EndIF
					Else
						cQuery := "UPDATE "
						IF ( lExInAs400 )
							cQuery += _cDataBase+"/"+cTableName
						Else
							cQuery += cTableName
						EndIF	
						cQuery += " SET "
						cQuery += "PC_QUANTC="		+ Str( aResult[ nX , ARESULT_HORAS ] , aTamQuantC[1] , aTamQuantC[2] )
						cQuery += ", "
						cQuery += "PC_CC='"			+ aResult[ nX , ARESULT_CC ] + "'"
						cQuery += ", "
						cQuery += "PC_TPMARCA='"	+ aResult[ nX , ARESULT_TPMARCA ] + "'"
						cQuery += ", "
						cQuery += "PC_QTABONO="		+ Str( nHrsAbono , aTamAbonos[1] , aTamAbonos[2] )
						cQuery += ", "
						cQuery += "PC_ABONO='"		+ cCodAbono + "'"

						//-- Portaria 1.510
						IF __lCpoTurno .and. __lCpoSemana .and. __lCpoTipoHE .and. __lCpoPercent
							cQuery += ", "
							cQuery += "PC_TURNO='"			+ aResult[ nX , ARESULT_TURNO ] + "'"
							cQuery += ", "
							cQuery += "PC_SEMANA='"			+ aResult[ nX , ARESULT_SEMANA ] + "'"
							cQuery += ", "
							cQuery += "PC_TIPOHE='"			+ aResult[ nX , ARESULT_TIPOHE ] + "'"
							cQuery += ", "
							cQuery += "PC_PERCENT="		+ ALLTRIM(STR(aResult[ nX , ARESULT_PERCENT ] ))
						Endif
					
						cQuery += " WHERE " 
						cQuery += cCpoRecno + "=" + Str( aSPC[ nPos , 7 ] , 10 , 0 ) 
						
						TcSqlExec( cQuery )
						cQuery := ""
					EndIF
				#ENDIF
			EndIF
			aSPC[ nPos , 7 ] := 0
		Else
			IF RecLock( cAlias , .T. , .F. )
				( cAlias )->( PC_FILIAL		)	:= cFil
				( cAlias )->( PC_MAT		)	:= cMat
				( cAlias )->( PC_DATA		)	:= aResult[ nX , ARESULT_DATA		]
				( cAlias )->( PC_PD			)	:= aResult[ nX , ARESULT_EVENTO 	]
				( cAlias )->( PC_QUANTC		)	:= aResult[ nX , ARESULT_HORAS  	]
				( cAlias )->( PC_CC			)	:= aResult[ nX , ARESULT_CC			]
				( cAlias )->( PC_TPMARCA	)	:= aResult[ nX , ARESULT_TPMARCA	]
				( cAlias )->( PC_QTABONO	)	:= nHrsAbono
				( cAlias )->( PC_ABONO		)	:= cCodAbono
				If __lCpoDataAlt .And. __lCpoUsuaAlt
				   	( cAlias )->( PC_DATAALT )	:= MsDate()
					( cAlias )->( PC_USUARIO )	:= __cUserId
				EndIf
				
				//-- Portaria 1.510
				IF __lCpoTurno .and. __lCpoSemana .and. __lCpoTipoHE .and. __lCpoPercent
			 		( cAlias )->( PC_TURNO 	)  	:= aResult[ nX , ARESULT_TURNO ]
					( cAlias )->( PC_SEMANA	)  	:= aResult[ nX , ARESULT_SEMANA]
					( cAlias )->( PC_TIPOHE	)  	:= aResult[ nX , ARESULT_TIPOHE]
					( cAlias )->( PC_PERCENT)  	:= aResult[ nX , ARESULT_PERCENT]
				Endif
				
				( cAlias )->( MsUnLock() )
			EndIF
		EndIF

		DelAbo( aPreAbonos )

		IF !Empty( aNewAbonos )

			GravaAbo( 	cFil								,;	//01 -> Filial do Funcionario
						cMat								,;	//02 -> Matricula do Funcionario
						aNewAbonos				    		,;	//03 -> Horarios do Apontamento Abonado
						aResult[ nX , ARESULT_DATA		]	,;	//04 -> Data da Geracao
						aResult[ nX , ARESULT_EVENTO	]	,;	//05 -> Codigo do Evento
						aResult[ nX , ARESULT_CC		]	,;	//06 -> Centro de Custo a ser Gravado
						aResult[ nX , ARESULT_TPMARCA	]	 ;	//07 -> Tipo de Marcacao   
					) 
		EndIF
		
	EndIF

Next nX

For nX := 1 To nLenSPC
	IF (;
			( aSPC[ nX , 7 ] > 0 );
			.and.;
			( aSPC[ nX , 4 ] == 0 );
			.and.;
			!( aSPC[ nX , 02 ] $ cEveMesA );
		 )
		( cAlias )->( dbGoTo( aSPC[ nX , 7 ] ) )
		IF RecLock( cAlias , .F. , .F. )
			IF !( cAlias )->( FkDelete( @cMsgErr ) )
				( cAlias )->( RollBackDelTran( cMsgErr ) )
			EndIF
			( cAlias )->( MsUnLock() )
		EndIF
		fAbonos( aSPC[ nX , 01 ] , aSPC[ nX , 2 ] , NIL , @aAbonos , aSPC[ nX , 6 ] , aSPC[ nX , 5 ] , aAbonosPer )
		fFiltAbo( aAbonos , { |x| x[ AABONOS_FLAG ] <> "P" } , { |x| x[ AABONOS_FLAG ] == "P" } , @aPreAbonos )
		DelAbo( aPreAbonos )
	EndIF
Next nX

IF !( nSvOrder == nOrder )
	( cAlias )->( dbSetOrder( nSvOrder ) )
EndIF

cFilAnt	:= cSvFilAnt

Return( NIL )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGravaAbo  Ё Autor Ё Mauricio MR           Ё Data Ё10/05/2004Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁGrava o Abonos no SPK.		                                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>                                   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>                                   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGravacao dos Pre-Abonos no SPK                              Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function GravaAbo(	cFil						,;	//01 -> Filial do Funcionario
							cMat						,;	//02 -> Matricula do Funcionario
							aHorarios				    ,;	//03 -> Horarios do Apontamento Abonado
							dDtGer						,;	//04 -> Data da Geracao
							cEvento						,;	//05 -> Codigo do Evento
							cCusto   					,;	//06 -> Centro de Custo a ser Gravado
							cTpMarc						 ;	//07 -> Tipo de Marcacao   
						 ) 

Local lPkTpMarca	:= ( Type( "SPK->PK_TPMARCA" ) == "C" )

Local nLoop
Local nLoops

nLoops := Len( aHorarios )
For nLoop := 1 To nLoops
	
	IF SPK->( RecLock( "SPK" , .T. , .F. ) )
		SPK->PK_FILIAL	:= cFil
		SPK->PK_MAT		:= cMat
		SPK->PK_CODABO	:= aHorarios[ nLoop , AABONOS_CODIGO ] 
		SPK->PK_CODEVE	:= cEvento
	    SPK->PK_DATA	:= dDtGer
		SPK->PK_CC		:= cCusto
		SPK->PK_HRSABO	:= aHorarios[ nLoop , AABONOS_HORAS_ABO	] 
		SPK->PK_HORINI	:= aHorarios[ nLoop , AABONOS_HORAS_INI	]
		SPK->PK_HORFIM	:= aHorarios[ nLoop , AABONOS_HORAS_FIM	] 
		IF ( lPkTpMarca )
			SPK->PK_TPMARCA	:= cTpMarc
		EndIF
		SPK->PK_FLAG	:= "P"
		If __lCpoDataAlt .And. __lCpoUsuaAlt
		   	SPK->PK_DATAALT 	:= MsDate()
			SPK->PK_USUARIO 	:= __cUserId
		EndIf
		SPK->( MsUnLock() )
	EndIF        

	/*
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Altera Flag da Faixa de Pre-Abono							  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/	
	RF0->( dbgoto( aHorarios[ nLoop , ELEMENTOS_AABONOS + 1 ] ) )
	
	If	RF0->RF0_ABONA <> 'S'
		IF RecLock( 'RF0' , .F. , .F. )
		   RF0->RF0_ABONA := 'S' 
		   RF0->( MsUnLock() )	
        Endif
	Endif 

Next nLoop

aHorarios := {}

Return( NIL )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    Ё DelAbo   Ё Autor Ё Mauricio MR           Ё Data Ё13/05/2004Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o Ё Deleta Abonos no SPK.		                                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё Vide Parametros                                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ                                                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       Ё Generico                                                   Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function DelAbo( aPreAbonos ) //01 -> Array de Abonos Pre-Abonados

Local cMsgErr
Local nLoop
Local nLoops

DEFAULT aPreAbonos := {}

nLoops := Len( aPreAbonos )
For nLoop := 1 To nLoops
	SPK->( dbGoto( aPreAbonos[ nLoop , AABONOS_RECNO ] ) )
	IF ( SPK->( Recno() ) == aPreAbonos[ nLoop , AABONOS_RECNO ] )
		IF RecLock( "SPK" , .F. , .F. )
			IF !SPK->( FkDelete( @cMsgErr ) )
				SPK->( RollBackDelTran( cMsgErr ) )
			EndIF
			SPK->( MsUnLock() )
		EndIF
	EndIF	
Next nLoop

aPreAbonos := {}

Return( NIL )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁfFiltAbo		ЁAutorЁMauricio MR		  Ё Data Ё12/05/2004Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁFiltra Abonos											    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                  	                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fFiltAbo( aAbonos , bSkip , bCondRet , aRetorno )

Local nHrsAbo	:= 0

Local nLoop
Local nLoops

DEFAULT aAbonos		:= {}
DEFAULT bSkip 		:= { || .F. }
DEFAULT bCondRet 	:= { || .T. }

aRetorno := {}

nLoops := Len( aAbonos )
For nLoop := 1 To nLoops
    IF Eval( bSkip , aAbonos[ nLoop ] )
       Loop
    EndIF
	IF Eval( bCondRet , aAbonos[ nLoop ] )
	   aAdd( aRetorno , aAbonos[ nLoop ] )
	EndIF
	nHrsAbo := SomaHoras( nHrsAbo , aAbonos[ nLoop , AABONOS_HORAS_ABO	] )
Next nLoop

Return( nHrsAbo )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁPerAponta Ё Autor Ё Equipe Advanced RH    Ё Data Ё14/04/1997Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna a data inicio e fim para apontamento das marcacoes. Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё          ЁObs.:Quando a Data Inicial e Maior que a Data Final a fun┤└oЁ
Ё          Ёir═ considerar que o apontamento ┌ feito de um mes para   ouЁ
Ё          Ёtro, e quando a Data Final for maior que a Data Inicial,   aЁ
Ё          Ёfun┤└o ir═ considerar que o apontamento ┌ feito no m┬s.     Ё
Ё          ЁCaso a dData nao for passado assume a dDataBase do Sistema. Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PerAponta(		dPerIni			,;	//Data Inicial passada como referencia
						dPerFim 		,;	//Data Final   passada como referencia
						dData			,;	//Data Base
						lShowHelp		,;	//Mostrar o Help
						cFil			,;	//Filial para GetMv
						lNewPer			,;	//Se eh para gerar um novo periodo
						lPerCompleto	,;	//Se o periodo esta preenchido com AAAAMMDD/AAAAMMDD ou AAAAMMDDAAAAMMDD (por referencia)
						lIncDate		,;	//Se Quando lNewPer Incrementa Data, caso contrario Decrementa
						lUseParamPer	 ;	//Se quando periodo completo considerar dPerIni e dPerFim passados como parametro
				 )

Local cSvFilAnt			:= cFilAnt
Local lPerNotOk			:= .F.

Local cDiaIni
Local cDiaFim
Local cMesIni
Local cMesFim
Local cAnoIni
Local cAnoFim
Local cPerAponta
Local nDiaIni
Local nDiaFim

DEFAULT dPerIni			:= Ctod("//")
DEFAULT dPerFim			:= Ctod("//")
DEFAULT dData			:= dDataBase
DEFAULT lShowHelp		:= .T.
DEFAULT cFil			:= cSvFilAnt
DEFAULT lNewPer			:= .F.
DEFAULT lIncDate		:= .T.
DEFAULT lUseParamPer	:= .F.

lPerCompleto		:= .F.

cFilAnt := IF( !Empty( cFil ) , cFil , cFilAnt )

Begin Sequence

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁVerifica o Modo de Acesso do Cadastro de Periodos de ApontamenЁ
	Ёto															   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF !( lPerNotOk := CheckModSPO() )
		Break
	EndIF

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁVerifica se o Conteudo do  MV_PAPONTA esta OK  			   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( lPerNotOk := !PapontaOk( @cPerAponta , @nDiaIni , @nDiaFim , cFil ) )
		Break
	EndIF
	
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Para Possibilitar que o periodo seja definido pelo    usuarioЁ
	Ё Este devera ser preenchido com a String de Data da   SeguinteЁ
	Ё te forma AAAAMMDD/AAAAMMDD ou AAAAMMDDAAAAMMDD. Onde AAAA corЁ
	Ё responde ao ano com 4 digitos, MM ao mes com 2 digitos e   DDЁ
	Ё corresponde ao dia com 2 Digitos. A barra (/) separadora   seЁ
	Ё servira apenas para facilitar a leitura do periodo pelo  usuaЁ
	Ё rio. Essa forma de Preenchimento do Parametro ira   facilitarЁ
	Ё as Empresas que reduzem ou aumentam o periodo em  determinadoЁ
	Ё mes. Obs.: Essa forma de preenchimento devera ser   utilizadaЁ
	Ё apenas para os meses em que o periodo for diferente do padraoЁ
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( lPerCompleto := PerCompleto( @cPerAponta ) )

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁQuando Nao Considerar as Datas Passadas Redefine-as   confermeЁ
		Ёconteudo de MV_PAPONTA										   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF !( lUseParamPer )
			dPerIni := Stod( Left(	cPerAponta , 08 ) )
			dPerFim := Stod( Right(	cPerAponta , 08 ) )
		EndIF	

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁQuando for um novo Periodo Incrementa ou Decrementa		   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( lNewPer )
			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁApura o Novo periodo baseado no numero de dias do periodo anteЁ
			Ёrior														   Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF ( lIncDate )
				PonIncDate( @dPerIni , @dPerFim )
			Else
				PonDecDate( @dPerIni , @dPerFim )
			EndIF	
		EndIF

		Break

	EndIF

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁA Principio, Inicio ┌ no mes corrente.						   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( nDiaIni > nDiaFim )

		cMesIni := Month2Str( dData )
		cAnoIni := Year2Str( dData )
		cDiaIni := Day2Str( Min( nDiaIni , f_UltDia( Ctod( "01/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" ) ) ) )
		dPerIni := Ctod( cDiaIni + "/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" )

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁAcrescenta um dia ao Periodo Inicial se Inicio do Periodo for Ё
		Ё>= 29 e Mes Fev.											   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF (;
				(;
					( Month( dPerIni ) == 2 );
					.or.;
					( ( Month( dPerIni ) - 1 )  == 2 );
				);
				.and.;
				( nDiaIni >= 29 );
			)	
			IF ( Day( dPerIni ) != nDiaIni )
				dPerIni++
			EndIF
		EndIF

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁSe Inicio for Apos Data-Base, Retrocede 1 mes.				   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( dPerIni > dData )
			cMesIni := Month2Str( IF( Month( dData ) - 1 == 0 , 12 , Month( dData ) -1 ) )
			cAnoIni := Year2Str( IF( cMesIni == "12" , Year(dData) - 1 , Year( dData ) ) )
			cDiaIni := Day2Str( Min( nDiaIni , f_UltDia( Ctod( "01/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" ) ) ) )
			dPerIni := Ctod( cDiaIni + "/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" )
		EndIF

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁA Principio, Data Final ┌ 1 mes apos a data Inicial.		   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		cMesFim := Month2Str( IF( Month( dPerIni ) + 1 == 13 , 1 , Month( dPerIni ) + 1 ) )
		cAnoFim := Year2Str( IF( cMesFim == "01" , Year( dPerIni ) + 1 , Year( dPerIni ) ) )
		cDiaFim := Day2Str( Min( nDiaFim , f_UltDia( Ctod( "01/" + cMesFim + "/" + cAnoFim , "DDMMYYYY" ) ) ) )
		dPerFim := Ctod( cDiaFim + "/" + cMesFim + "/" + cAnoFim , "DDMMYYYY" )

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁA Data Final ┌ no mesmo mes da Data Inicio.				   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( ( dPerFim - dPerIni ) > 50 )
			cDiaFim := Day2Str( Min( nDiaFim , f_UltDia( Ctod( "01/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" ) ) ) )
			dPerFim := Ctod( cDiaFim + "/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" )
		EndIF

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁAcrescenta um dia ao Periodo Inicial quando o dia deste    forЁ
		Ёigual ao do Periodo Final									   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF (;
				(;
					( Day( dPerIni ) == Day( dPerFim ) );
					.or.;
					( Day( dPerIni ) < Day( dPerFim ) );
		    	);
		    	.and.;
		    	( AnoMes( dPerIni ) != AnoMes( dPerFim ) );
		   ) 
			dPerIni++
		EndIF

		Break

	EndIF

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁA Principio, Final ┌ no mes corrente.						   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	cMesFim := Month2Str( dData )
	cAnoFim := Year2Str( dData )
	cDiaFim := Day2Str( Min( nDiaFim , f_UltDia( Ctod( "01/" + cMesFim + "/" + cAnoFim , "DDMMYYYY" ) ) ) )
	dPerFim := Ctod( cDiaFim + "/" + cMesFim + "/" + cAnoFim , "DDMMYYYY" )

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁSe Final for Antes da Data-Base, Avan┤a 1 mes.				   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( dPerFim < dData )
		cMesFim := Month2Str( IF( Month( dData ) + 1 == 13 , 1 , Month( dData ) +1 ) )
		cAnoFim := Year2Str( IF( cMesFim == "01" , Year( dData ) + 1 , Year( dData ) ) )
		cDiaFim := Day2Str( Min( nDiaFim , f_UltDia( Ctod( "01/" + cMesFim +"/" + cAnoFim , "DDMMYYYY" ) ) ) )
		dPerFim := Ctod( cDiaFim + "/" + cMesFim + "/" + cAnoFim , "DDMMYYYY" )
	EndIF

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁA Principio, Data Inicial ┌ 1 mes anterior a data Final.	   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	If nDiaFim > nDiaIni
		cMesIni := Month2Str( IF( Month( dPerFim ) - 1 == 0 , 12 , Month( dPerFim ) ) )
		cAnoIni := Year2Str( IF( cMesIni == "12" , Year(dPerFim) - 1 , Year( dPerFim ) ) )
		cDiaIni := Day2Str( Min( nDiaIni , f_UltDia( Ctod( "01/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" ) ) ) )
		dPerIni := Ctod( cDiaIni + "/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" )	
	Else
		cMesIni := Month2Str( IF( Month( dPerFim ) - 1 == 0 , 12 , Month( dPerFim ) -1 ) )
		cAnoIni := Year2Str( IF( cMesIni == "12" , Year(dPerFim) - 1 , Year( dPerFim ) ) )
		cDiaIni := Day2Str( Min( nDiaIni , f_UltDia( Ctod( "01/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" ) ) ) )
		dPerIni := Ctod( cDiaIni + "/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" )
	EndIf

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁA Data Inicial ┌ no mesmo mes da Data Final.				   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( ( dPerFim - dPerIni ) > 50 ) 
		cDiaIni := Day2Str( Min( nDiaIni , f_UltDia( Ctod( "01/" + cMesFim + "/" + cAnoFim , "DDMMYYYY" ) ) ) )
		dPerIni := Ctod( cDiaIni + "/" + cMesFim + "/" + cAnoFim , "DDMMYYYY" )
	EndIF

End Sequence

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Se ocorreu alguma Inconsistencia Verifica se Deve Mostrar   oЁ
Ё Help														   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( lPerNotOk )
	IF ( lShowHelp )
		Help("" , 1 , "PERNCAD" )
	EndIF	
EndIF

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Restaura cFilAnt											   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
cFilAnt := cSvFilAnt
	
Return( !( lPerNotOk ) )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGetPerAtu		ЁAutorЁMarinaldo de Jesus Ё Data Ё25/08/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁDisponibilizar Dialogo para Alteracao do Periodo 			Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>     								Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁPona080Calend												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Retorno  ЁNIL															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >									Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetPerAtu( dDataIni , dDataFim , oDataIni , oDataFim )

GetPonMesDat( @dDataIni , @dDataFim  , xFilial("SRA") )
IF ( ValType( oDataIni ) == "O" )
	oDataIni:Refresh()
EndIF	
IF ( ValType( oDataFim ) == "O" )
	oDataFim:Refresh()
EndIF	

Return( NIL )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGetPerPrev		ЁAutorЁMarinaldo de Jesus Ё Data Ё25/08/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁDisponibilizar Dialogo para Alteracao do Periodo 			Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>     								Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁPona080Calend												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Retorno  ЁNIL															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >									Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetPerPrev(	dDataIni	,;
						dDataFim	,;
						oDataIni	,;
						oDataFim	,;
						lShowHelp	,;
						lGetNewPer	,;
						lIncDate	,;
						lUseParamPer ;
					)

Local dData := ( dDataIni - 1 )

Local nFimPer
Local nDay

DEFAULT lShowHelp		:= .T.
DEFAULT lGetNewPer		:= .T.
DEFAULT lIncDate		:= .F.
DEFAULT lUseParamPer	:= .T.

IF PapontaOk( NIL , NIL , @nFimPer )
	IF ( nFimPer <> NIL )
		nDay := Day( dData )
		IF ( nDay > nFimPer )
			While ( Day( dData ) <> nFimPer )
				--dData	
			End While
		EndIF	
	EndIF
EndIF

PerAponta(	@dDataIni 		,;	//Data Inicial passada como referencia
			@dDataFim 		,;	//Data Final   passada como referencia
			dData			,;	//Data Base
			lShowHelp		,;	//Mostrar o Help
			xFilial("SRA")	,;	//Filial para GetMv
			lGetNewPer		,;	//Se eh para gerar um novo periodo
			NIL				,;	//Se o periodo esta preenchido com AAAAMMDD/AAAAMMDD ou AAAAMMDDAAAAMMDD (por referencia)
			lIncDate		,;  //Se Quando lNewPer Incrementa Data, caso contrario Decrementa
			lUseParamPer  	 ;	//Se quando periodo completo considerar dPerIni e dPerFim passados como parametro
		  )

IF ( ValType( oDataIni ) == "O" )
	oDataIni:Refresh()
EndIF	
IF ( ValType( oDataFim ) == "O" )
	oDataFim:Refresh()
EndIF	

Return( NIL )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGetPerNext		ЁAutorЁMarinaldo de Jesus Ё Data Ё25/08/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁDisponibilizar Dialogo para Alteracao do Periodo 			Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>     								Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁPona080Calend												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Retorno  ЁNIL															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >									Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetPerNext(	dDataIni 	,;
						dDataFim 	,;
						oDataIni 	,;
						oDataFim 	,;
						lShowHelp	,;
						lGetNewPer	,;
						lIncDate	,;
						lUseParamPer ;
					)

Local dData := ( dDataFim + 1 )

Local nIniPer
Local nDay

DEFAULT lShowHelp		:= .T.
DEFAULT lGetNewPer		:= .T.
DEFAULT lIncDate		:= .T.
DEFAULT lUseParamPer    := .T.

IF PapontaOk( NIL , @nIniPer )
	IF ( nIniPer <> NIL )
		nDay := Day( dData )
		IF ( nDay < nIniPer )
			While ( Day( dData ) <> nIniPer )
				++dData	
			End While
		EndIF	
	EndIF
EndIF

PerAponta(	@dDataIni 		,;	//Data Inicial passada como referencia
			@dDataFim 		,;	//Data Final   passada como referencia
			dData			,;	//Data Base
			lShowHelp		,;	//Mostrar o Help
			xFilial("SRA")	,;	//Filial para GetMv
			lGetNewPer		,;	//Se eh para gerar um novo periodo 
			NIL				,;	//Se o periodo esta preenchido com AAAAMMDD/AAAAMMDD ou AAAAMMDDAAAAMMDD (por referencia)
			lIncDate		,;  //Se Quando lNewPer Incrementa Data, caso contrario Decrementa
			lUseParamPer 	 ;	//Se quando periodo completo considerar dPerIni e dPerFim passados como parametro
		  )

IF ( ValType( oDataIni ) == "O" )
	oDataIni:Refresh()
EndIF	
IF ( ValType( oDataFim ) == "O" )
	oDataFim:Refresh()
EndIF	

Return( NIL )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGetPerSPO		ЁAutorЁMarinaldo de Jesus Ё Data Ё29/08/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRetorna consulta SXB ao RPO                      			Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>     								Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁPona080Calend												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Retorno  ЁNIL															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >									Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetPerSPO( dDataIni , dDataFim , oDataIni , oDataFim )

IF ( PerApoConPad() )
	dDataIni := SPO->PO_DATAINI
	dDataFim := SPO->PO_DATAFIM
	IF ( ValType( oDataIni ) == "O" )
		oDataIni:Refresh()
	EndIF	
	IF ( ValType( oDataFim ) == "O" )
		oDataFim:Refresh()
	EndIF	
EndIF

Return( NIL )

/*/
зддддддддддбдддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGetPaponta Ё Autor Ё Marinaldo de Jesus   Ё Data Ё30/06/2004Ё
цддддддддддедддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁObtem o Conteudo do parametro MV_PAPONTA                    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetPaponta( cFil )

Local cSvFilAnt		:= cFilAnt

Local cPerAponta

DEFAULT cFil		:= cFilAnt

cFilAnt		:= IF( !Empty( cFil ) , cFil , cFilAnt )
cPerAponta	:= AllTrim( StrTran( GetMv( "MV_PAPONTA" , NIL , "" ) , " " , "" ) )
cFilAnt		:= cSvFilAnt

Return( cPerAponta )

/*/
зддддддддддбдддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁPapontaOk  Ё Autor Ё Marinaldo de Jesus   Ё Data Ё30/06/2004Ё
цддддддддддедддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica se o parametro MV_PAPONTA este com o Conteudo OK   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PapontaOk( cPerAponta , nIniPer , nFimPer , cFil )

Local lPapontaOk := .T.

DEFAULT cPerAponta := GetPaponta( cFil )

Begin Sequence

	IF !( lPapontaOk := !Empty( cPerAponta ) )
		Break
	EndIF
	
	IF PerCompleto( @cPerAponta )
		Break
	EndIF

	nIniPer	:= Val( Left( cPerAponta , 2 ) )
	IF !( lPapontaOk := ( nIniPer > 0 ) )
		Break
	EndIF

	nFimPer := Val( Right( cPerAponta , 2 ) )
	IF !( lPapontaOk := ( nFimPer > 0 ) )
		Break
	EndIF

	IF !( lPapontaOk := ( nIniPer <= 31 ) )
		Break
	EndIF

	IF !( lPapontaOk := ( nFimPer <= 31 ) )
		Break
	EndIF

	IF !( lPapontaOk := ( nIniPer <> nFimPer ) )
		Break
	EndIF

End Sequence

Return( lPapontaOk )

/*/
зддддддддддбдддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁPerCompletoЁ Autor Ё Marinaldo de Jesus   Ё Data Ё30/06/2004Ё
цддддддддддедддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica se o parametro MV_PAPONTA este Preenchido com o conЁ
Ё          Ёteudo equivalente a "AAAAMMDD/AAAAMMDD"                     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PerCompleto( cPerAponta , cFil )
DEFAULT cPerAponta := GetPaponta( cFil )
Return( ( ( Len( cPerAponta ) == 17 ) .or. ( Len( cPerAponta ) == 16 ) ) )

/*/
зддддддддддбдддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGetPonMes  Ё Autor Ё Marinaldo de Jesus   Ё Data Ё01/07/2004Ё
цддддддддддедддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁObtem o Conteudo do parametro MV_PONMES                     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetPonMes( cFil )

Local cSvFilAnt		:= cFilAnt

Local cPonMes

DEFAULT cFil		:= cFilAnt

cFilAnt	:= IF( !Empty( cFil ) , cFil , cFilAnt )
cPonMes	:= AllTrim( StrTran( GetMv( "MV_PONMES" , NIL , "" ) , " " , "" ) )
cFilAnt	:= cSvFilAnt

Return( cPonMes )

/*/
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁDescAbono Ё Autor Ё Equipe Advanced RH    Ё Data Ё11/03/2002Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Verifica a existencia do codigo de abono e retorna a Desc. Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё Generico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ/*/
Function DescAbono( cCodigo , cTipoRet , cCampo , cFil , nSize )

Local uRet			:= ""

Local nPoscCampo
Local nPosQtdAbo
Local nPosQtdCal
Local cCpoQtdAbo
Local cCpoQtdCal

DEFAULT cTipoRet	:= ""
DEFAULT cCodigo 	:= ""
DEFAULT cCampo		:= ""
DEFAULT nSize		:= GetSx3Cache( "P6_DESC" , "X3_TAMANHO" )

cTipoRet	:= Upper( AllTrim( cTipoRet ) )
cCampo		:= Upper( AllTrim( cCampo ) )
cFil		:= xFilial( "SP6" , cFil )
cCodigo		:= IF( Empty( cCodigo ) .and. cTipoRet == "L" , &(ReadVar()) , cCodigo )

IF SP6->( MsSeek( cFil + cCodigo ) )
	uRet 		:= IF( ( cTipoRet == "L" ) , .T. , Padr( SP6->P6_DESC , nSize ) )
	cCpoQtdAbo	:= IF( cCampo == "PC_DESCABO" , "PC_QTABONO" ,"PH_QTABONO" )
	cCpoQtdCal	:= IF( cCampo == "PC_DESCABO" , "PC_QUANTC"  ,"PH_QUANTC"  )
	IF IsInGetDados( { cCampo , cCpoQtdAbo , cCpoQtdCal } )
	    IF ( ( nPoscCampo := GdFieldPos( cCampo ) ) > 0 )
			aCols[n,nPoscCampo] := SP6->P6_DESC
    	EndIF
		IF ( ( cTipoRet == "L" ) .and. ( cCampo $ "PC_DESCABO*PH_DESCABO" ) )
			nPosQtdAbo := GdFieldPos( cCpoQtdAbo )
			nPosQtdCal := GdFieldPos( cCpoQtdCal )
			IF nPosQtdAbo > 0 .and. nPosQtdCal > 0
				IF aCols[n,nPosQtdAbo] == 0
					aCols[n,nPosQtdAbo] := aCols[n,nPosQtdCal] // Calculado
				EndIF
			EndIF
		EndIF
	EndIF
Else
	uRet := IF( ( cTipoRet == "L" ) , .F. , Space( nSize ) )
EndIF

Return( uRet )

/*/
зддддддддддбддддддддбдддддбддддддддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁfCargaIdЁAutorЁMauro     1a. Versao  	   Ё Data Ё18/12/1996Ё
Ё          Ё        ЁAutorЁMarinaldo 2a. Versao  	   Ё Data Ё04/08/2004Ё
цддддддддддеддддддддадддддаддддддддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁCarregar Array com os Identificadores e Verbas               Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>                                    Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>                                    Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                     Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fCargaId( aCodigos , cFil , lStop )

Local lRet			:= .T.
Local lShowHelp		:= .T.

Local cFilSX5
Local cFilSP9
Local nOrderSP9
Local nSvSp9Ord
Local nPosEmpFil
Local nLenaCod

aCodigos			:= {}

DEFAULT cFil		:= xFilial( "SP9" , IF( Type( "SRA->RA_FILIAL" ) == "C" , SRA->RA_FILIAL , NIL ) )
DEFAULT lStop		:= .T.

Begin Sequence

	DEFAULT aCargaIdCache	:= {}
	
	cFilSP9	:= xFilial( "SP9" , cFil )
	IF ( ( nPosEmpFil := aScan( aCargaIdCache , { |x| ( x[1] == cEmpAnt ) .and. ( x[2] == cFilSp9 ) } ) ) > 0 )
		Break
	EndIF

	cFilSX5	:= xFilial( "SX5" , cFil )
	IF !( lRet := SX5->( MsSeek( cFilSX5 + "20" , .F. ) ) )
		IF ( lStop )
			lShowHelp := .F.
			Help( "" , 1 , "EVENTNCAD" )
		EndIF
		Break
	EndIF

	nOrderSP9	:= RetOrdem( "SP9" , "P9_FILIAL+P9_IDPON+P9_CODIGO" )
	nSvSp9Ord	:= SP9->( IndexOrd() )
	IF !( nOrderSP9 == nSvSp9Ord )
		SP9->( dbSetOrder( nOrderSP9 ) )
	EndIF
	SP9->( dbSeek( cFilSP9 , .F. ) )
	While SP9->( !Eof() .and. ( P9_FILIAL == cFilSP9 ) )
		IF SP9->( !Empty( P9_IDPON ) .or. !Empty( P9_CODFOL ) )
			aAdd( aCodigos , Array( 04 ) )
			nLenaCod := Len( aCodigos )
			aCodigos[nLenaCod,01] := SP9->P9_CODIGO
			aCodigos[nLenaCod,02] := SP9->P9_IDPON
			aCodigos[nLenaCod,03] := SP9->P9_DESCDSR
			aCodigos[nLenaCod,04] := SP9->P9_CODFOL
		EndIF
		SP9->(dbSkip())
	End While
	SP9->( dbSetOrder( nSvSp9Ord ) )
	aAdd( aCargaIdCache , { cEmpAnt , cFilSP9 , aClone( aCodigos ) } )
	nPosEmpFil	:= Len( aCargaIdCache )
	aCodigos	:= {}

End Sequence

IF !Empty( nPosEmpFil )
	aCodigos := aClone( aCargaIdCache[ nPosEmpFil , 3 ] )
EndIF

IF !( lRet := !Empty( aCodigos ) )
	IF ( ( lStop ) .and. ( lShowHelp ) )
		Help( " ",1,"EVENTNCAD" )
	EndIF	
EndIF

Return( lRet )

/*/
зддддддддддбддддддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁRstfCargaId   Ё Autor ЁMarinaldo de Jesus     Ё Data Ё04/08/2004Ё
цддддддддддеддддддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁReinicializa as Statics em fCargaId()                       	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL																Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RstfCargaId()

aCargaIdCache := {}

Return( NIL )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁGetEveIdPon   ЁAutorЁ Marinaldo de Jesus  Ё Data Ё15/08/2002Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna Array com Identificadores de Ponto x Eventos de acorЁ
Ё          Ёdo com o SX5                                				Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais> 									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais> 									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerico 												    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetEveIdPon( aCodigos , cFil , aLogFile, lChkEve )

Local aEveIds		:= {}
Local aArea			:= GetArea()
Local aAreaSX5		:= SX5->( GetArea() )
Local aLastLog		:= {}
Local cTabId		:= "20"
Local cChaveId		:= ""
Local cIdPon		:= "" 
Local nEveId 		:= 0
Local nPosId		:= 0
Local nEvesSX5		:= 0
Local nTotIdPonto	:= 0

DEFAULT aCodigos	:= {}
DEFAULT cFil		:= cFilSX5
DEFAULT aLogfile	:= {}  
DEFAULT lChkEve		:= .F.

IF Empty( aCodigos )
	aCodigos := {}
	fCargaId( @aCodigos , cFil , .F. )
EndIF

aLastLog := aClone( aLogFile )

cFil 		:= xFilial( "SX5" , cFil )
cChaveId	:= ( cFil + cTabId )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁInclui Novos Identificadores					              Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
PonCriaID(cFil) 

IF SX5->( dbSeek( cChaveId , .F. ) )  
	
	While SX5->( !Eof() .and. X5_FILIAL + X5_TABELA == cChaveId )
		aAdd( aEveIds , Array( 3 ) )
		cIdPon						:= Upper( AllTrim( SX5->X5_CHAVE ) )
		aEveIds[ ++nEveId , 01 ]	:= cIdPon
		IF ( nPosId := aScan( aCodigos , { |x| Upper( AllTrim( x[2] ) ) == cIdPon } ) ) == 0
			aEveIds[ nEveId , 02 ]	:= ""
		Else
			aEveIds[ nEveId , 02 ]	:= aCodigos[ nPosId , 01 ]
		EndIF
		aEveIds[ nEveId , 03 ]		:= SX5->( x5Descri() )   
		IF lChkEve
			IF Empty( aEveIds[ nEveId , 02 ] ) 
				aAdd( aLogFile , ( STR0117 + aEveIds[ nEveId , 01 ] + " - " + aEveIds[ nEveId , 03 ] ) ) //'Nao Foi Encontrado Evento para o Id. de Ponto: '
			EndIF
		EndIF
		SX5->( dbSkip() )
	End While
EndIF               

nTotIdPonto:= 42 
	
nEvesSX5 := Len( aEveIds )
IF ( !( ArrayCompare( aLastLog , aLogFile ) ) .or. ( nEvesSX5 < nTotIdPonto ) .or. ( nEvesSX5 > nTotIdPonto ) )
	aAdd( aLogFile , "" )
	aAdd( aLogFile , STR0118 )									//'- O Apontamento nao foi Efetuado porque Foram Encontradas Inconsitencias nos Eventos. ' 
	IF ( ( nEvesSX5 < nTotIdPonto ) .or. ( nEvesSX5 > nTotIdPonto ) )
		IF ( nEvesSX5 < nTotIdPonto )
			aAdd( aLogFile , STR0180 )							//'- Estao faltado codigos de Identificadores de Ponto na Tabela 20 do Configurador. '
 	 	ElseIF ( nEvesSX5 > nTotIdPonto )
			aAdd( aLogFile , STR0183 )							//'- Existem Identificadores do Ponto Duplicados na Tabela 20 do Condigurador.'
		EndIF
 	 	aAdd( aLogFile , STR0181 + StrZero( nTotIdPonto , 2 ) )			//'- Numero de Identificadores requeridos: '
 	 	aAdd( aLogFile , STR0182 + StrZero( nEvesSX5 , 2 ) )	//'- Numero de Identificadores Existentes: '
	Else
		IF lChkEve
			aAdd( aLogFile , STR0119 )								//'- Esta Faltando Vincular os Identificadores de Ponto Acima a Eventos. '
		EndIF
	EndIF
EndIF

( RestArea( aAreaSX5 ) , RestArea( aArea ) )

Return( aClone( aEveIds ) )  


/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁPonCriaID     ЁAutorЁ Mauricio MR		  Ё Data Ё23/01/2007Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁGera automaticamente novos identificadores de eventos       Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais> 									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais> 									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerico 												    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PonCriaID(cFil)     
Local aArea			:= GetArea()
Local aAreaSX5		:= SX5->( GetArea() )
Local cTabId		:= "20"
Local cChaveId		:= ""

DEFAULT cFil 		:= xFilial( "SX5" )

cChaveId			:= ( cFil + cTabId )

//-- Prima Dominical
If !SX5->(dbSeek(cChaveId+"039A"))
	SX5->(Reclock("SX5",.T.))
	SX5->X5_FILIAL := cFil
	SX5->X5_TABELA := cTabId
	SX5->X5_CHAVE  := "039A"
	SX5->X5_DESCRI := "GRATIFICACAO DOMINGO TRABALHADO"
	SX5->X5_DESCSPA:= "PRIMA DOMINICAL"
	SX5->X5_DESCENG:= "SUNDAY WORK BONUS"
	SX5->(MsUnlock())
Endif
//-- Descanso Laborado
If !SX5->(dbSeek(cChaveId+"040A"))
	SX5->(Reclock("SX5",.T.))
	SX5->X5_FILIAL := cFil
	SX5->X5_TABELA := cTabId
	SX5->X5_CHAVE  := "040A"
	SX5->X5_DESCRI := "GRATIFICACAO DESCANSO TRABALHADO"
	SX5->X5_DESCSPA:= "DESCANSO LABORADO"
	SX5->X5_DESCENG:= "PAID TIME OFF"
	SX5->(MsUnlock())
Endif
//-- Festivo Laborado
If !SX5->(dbSeek(cChaveId+"041A"))
	SX5->(Reclock("SX5",.T.))
	SX5->X5_FILIAL := cFil
	SX5->X5_TABELA := cTabId
	SX5->X5_CHAVE  := "041A"
	SX5->X5_DESCRI := "GRATIFICACAO FERIADO TRABALHADO"
	SX5->X5_DESCSPA:= "FESTIVO LABORADO"
	SX5->X5_DESCENG:= "HOLIDAY BONUS"   
	SX5->(MsUnlock())
Endif   

//-- Total Meses Banco Horas
If !SX5->(dbSeek(cChaveId+"042A"))
	SX5->(Reclock("SX5",.T.))
	SX5->X5_FILIAL := cFil
	SX5->X5_TABELA := cTabId
	SX5->X5_CHAVE  := "042A"
	SX5->X5_DESCRI := "TOTAL MESES BANCO HORAS"
	SX5->X5_DESCSPA:= "TOTAL MESES BANCO HORAS"
	SX5->X5_DESCENG:= "TOTAL MESES BANCO HORAS"   
	SX5->(MsUnlock())
Endif   
RestArea(aAreaSX5)
RestArea(aArea)

Return(NIL)



/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁObtemEveNoDeleЁAutorЁ Marinaldo de Jesus  Ё Data Ё15/08/2002Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁObtem Eventos que nao Podem ser Deletados pela GravaSPC()   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais> 									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais> 									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerico 												    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function ObtemEveNoDele( aCodigos )

Local cEvesNoDele	:= ""
Local nPos			:= 0

DEFAULT aCodigos := {}

//-- Evento de Faltas/Antrasos Meses Anteriores Autorizado
IF ( nPos := aScan( aCodigos , { |x| x[2] == "022A" } ) ) > 0
	cEvesNoDele += aCodigos[ nPos , 01 ]
EndIF

//-- Evento de Faltas/Antrasos Meses Anteriores Nao Autorizado
IF ( nPos := aScan( aCodigos , { |x| x[2] == "021N" } ) )  > 0
	cEvesNoDele += ( "/" + aCodigos[ nPos , 01 ] )
EndIF

//-- Evento de DSR Ultima Semana Periodo Anterior
IF ( nPos := aScan( aCodigos , { |x| x[2] == "036N" } ) ) > 0
	cEvesNoDele += ( "/" + aCodigos[ nPos , 01 ] )
EndIF

Return( cEvesNoDele )    


/*/
зддддддддддбдддддддддддддбддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁObtemIdPon   ЁAutor ЁMauricio MR          Ё Data Ё25/03/2005Ё
цддддддддддедддддддддддддаддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica a Existencia do Id.Ponto e Evento correspondente   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >								  	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >								  	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function ObtemIdPon( aEvesIds, cId, lOnlyId )
Local lRet	:= .F.
Local nPos	:= 0   

DEFAULT lOnlyId:= .F.

If lOnlyId
	lRet:= !Empty( (nPos:= Ascan(aEvesIds,{|aId| SUBSTR(aId[1],1,4) == cId  } ) ))
Else
	lRet:= !Empty( (nPos:= Ascan(aEvesIds,{|aId| SUBSTR(aId[1],1,4) == cId .AND. !Empty(aId[2]) } ) ))
Endif
Return lRet
                
/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁfTotaliza Ё Autor Ё Mauro                 Ё Data Ё 10/12/96 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Totalizar as Verbas do SPC                                 Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё Generico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ/*/
Function fTotaliza( aTotaliza , cFil , cMat , bAcessaSPC )

Local cFilMat		:= ""
Local dDataIni		:= Ctod("//")
Local dDataFim		:= dDataIni

DEFAULT cFil 		:= SRA->RA_FILIAL
DEFAULT cMat 		:= SRA->RA_MAT
DEFAULT aTotaliza	:= {}
DEFAULT bAcessaSPC	:= { || .T. }

IF PerAponta( @dDataIni , @dDataFim , NIL , NIL , cFil )

	cFilMat	:= ( cFil + cMat )
	IF SPC->( dbSeek( cFilMat , .F.  ) )
	
		While SPC->( !Eof() .and. cFilMat == PC_FILIAL + PC_MAT )
	
			IF SPC->( PC_DATA < dDataIni .or. PC_DATA > dDataFim )
				SPC->( dbSkip() )
				Loop
			EndIF
	
			IF !Eval( bAcessaSPC )
				SPC->( dbSkip() )
				Loop
			EndIF
	
			IF SPC->( ( nPos := aScan( aTotaliza , { |x| x[1] = IF( !Empty( PC_PDI ) , PC_PDI , PC_PD ) } ) ) > 0 )
				aTotaliza[nPos,2] := SomaHoras( aTotaliza[nPos,2] , SPC->( IF( PC_QUANTI > 0 , 0 , SubHoras( PC_QUANTC , PC_QTABONO ) ) ) )
				aTotaliza[nPos,3] := SomaHoras( aTotaliza[nPos,3] , SPC->PC_QUANTI  )
				aTotaliza[nPos,4] := SomaHoras( aTotaliza[nPos,4] , SPC->PC_QTABONO )
			Else
				SPC->( aAdd( aTotaliza , { IF( !Empty( PC_PDI ) , PC_PDI , PC_PD ) , IF( PC_QUANTI > 0 , 0 , SubHoras( PC_QUANTC , PC_QTABONO ) ) , PC_QUANTI , PC_QTABONO } ) )
			EndIF
			
			SPC->( dbSkip() )

		End While
	
	EndIF

EndIF
	
Return( NIL )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁfTabTurno Ё Autor Ё Equipe Advanced RH    Ё Data Ё18/11/1997Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o Ё Preenche um Array com a Tabela de Hor═rios dos Turnos      Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё fTabTurno( aTabTno , cFil )                                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁPar┐metrosЁ aTabTno = Array a ser alimentado com as Tabelas            Ё
Ё          Ё cFil    = Filial para Pesquisa                             Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   Ё lRet                                                       Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       Ё Gen┌rico                                                   Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fTabTurno( aTabTno , cFil , lExecQryTop , bCond )

Local lRet		:= .T.
Local nSR6Rec	:= SR6->( Recno() )

DEFAULT aTabTno	:= {}

IF ( lRet := xRetModo("SR6","SPJ") )
	IF cFil == NIL
		SR6->( dbGoTop() )
	Else
		cFil := xFilial( "SR6" , cFil )
		SR6->( MsSeek( cFil , .T. ) )
	EndIF
	While SR6->( !Eof() .and. IF( cFil == NIL , .T. , cFil <= R6_FILIAL  ) )
		fTabPadrao( @aTabTno , SR6->R6_FILIAL , SR6->R6_TURNO , lExecQryTop , bCond )
		SR6->( dbSkip() )
	End While
	IF !( lRet := !Empty( aTabTno ) )
		Help(' ',1,'TPADNCAD')
	EndIF
EndIF

IF ( SR6->( Recno() ) != nSR6Rec )
	SR6->( dbGoto( nSR6Rec ) )
EndIF

Return( lRet )

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁfTrocaTno Ё Autor ЁEquipe Advanced RH     Ё Data Ё03/09/1998Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o ЁAdiciona os Turnos pelos quais o funcionario passou durante Ё╠╠
╠╠Ё          Ёo periodo.                                                  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   ЁfTrocaTno(dPerIni,dPerFim,aTurnos,aSPF)		              Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁPar┐metrosЁdPerIni = Periodo Inicial a ser pesquizado                  Ё╠╠
╠╠Ё          ЁdPerFim = Periodo Final a ser pesquizado                    Ё╠╠
╠╠Ё          ЁaTurnos = Array a ser alimentado com as trocas de turno     Ё╠╠
╠╠Ё          ЁaSPF    = Array com as Trocas de Turno do SPF               Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё Gen┌rico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ/*/
Function fTrocaTno( dPerIni , dPerFim , aTurnos , aSPF , cSeq , lAddTrcIniPer )

Local cFil			:= SRA->RA_FILIAL
Local cMat			:= SRA->RA_MAT
Local cFilMat		:= ( cFil + cMat )
Local cRegra		:= SRA->RA_REGRA
Local cTurno		:= SRA->RA_TNOTRAB
Local cSeqTurn		:= SRA->RA_SEQTURN
Local cAlias		:= "SPF"
Local cAliasQuery	:= cAlias
Local dData     	:= Ctod("//")
Local lTrocaTno		:= .F.
Local nX        	:= 0
Local nFornX		:= 0
Local nY        	:= 0
Local nFornY		:= 0

#IFDEF TOP

	Local cIniData	 		:= ""
	Local cFimData			:= ""
	Local cQuery	 		:= ""
	Local cPrefixo			:= ( PrefixoCpo( cAlias ) + "_" )
	Local aSvAlias			:= GetArea()
	Local lQueryOpened		:= .F.

	Static aSpfFields
	Static cQrySpfFields
	Static nSpfFields

	IF !( lExInAs400 )

		DEFAULT aSpfFields := ( cAlias )->( dbStruct() )
		DEFAULT nSpfFields := Len( aSpfFields )
	
		IF ( cQrySpfFields == NIL )
			cQrySpfFields := ""
			For nX := 1 To nSpfFields
				cQrySpfFields += aSpfFields[ nX , 01 ] + ", "
			Next nX
		EndIF

	EndIF
	
#ENDIF

DEFAULT dPerIni 		:= Ctod("//")
DEFAULT dPerFim			:= Ctod("//")
DEFAULT aTurnos			:= {}
DEFAULT aSPF			:= {}
DEFAULT lAddTrcIniPer	:= .T.

IF Empty( dPerIni ) .or. Empty( dPerFim )
	PerAponta( @dPerIni , @dPerFim , NIL , NIL , cFil )
EndIF
aTurnos := {}

IF Empty( aSPF ) 

	#IFDEF TOP

		IF ( lExInAs400 )
			( cAliasQuery )->( dbSeek( cFilMat , .F. ) )
		Else
			cIniData	:= Dtos( dPerIni )
			cFimData	:= Dtos( dPerFim )
			cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )
			cQuery := "SELECT "
			cQuery += cQrySpfFields
			cQuery += "R_E_C_N_O_ RECNO "
			cQuery += " FROM "
			cQuery += InitSqlName( cAlias )
			cQuery += " WHERE "
			cQuery += cPrefixo + "FILIAL='"+cFil+"'"
			cQuery += " AND "
			cQuery += cPrefixo + "MAT='"+cMat+"'"
			cQuery += " AND "
			cQuery += cPrefixo + "DATA>='"+cIniData+"'"
			cQuery += " AND "
			cQuery += cPrefixo + "DATA<='"+cFimData+"'"
			cQuery += " AND "
			cQuery += "D_E_L_E_T_=' ' "
			cQuery += "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )
			cQuery := ChangeQuery( cQuery )
			IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
				For nX := 1 To nSpfFields
					IF !( aSpfFields[ nX , 02 ] == "C" )
						TcSetField(cAliasQuery,aSpfFields[nX,01],aSpfFields[nX,02],aSpfFields[nX,03],aSpfFields[nX,04])
					EndIF
				Next nX
			Else
				cAliasQuery := cAlias
				( cAliasQuery )->( dbSeek( cFilMat , .F. ) )
			EndIF	
		EndIF
	#ELSE
		IF ( cAliasQuery )->( dbSeek( cFilMat , .F. ) )
	#ENDIF
			While ( cAliasQuery )->( !Eof() .and. cFilMat == PF_FILIAL + PF_MAT )
				#IFNDEF TOP
					IF ( cAliasQuery )->( PF_DATA < dPerIni .or. PF_DATA > dPerFim )
						( cAliasQuery )->( dbSkip() )
						Loop
					EndIF
				#ELSE
					IF !( lQueryOpened )
						IF ( cAliasQuery )->( PF_DATA < dPerIni .or. PF_DATA > dPerFim )
							( cAliasQuery )->( dbSkip() )
							Loop
						EndIF
					EndIF
				#ENDIF
				( cAliasQuery )->( aAdd(	aSPF , {	PF_TURNODE									,;	//01 - Turno De
														PF_TURNOPA									,;	//02 - Turno Para
														PF_DATA										,;	//03 - Data
														PF_SEQUEDE									,;	//04 - Sequencia De
														PF_SEQUEPA									,;	//05 - Sequencia Para
														IF(!Empty(PF_REGRADE),PF_REGRADE,cRegra)	,;	//06 - Regra De
														IF(!Empty(PF_REGRAPA),PF_REGRAPA,cRegra)	 ;	//07 - Regra Para
					      		   					};
				    					);
					  			 )
				( cAliasQuery )->( dbSkip() )
			End While
	#IFNDEF TOP
		EndIF
	#ELSE
		IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
			( cAliasQuery )->( dbCloseArea() )
			RestArea( aSvAlias )
		EndIF	
	#ENDIF	
EndIF
	
IF ( Len(aSPF) > 0 )
	aSort( @aSPF , NIL , NIL , { |x,y| ( x[3] < y[3] ) } )
	nFornX := ( dPerFim - dPerIni )
	For nX := 0 To nFornX
		dData := dPerIni + nX
		nFornY := Len(aSPF)
		For nY := 1 To nFornY
			IF aSPF[nY,3] >= dData .And. nY < Len(aSPF) .And. dData <= aSPF[nY+1,3] .Or. ;
				aSPF[nY,3] >= dData .And. nY == Len(aSPF)
				//-- Inclui o 1o. "TURNO DE" como 1o. do periodo
				//-- qdo nao houver troca no primeiro dia do periodo
				IF Len(aTurnos)==0 .And. aSPF[nY,3] # dPerIni .and. lAddTrcIniPer
					aAdd(aTurnos, {	aSPF[nY, 1],;								//01 - Turno De
									dPerIni,;									//02 - Data
									IF(Empty(aSPF[nY,4]),cSeqTurn,aSPF[nY,4]),;	//03 - Sequencia De
									0,;											//04 - Numero Serial
									IF(Empty(aSPF[nY,6]),cRegra,aSPF[nY,6]);	//05 - Regra De
							      };
						 )
				EndIF
				//-- Inclui os "TURNO PARA" do periodo
				IF aScan(aTurnos, {|x| x[1] == aSPf[nY,2] .And. x[2] == aSPF[nY,3]}) == 0
					aAdd(aTurnos, {	aSPF[nY, 2],;								//01 - Turno Para
									aSPF[nY, 3],;								//02 - Data
									IF(Empty(aSPF[nY,5]),cSeqTurn,aSPF[nY,5]),;	//03 - Sequencia Para
									0,;											//04 - Numero Serial
									IF(Empty(aSPF[nY,7]),cRegra,aSPF[nY,7]),;	//05 - Regra Para
								  };
						 )
				EndIF
				Exit
			EndIF
		Next nY
	Next nX
EndIF

IF !( lTrocaTno := !Empty( aTurnos ) )
	DEFAULT cSeq := cSeqTurn
	IF ( lAddTrcIniPer )
		aAdd( aTurnos , { cTurno , dPerIni , cSeq , 0 , cRegra } )
	EndIF	
EndIF

Return( lTrocaTno )

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁfDepuraSP2Ё Autor Ё Fernando Joly Siquini Ё Data Ё 27.08.98 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Filtra SP2 deixando somente excecoes do Per║odo            Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё fDepuraSP2(cArqInd, dPerIni, dPerFim)                      Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ cArqInd = Nome do Arquivo de Indice (passar com "@")       Ё╠╠
╠╠Ё          Ё dPerIni = Inicio do Periodo de Depura┤└o                   Ё╠╠
╠╠Ё          Ё dPerFim = Final do Periodo de Depura┤└o                    Ё╠╠
╠╠Ё          Ё lShowDialog = Mostrar Dialogo na IndRegua                  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё Generico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ/*/
Function fDepuraSP2( cArqInd , dPerIni , dPerFim , lShowDialog )

Local cChave		:= "P2_FILIAL+P2_MAT+P2_CC+P2_TURNO+DtoS(P2_DATA)+P2_TIPODIA"
Local cPerIni		:= ""
Local cPerFim		:= ""
Local cQuery		:= ""

DEFAULT cArqInd		:= ""
DEFAULT dPerIni		:= dDataBase
DEFAULT dPerFim		:= dDataBase
DEFAULT lShowDialog := .T.

IF !Empty( cArqInd )
	RetIndex( "SP2" )
	SP2->( dbSetOrder( RetOrdem( "SP2" , cChave ) ) )
	fErase( cArqInd + OrdBagExt() )
	cArqInd := ""
EndIF

cPerIni	:= Dtos( dPerIni )
cPerFim := Dtos( dPerFim )

cArqInd	:= CriaTrab("",.F.)
cQuery  += '(((DtoS(P2_DATAATE)>="'+cPerIni+'".AND.DtoS(P2_DATAATE)<="'+cPerFim+'").OR.'
cQuery  += '(DtoS(P2_DATAATE)>="'+cPerFim+'".AND.DtoS(P2_DATA)<="'+cPerIni+'")).OR.'
cQuery  += '(DtoS(P2_DATA)>="'+cPerIni+'".AND.DtoS(P2_DATA)<="'+cPerFim+'"))'

IndRegua( "SP2" , cArqInd , cChave ,, cQuery , STR0056 , lShowDialog ) // 'Depurando Excecoes...'

Return( NIL )

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    Ё fTabSP4  Ё Autor Ё Aldo Marini Junior    Ё Data Ё 15/10/99 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Carrega tabela de Eventos do Tipo de Hora Extra            Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё Generico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ/*/
Function fTabSP4(aCodAut)

Local nLenCodAut := 0

//-- Preenche o Array aCodAut com as Horas Extras
SP4->( dbGoTop() )
While SP4->( !Eof() )
	IF (;
			SP4->(;
					aScan(aCodAut, {|x| x[1] == P4_FILIAL .and. ;
									  	x[2] == P4_TURNO  .and. ;
									  	x[3] == P4_CODAUT		;
									};
					  	) == 0;
				  );
		)		  	  	
		aAdd( aCodAut , Array( 04 ) )
		nLenCodAut := Len( aCodAut )
		aCodAut[nLenCodAut,01] := SP4->P4_FILIAL
		aCodAut[nLenCodAut,02] := SP4->P4_TURNO
		aCodAut[nLenCodAut,03] := SP4->P4_CODAUT
		aCodAut[nLenCodAut,04] := "A"
	EndIF
	IF (;
			SP4->(;
					aScan(aCodAut, {|x| x[1] == P4_FILIAL .and. ;
								  		x[2] == P4_TURNO  .and. ;
								  		x[3] == P4_CODNAUT		;
								  	};
						  ) == 0;
				);
		)										  
		aAdd( aCodAut , Array( 04 ) )
		nLenCodAut := Len( aCodAut )
		aCodAut[nLenCodAut,01] := SP4->P4_FILIAL
		aCodAut[nLenCodAut,02] := SP4->P4_TURNO
		aCodAut[nLenCodAut,03] := SP4->P4_CODNAUT
		aCodAut[nLenCodAut,04] := "N"
	EndIF
	SP4->( dbSkip() )
End While

aCodAut := aSort( @aCodAut , NIL , NIL , { |x,y| x[2]+x[3] > y[2]+y[3] } )

Return( NIL )

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁfBscEven  Ё Autor Ё Aldo Marini Junior    Ё Data Ё 28.12.98 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Retorna % ou Efetua validacao do Evento                    Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё fBscEven(cEvento,nTipo,nTpEvento)                          Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ cEvento  = Codigo do Evento a ser pesquisado               Ё╠╠
╠╠Ё          Ё nTipo    = 1-Percentual Evento 2-Validacao do Evento       Ё╠╠
╠╠Ё          Ё nTpEvento= 1-Autorizado 2-Nao Autorizado 3-Ambos           Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё Generico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠*/
Function fBscEven( cEvento , nTipo , nTpEvento )

Local nPerc		:= 100
Local cCodFol	:= ""
Local lRet		:= .T.

IF nTipo == 1
	IF ( nPerc := PosSP9(cEvento,SRA->RA_FILIAL,"P9_BHPERC") ) <= 0
		nPerc := 100
	EndIF
Else
	cCodFol := PosSP9(cEvento,SRA->RA_FILIAL,"P9_CODFOL")
	IF ( Empty(cCodFol) .and. nTpEvento == 1 ) .or. ( !Empty(cCodFol) .and. nTpEvento == 2 )
		lRet := .F.
	EndIF
EndIF

Return( IF( nTipo == 1 , nPerc ,  lRet ) )

/*/
зддддддддддбддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁfValidMarc	Ё Autor ЁEquipe Advanced RH    Ё Data Ё11/07/2001Ё
цддддддддддеддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁValidar a multipla escolha do tipo de marcacao 1E/1S ..		 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁfValidMarc( l1Elem , cTipo )								 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ                                                     		 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   Ё.T.                                                  	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁApontamento                                                  Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fValidMarc( l1Elem , cTipo )

Local aMarc		:= {}
Local aStruct	:= SPJ->( dbStruct() )
Local bSort		:= { || NIL }
Local cMarc		:= ""
Local cTitulo	:= ""
Local cMvParDef	:= ""
Local cMvPar	:= &( Alltrim( ReadVar() ) )
Local nX		:= 0
Local nCampos	:= Len( aStruct )

Private uMvRet	:= Alltrim( ReadVar() )

l1Elem			:= IF( l1Elem == NIL .and. ValType( l1Elem ) != "L" , .F. , .T. )

bSort := { |x,y| ( SubStr( x[1] , 9 , 1 ) + SubStr( x[1] , 4 , 1 ) );
				 <;
				 ( SubStr( y[1] , 9 , 1 ) + SubStr( y[1] , 4 , 1 ) );
		 }

CursorWait()

	aSort( @aStruct , NIL , NIL , bSort )
	
	IF ( cTipo != "I" )
		For nX := 1 To nCampos
			cCampo := Upper( AllTrim( aStruct[ nX , 01 ] ) )
			IF Subs(cCampo,1,8) $ "PJ_ENTRA_PJ_SAIDA"
				cMarc := SubStr( cCampo , 9 , 1 ) + SubStr( cCampo , 4 , 1 )
				cMvParDef += ( cMarc + "-" )
				aAdd( aMarc , cMarc += ( "-" + GetDescMarc( cMarc  ) ) )
			EndIF
		Next nX
	Else
		aAdd( aMarc , "I1-" + GetDescMarc( "I1" ) )
		aAdd( aMarc , "I2-" + GetDescMarc( "I2" ) )
		aAdd( aMarc , "I3-" + GetDescMarc( "I3" ) )
		cMvParDef := "I1-I2-I3-"
	EndIF

CursorArrow()
	
IF ( cMvPar != NIL )
	IF f_Opcoes(@cMvPar,cTitulo,aMarc,cMvParDef,12,49,l1Elem,3,8)
		&(uMvRet) := cMvPar
	EndIF	
EndIF	

Return( .T. )

/*/
зддддддддддбдддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁfToleranciaЁ Autor ЁEquipe Advanced RH    Ё Data Ё22/03/2001Ё
цддддддддддедддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o Ё Extrai a tolerancia da regra de apontamento.               Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё fTolerancia(cString, nMarc)								Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ cString - String contendo as tolerancias separadas por '-' Ё
Ё          Ё nMarc   - Numero sequencial da marcacao referente a tol. 	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   Ё Generico 													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fTolerancia( cString , nMarc )

Local nTolera := 0				//-- Retorno da tolerancia
Local nY      := 0				//-- Contador da quantidade de tolerancias
Local nPos    := 1				//-- Posicao para extracao de cString
Local nLenStr := Len(cString)	//-- Tamanho da String

While ( nPos <= nLenStr )
	nY++
	IF ( nY > nMarc )
		Exit
	ElseIF ( nY == nMarc )
		nTolera := __Min2Hrs( Val( Subs( cString , nPos , 2 ) ) )
		Exit
	EndIF
	nPos += 3
End While

Return( nTolera )

/*/
зддддддддддбддддддддддбдддддбдддддддддддддддддддддддддбддддддбдддддддддд©
ЁFuncao	   ЁfAbonos   ЁAutorЁEquipe Advanced RH Ver. IЁ Data Ё04/04/2001Ё
Ё          Ё          Ё     ЁMarinaldo de Jesus Ver.IIЁ Data Ё27/04/2004Ё
цддддддддддеддддддддддадддддадддддддддддддддддддддддддаддддддадддддддддд╢
ЁDescricao ЁVerifica a existencia de abonos.                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerico 												  	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fAbonos(	dData		,;	//Data do Abono
					cPD			,;	//Evento do Abono
					nHora		,;	//Hora Inicial do Abono
					aAbonos		,;	//Array onde serao carregados os Abonos
					cTpMarca	,;	//Tipo de Marcacao
					cCC			,;	//Centro de Custo
					aAbonosPer	 ;	//Array com Todos os Abonos do Periodo
				)

Local lPassTpMarca		:= !( cTpMarca == NIL )
Local lPassCC			:= !( cCC == NIL )
Local nHrsAbo			:= 0

Local aTamSx3
Local bEval
Local bFiltro
Local cFilSPK
Local cCond_01
Local cCond_02
Local cbCond
Local lAbonosPer
Local nLenAbo
Local nSvOrder
Local nOrder

DEFAULT cTpMarca		:= Space( GetSx3Cache( "PK_TPMARCA" , "X3_TAMANHO" ) )

IF ( Type( "lMemoria" ) <> "L" )
	Private lMemoria := .F.
EndIF

aAbonos	 := {}

IF !( lMemoria )

	lAbonosPer := ( ValType( aAbonosPer ) == "A" )

	IF !( lAbonosPer )

		aTamSx3		:= TamSx3( "PK_HORINI" )
		bEval		:= { |e1 , e2 | e1 == &(e2) }
		cFilSPK		:= SRA->RA_FILIAL
		nSvOrder	:= SPK->( IndexOrd() )
		nOrder		:= RetOrdem( "SPK" , "PK_FILIAL+PK_MAT+DTOS(PK_DATA)+PK_CODEVE+STR(PK_HORINI,"+AllTrim(Str(aTamSx3[1]))+","+AllTrim(Str(aTamSx3[2]))+")+PK_CC" )

		IF ( lPassTpMarca )
		   cbCond	:=	"SPK->PK_TPMARCA $ cTpMarca"
		EndIF
		IF ( lPassCC )
		   cbCond	:= IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "SPK->PK_CC==cCC"
		EndIF
		IF Empty( cbCond )
		   cbCond	:=	".T."
		EndIF
		bFiltro  := &( "{ ||" + cbCond + " }" )
		IF ( ( nHora == NIL ) .and. ( cPD # NIL ) )
			cCond_01	:= ( cFilSPK +  SRA->RA_MAT + Dtos( dData ) + cPD )
			cCond_02	:= "PK_FILIAL+PK_MAT+Dtos(PK_DATA)+PK_CODEVE"
		ElseIF ( nHora == NIL .and. cPD == NIL )
			cCond_01	:= ( cFilSPK + SRA->RA_MAT + Dtos( dData ) )
			cCond_02	:= "PK_FILIAL+PK_MAT+Dtos(PK_DATA)"
		Else
			cCond_01	:= ( cFilSPK + SRA->RA_MAT + Dtos(dData) + cPD + Str( nHora , aTamSx3[1] , aTamSx3[2] ) )
			cCond_02	:= "PK_FILIAL+PK_MAT+Dtos(PK_DATA)+PK_CODEVE+Str(PK_HORINI,"+AllTrim(Str(aTamSx3[1]))+","+AllTrim(Str(aTamSx3[2]))+")"
		EndIF

		IF !( nSvOrder == nOrder )
			SPK->( dbSetOrder( nOrder ) )
		EndIF

		IF SPK->( MsSeek( cCond_01 ) )
			While SPK->( !Eof() .and. Eval( bEval , cCond_01 , cCond_02 ) )
		        IF Eval( bFiltro )
					aAdd( aAbonos , Array( ELEMENTOS_AABONOS ) )
					nLenAbo := Len( aAbonos )
					aAbonos[ nLenAbo , AABONOS_CODIGO 		] := SPK->PK_CODABO
					aAbonos[ nLenAbo , AABONOS_HORAS_ABO	] := SPK->PK_HRSABO
					aAbonos[ nLenAbo , AABONOS_HORAS_INI	] := SPK->PK_HORINI
					aAbonos[ nLenAbo , AABONOS_HORAS_FIM	] := SPK->PK_HORFIM
					aAbonos[ nLenAbo , AABONOS_DATA			] := SPK->PK_DATA
					aAbonos[ nLenAbo , AABONOS_CC			] := SPK->PK_CC
					aAbonos[ nLenAbo , AABONOS_TPMARCA		] := SPK->PK_TPMARCA
					aAbonos[ nLenAbo , AABONOS_CODEVE		] := SPK->PK_CODEVE
					aAbonos[ nLenAbo , AABONOS_RECNO		] := SPK->( Recno() )
					aAbonos[ nLenAbo , AABONOS_FLAG			] := SPK->PK_FLAG
				   	nHrsAbo := SomaHoras( nHrsAbo , SPK->PK_HRSABO )
				EndIF
				SPK->( dbSkip() )
			End While
		EndIF
		
		IF !( nSvOrder == nOrder )
			SPK->( dbSetOrder( nSvOrder ) )
		EndIF

	Else

		nHrsAbo := GetAbonosPer( dData , cPD , nHora , @aAbonos , cTpMarca , cCC , aAbonosPer , lPassTpMarca , lPassCC )
			
	EndIF
	
Else

	nHrsAbo := fAbonosMem( dData , cPD , nHora , @aAbonos , cTpMarca , cCC , lPassTpMarca , lPassCC )

EndIF

Return( nHrsAbo )

/*/
зддддддддддбддддддддддддбддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFuncao	   ЁGetAbonosPerЁAutor ЁMarinaldo de Jesus    Ё Data Ё20/01/2003Ё
цддддддддддеддддддддддддаддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescricao ЁCarrega aAbonos a Partir do Conteudo de aAbonosPer			Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁfAbonos()													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function GetAbonosPer(	dData			,;	//Data do Abono
								cPD				,;	//Evento do Abono
								nHora			,;	//Hora Inicial do Abono
								aAbonos			,;	//Array onde serao carregados os Abonos
								cTpMarca		,;	//Tipo de Marcacao
								cCC				,;	//Centro de Custo
								aAbonosPer		,;	//Array com Todos os Abonos do Periodo
								lPassTpMarca	,;	//Se passou o Tipo da Marcacao em fAbonos
								lPassCC			 ;	//Se passou o Centro de Custo em fAbonos
							)
                
Local aTamSx3	:= TamSx3( "PK_HORINI" )
Local nHrsAbo	:= 0

Local bEval
Local bFiltro
Local bCond_01
Local bCond_02
Local cbCond
Local nLenAbo
Local nAbonosPer
Local nPosAbono

aAbonos	 := {}

IF ( lPassTpMarca )
   cbCond	:=	"aAbonosPer[ nPosAbono ," + AllTrim( Str( AABONOS_TPMARCA ) ) + "] $ cTpMarca"
EndIF
IF ( lPassCC )
   cbCond := IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "aAbonosPer[ nPosAbono ," + Str( AABONOS_CC ) + "] == cCC"
EndIF
IF Empty( cbCond )
   cbCond	:= ".T."
EndIF
bFiltro		:= &( "{ || " + cbCond + " } " )
IF ( ( nHora == NIL ) .and. ( cPD # NIL ) )
	bCond_01	:= { || Dtos( dData ) + cPD }
	bCond_02	:= { || Dtos( aAbonosPer[ nPosAbono , AABONOS_DATA ] ) + aAbonosPer[ nPosAbono , AABONOS_CODEVE ] }
ElseIF ( ( nHora == NIL ) .and. ( cPD == NIL ) )
	bCond_01	:= { || Dtos( dData ) }
	bCond_02	:= { || Dtos( aAbonosPer[ nPosAbono , AABONOS_DATA ] ) }
Else
	bCond_01	:= { || Dtos( dData ) + cPD + Str( nHora , aTamSx3[1] , aTamSx3[2] ) }
	bCond_02	:= { || Dtos( aAbonosPer[ nPosAbono , AABONOS_DATA ] ) + aAbonosPer[ nPosAbono , AABONOS_CODEVE ] + Str( aAbonosPer[ nPosAbono , AABONOS_HORAS_INI ] , aTamSx3[1] , aTamSx3[2] ) }
EndIF

nAbonosPer	:= Len( aAbonosPer )
IF ( ( nPosAbono := aScan( aAbonosPer , { |x| x[ AABONOS_DATA ] == dData } ) ) > 0 )
	bEval := { | b1 , b2 | Eval( b1 ) == Eval( b2 ) }
	For nPosAbono := nPosAbono To nAbonosPer
		IF ( !Eval( bEval , bCond_01 , bCond_02 ) .or. !Eval( bFiltro ) )
			Loop
		EndIF
		aAdd( aAbonos , Array( ELEMENTOS_AABONOS ) )
		nLenAbo := Len( aAbonos )
		aAbonos[ nLenAbo , AABONOS_CODIGO 		] := aAbonosPer[ nPosAbono , AABONOS_CODIGO 	]
		aAbonos[ nLenAbo , AABONOS_HORAS_ABO	] := aAbonosPer[ nPosAbono , AABONOS_HORAS_ABO	]
		aAbonos[ nLenAbo , AABONOS_HORAS_INI	] := aAbonosPer[ nPosAbono , AABONOS_HORAS_INI	]
		aAbonos[ nLenAbo , AABONOS_HORAS_FIM	] := aAbonosPer[ nPosAbono , AABONOS_HORAS_FIM	]
		aAbonos[ nLenAbo , AABONOS_DATA			] := aAbonosPer[ nPosAbono , AABONOS_DATA		]
		aAbonos[ nLenAbo , AABONOS_CC			] := aAbonosPer[ nPosAbono , AABONOS_CC			]
		aAbonos[ nLenAbo , AABONOS_TPMARCA		] := aAbonosPer[ nPosAbono , AABONOS_TPMARCA	]
		aAbonos[ nLenAbo , AABONOS_CODEVE		] := aAbonosPer[ nPosAbono , AABONOS_CODEVE		]
		aAbonos[ nLenAbo , AABONOS_RECNO		] := aAbonosPer[ nPosAbono , AABONOS_RECNO		]
		aAbonos[ nLenAbo , AABONOS_FLAG			] := aAbonosPer[ nPosAbono , AABONOS_FLAG		]
		nHrsAbo := SomaHoras( nHrsAbo , aAbonosPer[ nPosAbono , AABONOS_HORAS_ABO	] )
	Next nPosAbono
EndIF

Return( nHrsAbo )

/*/
зддддддддддбддддддддддбдддддбдддддддддддддддддддддддддбддддддбдддддддддд©
ЁFuncao	   ЁfAbonosMemЁAutorЁMauricio MR        Ver. IЁ Data Ё04/04/2001Ё
Ё          Ё          Ё     ЁMarinaldo de Jesus Ver.IIЁ Data Ё27/04/2004Ё
цддддддддддеддддддддддадддддадддддддддддддддддддддддддаддддддадддддддддд╢
ЁDescricao ЁVerifica a existencia de abonos (Trabalha com a Memoria)	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁfAbonos()													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function fAbonosMem(	dData			,;	//Data do Abono
							cPD				,;	//Evento do Abono
							nHora			,;	//Hora Inicial do Abono
							aAbonos			,;	//Array onde serao carregados os Abonos
							cTpMarca		,;	//Tipo de Marcacao
							cCC				,;	//Centro de Custo
							lPassTpMarca	,;	//Se passou o Tipo da Marcacao em fAbonos
							lPassCC			 ;	//Se passou o Centro de Custo em fAbonos
						   )								

Local nHrsAbo	:= 0

Local aAboCols
Local aTamSx3
Local bFiltro
Local cCond_01
Local cCond_02
Local cbCond
Local nLenAbo
Local nX
Local nLenX
Local nPkCodAbo
Local nPkHorIni
Local nPkHorFim
Local nPkHrsAbo
Local nPkCodEve
Local nPkTpMarca
Local nPkCc
Local nPkFlag

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Se Existir a Variavel bAboCols ( e for um bloco )   utilizadaЁ
Ё para a Montagem do aAboCols, Executa						   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( Type( "bAboCols" ) == "B" )

	aTamSx3		:= TamSx3( "PK_HORINI" )
	nPkData		:= GdFieldPos( "PK_DATA"    , aAboHeader )
	nPkCodAbo	:= GdFieldPos( "PK_CODABO" 	, aAboHeader )
	nPkHorIni	:= GdFieldPos( "PK_HORINI" 	, aAboHeader )
	nPkHorFim	:= GdFieldPos( "PK_HORFIM" 	, aAboHeader )
	nPkHrsAbo	:= GdFieldPos( "PK_HRSABO" 	, aAboHeader )
	nPkCodEve	:= GdFieldPos( "PK_CODEVE" 	, aAboHeader ) 
	nPkTpMarca	:= GdFieldPos( "PK_TPMARCA"	, aAboHeader )            
	nPkCc 		:= GdFieldPos( "PK_CC"		, aAboHeader ) 
	nPkFlag		:= GdFieldPos( "PK_FLAG"	, aAboHeader ) 

	aAboCols	:= Eval( bAboCols )

	IF ( lPassTpMarca )
	   cbCond := 'aAboCols[nX, nPkTpMarca]$cTpMarca'
	EndIF
	IF ( lPassCC )
	   cbCond := IF( !Empty(cbCond) , cbCond + ' .and. ','') + 'aAboCols[nX, nPkCc]==cCC'
	EndIF
	IF Empty(cbCond)
	   cbCond := '.T.'
	EndIF

	bFiltro  := &("{||"+cbCond+" }") 
	
	IF ( ( nHora == NIL ) .and. ( cPD # NIL ) )
		cCond_01	:= ( Dtos( dData ) + cPD )
		cCond_02	:= { |nElem| Dtos( aAboCols[ nElem , nPkData ] ) + aAboCols[ nElem , nPkCodEve ] }
	ElseIF ( ( nHora == NIL ) .and. ( cPD == NIL ) )
		cCond_01	:= ( Dtos( dData ) )
		cCond_02	:= { |nElem| Dtos( aAboCols[ nElem , nPkData ] ) }
	Else
		cCond_01	:= ( Dtos(dData) + cPD + Str( nHora , aTamSx3[1] , aTamSx3[2] ) )
		cCond_02	:= { |nElem| Dtos( aAboCols[ nElem, nPkData ] ) + aAboCols[ nElem , nPkCodEve ] + Str( aAboCols[ nElem , nPkHorIni ] , aTamSx3[1] , aTamSx3[2] ) }
	EndIF
	               
	nLenX := Len( aAboCols )
	For nX := 1 To nLenX
		IF ( cCond_01 == Eval( cCond_02 , nX ) )
			IF Eval( bFiltro )
				IF !Empty(aAboCols[nX, nPkCodAbo]) .AND. !aAboCols[ nX, Len( aAboCols[nX] ) ]
					aAdd( aAbonos , Array( ELEMENTOS_AABONOS ) )
					nLenAbo := Len( aAbonos )
					aAbonos[ nLenAbo , AABONOS_CODIGO 		] := aAboCols[ nX , nPkCodAbo 	]
					aAbonos[ nLenAbo , AABONOS_HORAS_ABO	] := aAboCols[ nX , nPkHrsAbo 	]
					aAbonos[ nLenAbo , AABONOS_HORAS_INI	] := aAboCols[ nX , nPkHorIni 	]
					aAbonos[ nLenAbo , AABONOS_HORAS_FIM	] := aAboCols[ nX , nPkHorFim 	]
					aAbonos[ nLenAbo , AABONOS_DATA			] := aAboCols[ nX , nPkData 	]
					aAbonos[ nLenAbo , AABONOS_CC			] := aAboCols[ nX , nPkCc	 	]
					aAbonos[ nLenAbo , AABONOS_TPMARCA		] := aAboCols[ nX , nPkTpMarca	]
					aAbonos[ nLenAbo , AABONOS_CODEVE		] := aAboCols[ nX , nPkCodEve	]
					aAbonos[ nLenAbo , AABONOS_RECNO		] := nX
					aAbonos[ nLenAbo , AABONOS_FLAG			] := aAboCols[ nX , nPkFlag		]
				EndIF
				IF !Empty( aAboCols[ nX , nPkCodAbo ] ) .and. !aAboCols[ nX, Len( aAboCols[nX] ) ]
					nHrsAbo := SomaHoras( nHrsAbo , aAboCols[ nX , nPkHrsAbo ] )
				EndIF
			EndIF
		EndIF
	Next nX

EndIF
	
Return( nHrsAbo )

/*/
зддддддддддбдддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFuncao	   ЁfAbonosPer Ё Autor ЁMarinaldo de Jesus    Ё Data Ё20/01/2003Ё
цддддддддддедддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescricao ЁCarrega no Array aAbonos    Todos os Abonos do Periodo		Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerico 												  	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fAbonosPer( aAbonos , dPerIni , dPerFim , cFil , cMat )

Local aTamSx3		:= TamSx3( "PK_HORINI" )
Local cAlias		:= "SPK"
Local cAliasQuery	:= cAlias
Local nOrder		:= RetOrdem( "SPK" , "PK_FILIAL+PK_MAT+DTOS(PK_DATA)+PK_CODEVE+STR(PK_HORINI,"+AllTrim(Str(aTamSx3[1]))+","+AllTrim(Str(aTamSx3[2]))+")+PK_CC" )
Local nOrdSPK		:= ( cAlias )->( IndexOrd() )

Local cFilMat
Local lExistAbo
Local nLenAbo

#IFDEF TOP

	Local aOldAlias			:= GetArea()
	Local cPrefixo			:= ( PrefixoCpo( cAlias ) + "_" )
	Local cIniData	 		:= ""
	Local cFimData			:= ""
	Local cQuery	 		:= ""
	Local lQueryOpened		:= .F.
	Local nX				:= 0

	Static aSpkFields
	Static cQrySpkFields
	Static nSpkFields

	IF !( lExInAs400 )
	
		DEFAULT aSpkFields := ( cAlias )->( dbStruct() )
		DEFAULT nSpkFields := Len( aSpkFields )

		IF ( cQrySpkFields == NIL )
			cQrySpkFields := ""	
			For nX := 1 To nSpkFields
				cQrySpkFields += aSpkFields[ nX , 01 ] + ", "
			Next nX
		EndIF
	
	EndIF		

#ENDIF

aAbonos := {}
DEFAULT dPerIni := Ctod("//")
DEFAULT dPerFim := Ctod("//")
DEFAULT cFil	:= SRA->RA_FILIAL
DEFAULT cMat	:= SRA->RA_MAT

IF !( nOrdSPK == nOrder )
	( cAliasQuery )->( dbSetOrder( nOrder ) )
EndIF

cFilMat := ( cFil + cMat )

#IFDEF TOP

	IF !( lExInAs400 )
		
		cIniData	:= Dtos( dPerIni )
		cFimData	:= Dtos( dPerFim )
		cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )
		cQuery := "SELECT "
		cQuery += cQrySpkFields
		cQuery += "R_E_C_N_O_ RECNO "
		cQuery += " FROM "
		cQuery += InitSqlName( cAlias )
		cQuery += " WHERE "
		cQuery += cPrefixo + "FILIAL='"+cFil+"'"
		cQuery += " AND "
		cQuery += cPrefixo + "MAT='"+cMat+"'"
		cQuery += " AND "
		cQuery += cPrefixo + "DATA>='"+cIniData+"'"
		cQuery += " AND "
		cQuery += cPrefixo + "DATA<='"+cFimData+"'"
		cQuery += " AND "
		cQuery += "D_E_L_E_T_=' ' "
		cQuery += "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )
		cQuery := ChangeQuery( cQuery )
		IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
			For nX := 1 To nSpkFields
				IF !( aSpkFields[ nX , 02 ] == "C" )
					TcSetField(cAliasQuery,aSpkFields[nX,01],aSpkFields[nX,02],aSpkFields[nX,03],aSpkFields[nX,04])
				EndIF
			Next nX
		Else
			cAliasQuery := cAlias
		EndIF	

	EndIF
				
#ENDIF

#IFNDEF TOP
	( cAliasQuery )->( MsSeek( cFilMat + Dtos( dPerIni ) , .T. ) )
#ELSE
	IF !( lQueryOpened )
		( cAliasQuery )->( MsSeek( cFilMat + Dtos( dPerIni ) , .T. ) )
	EndIF
#ENDIF

While ( cAliasQuery )->( !Eof() .and. ( ( PK_FILIAL + PK_MAT ) == cFilMat ) )
	#IFNDEF TOP
		IF ( cAliasQuery )->( ( PK_DATA < dPerIni ) .or. ( PK_DATA > dPerFim ) )
			( cAliasQuery )->( dbSkip() )
			Loop
		EndIF
	#ELSE
		IF !( lQueryOpened )
			IF ( cAliasQuery )->( ( PK_DATA < dPerIni ) .or. ( PK_DATA > dPerFim ) )
				( cAliasQuery )->( dbSkip() )
				Loop
			EndIF
	    EndIF
	#ENDIF
	aAdd( aAbonos , Array( ELEMENTOS_AABONOS ) )
	nLenAbo := Len( aAbonos )
	aAbonos[ nLenAbo , AABONOS_CODIGO 		] := ( cAliasQuery )->( PK_CODABO	)
	aAbonos[ nLenAbo , AABONOS_HORAS_ABO	] := ( cAliasQuery )->( PK_HRSABO	)
	aAbonos[ nLenAbo , AABONOS_HORAS_INI	] := ( cAliasQuery )->( PK_HORINI	)
	aAbonos[ nLenAbo , AABONOS_HORAS_FIM	] := ( cAliasQuery )->( PK_HORFIM	)
	aAbonos[ nLenAbo , AABONOS_DATA			] := ( cAliasQuery )->( PK_DATA		)
	aAbonos[ nLenAbo , AABONOS_CC			] := ( cAliasQuery )->( PK_CC		)
	aAbonos[ nLenAbo , AABONOS_TPMARCA		] := ( cAliasQuery )->( PK_TPMARCA	)
	aAbonos[ nLenAbo , AABONOS_CODEVE		] := ( cAliasQuery )->( PK_CODEVE	)
	#IFNDEF TOP	
		aAbonos[ nLenAbo , AABONOS_RECNO	] := ( cAliasQuery )->( Recno() )
	#ELSE
		IF !( lQueryOpened )
			aAbonos[ nLenAbo , AABONOS_RECNO	] := ( cAliasQuery )->( Recno() )
		Else
			aAbonos[ nLenAbo , AABONOS_RECNO	] := ( cAliasQuery )->( RECNO 	)
		EndIF
	#EndIF
	aAbonos[ nLenAbo , AABONOS_FLAG			] := ( cAliasQuery )->( PK_FLAG		)
	( cAliasQuery )->(  dbSkip() )
End While

#IFDEF TOP
	IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
    	( cAliasQuery )->( dbCloseArea() )
   		RestArea( aOldAlias )
   	EndIF
#ENDIF

lExistAbo := ( Len( aAbonos ) > 0 )

IF !( nOrdSPK == nOrder )
	SPK->( dbSetOrder( nOrdSPK ) )
EndIF

Return( lExistAbo )

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    Ё RetSeq   Ё Autor Ё Alexsandro Pereira    Ё Data Ё 25/08/00 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Retorna a sequencia inicial do turno de um periodo qualquerЁ╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё RetSeq(cSeqAtual,cTurno,dPerIni,dPerFim,dData,aTabPadrao)  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ cSeqAtual  - Sequencia do periodo atual                    Ё╠╠
╠╠Ё          Ё cTurno     - Turno de trabalho atual                       Ё╠╠
╠╠Ё          Ё dPerIni    - Data inicio do periodo a se calcular sequenciaЁ╠╠
╠╠Ё          Ё dPerFim    - Data fim do periodo a se calcular sequencia   Ё╠╠
╠╠Ё          Ё dData      - Data referente ao periodo para calculo sequencЁ╠╠
╠╠Ё          Ё aTabPadrao - Tabela de horario padrao                      Ё╠╠
╠╠Ё          Ё cSeqAnt    - Sequencia anterior calculada (retornado p/fun)Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё Gen┌rico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠*/
Function RetSeq(cSeqAtual,cTurno,dPerIni,dPerFim,dData,aTabPadrao,cSeqAnt,cFil)

//-- Calcula a sequencia inicial do periodo retroativo
//-- funcao chamada quando nao houver troca de turno.
Local dPerAntIni := Ctod('  /  /  ')	//-- Data inicial do periodo anterior
Local dPerAntFim := Ctod('  /  /  ')	//-- Data final do periodo anterior
Local dDataSeg   := Ctod('  /  /  ')	//-- Data da ultima segunda-feira
Local nSemanas   := 0					//-- Numero de semanas
Local nQtdSeq    := 0					//-- Quantidade de sequencias da tabela de horario padrao
Local nPosTab    := 0					//-- Posicao do turno na tabela de horario padrao
Local cFilSPF    := SRA->RA_FILIAL		//-- Codigo da filial do arquivo SPF

DEFAULT cFil := cFilAnt

//-- Quando a sequencia nao for informada, assume-se "01"
cSeqAtual := If(cSeqAtual==Nil .Or. Val(cSeqAtual)=0,'01',cSeqAtual)

//-- Obtem o total de sequencias da tabela
If (nPosTab := aScan(aTabPadrao, { |x| x[1] == fFilFunc('SPJ') .And. x[2] == cTurno })) > 0
	nQtdSeq := Val(aTabPadrao[nPosTab,3,Len(aTabPadrao[nPosTab,3]),19])
Endif

//-- Carrega o periodo de apontamento.
If !PerAponta(@dPerAntIni,@dPerAntFim,dData,NIL,cFil)
	Return .F.
Endif

//-- verifica as trocas de turno a partir do periodo escolhido ate a data atual
If SPF->(dbSeek(cFilSPF+SRA->RA_MAT+DTos(dPerIni),.T.))
	If SPF->PF_FILIAL+SPF->PF_MAT == cFilSPF+SRA->RA_MAT .And. SPF->PF_DATA <= dPerAntIni-1
		//-- Carrega o periodo de apontamento.
		cSeqAtual := SPF->PF_SEQUEDE
		cTurno    := SPF->PF_TURNODE
		//-- Carrega o periodo de apontamento.
		If !PerAponta(@dPerAntIni,@dPerAntFim,SPF->PF_DATA,NIL,cFil)
			Return .F.
		Endif
	Endif
Endif

//-- Se a data fim do antepenultimo periodo nao for na segunda-feira
If Dow(dPerAntIni-1) # 2
	//-- Obtem a data da segunda-feira do antepenultimo periodo.
	dDataSeg := (dPerAntIni-1) - (Dow(dPerAntIni-1) - 2)
	Else
	dDataSeg := dPerAntIni-1
Endif

//-- Calcula o numero de semanas decorridas desde a data inicial do periodo a obter a sequencia.
nSemanas  := If((nSemanas:=(dDataSeg-dPerIni)/7) > Int(nSemanas),Int(nSemanas := nSemanas + 1),nSemanas)
cSeqAnt   := Val(cSeqAtual)-nSemanas
cSeqAnt   := If(cSeqAnt<=1,nQtdSeq + cSeqAnt ,cSeqAnt)
cSeqAnt   := StrZero(ABS(cSeqAnt),2)

Return (cSeqAnt<>cSeqAtual)

/*/
зддддддддддбдддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    Ё fGeraExtraЁ Autor Ё Mauro Sergio          Ё Data Ё 07/11/96 Ё
цддддддддддедддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o Ё Gerar a Verba de Horas Extras                               Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >								   	 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >								   	 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGeracao de Horas Extras                                      Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fGeraExtra(	aTabExtra	,;//01 -> Array contendo os Tipos de Horas Extras
						cTpExtra	,;//02 -> Tipo de Hora Extra a ser Gerado
						nThoras		,;//03 -> Numero de Horas Extras Autorizadas	
						nTNhoras	,;//04 -> Numero de Horas Extras Nao Autorizadas	
						aResult		,;//05 -> Array com os Resultados do Apontamento do Dia
						aTotais		,;//06 -> Array com os Totais Apontados por Evento do Dia 
						dData		,;//07 -> Data da Gravacao
						cRotina		,;//08 -> Rotina Chamadora da Funcao
						cPeriodo	,;//09 -> Periodo de Apuracao 
						lSoma		,;//10 -> Soma ao Valor Existente
						cCusto		,;//11 -> Centro de Custo Para Gravacao
						cTpMarc		,;//12 -> Tipo de Marcacao
						lMvAcmHExt	,;//13 -> Considerar Todas as Horas Extras do Dia Para o Escalonamento
						lSubstitui	,;//14 -> Se Substitui as Horas Existentes
						cFuncao		,;//15 -> Funcao para gravacao
						cDepto		,;//16 -> Depto para gravacao
						cPosto		,;//17 -> Posto para gravacao  
						cProcesso 	,;//18 -> Processo para Gravacao								
						cRoteiro	,;//19 -> Roteiro para Gravacao
						cPeriodo	,;//20 -> Periodo para Gravacao								
						cNumPagto	,;//21 -> NumPagto para Gravacao	
						cTurno 		,;//19 -> Turno de Trabalho
						cSemana		,;//20 -> Semana/Sequencia do Turno
						aTotDia     ,;//21 -> Totais diarios     
						dDataApo	; //22 -> Data do Apontamento
				  	)

Local aExTipo

Local bEvalSomaA
Local bEvalSomaN

Local cEvento  
Local cTipoHE
Local nPercent
Local lRotFec

Local nResto
Local nHoras 
Local nHorasApo		:= nThoras  
Local nHorasAux		:= 0
Local nSaldoAnt		:= 0
Local nPos
Local nX
Local nFornX
Local nN 

DEFAULT nThoras		:= 0
DEFAULT nTNhoras	:= 0
DEFAULT aTotDia		:= {} 
DEFAULT dDataApo	:= dData
IF (;
		( nThoras > 0 );
		.or.;
		( nTNhoras > 0 );
	)

	aExTipo := {}
	nResto  := 0

	DEFAULT lSoma			:= .F.
	DEFAULT cCusto			:= Space( GetSx3Cache( "PC_CC" 		, "X3_TAMANHO" ) )
	DEFAULT cTpMarc 		:= Space( GetSx3Cache( "PC_TPMARCA"	, "X3_TAMANHO" ) )
	DEFAULT lMvAcmHExt		:= .F.  
	
	//-- Portaria 1.510
	DEFAULT __lCpoTurno		:= IF( ( SPC->(FIELDPOS( "PC_TURNO" 	)) != 0 )  ,.T. , .F. 	)   
	DEFAULT __lCpoSemana	:= IF( ( SPC->(FIELDPOS( "PC_SEMANA" 	)) != 0 )  ,.T. , .F. 	)   
	DEFAULT __lCpoTipoHE	:= IF( ( SPC->(FIELDPOS( "PC_TIPOHE" 	)) != 0 )  ,.T. , .F. 	)   
    
	IF __lCpoTurno .and. __lCpoSemana .and. __lCpoTipoHE .and. __lCpoPercent
		DEFAULT cTurno  	:= Space( GetSx3Cache( "PC_TURNO"		, "X3_TAMANHO" ) )
		DEFAULT cSemana		:= Space( GetSx3Cache( "PC_SEMANA"		, "X3_TAMANHO" ) )	
		DEFAULT cTipoHE		:= Space( GetSx3Cache( "PC_TIPOHE"		, "X3_TAMANHO" ) )	
		DEFAULT nPercent	:= 0
	Else                                                                                
		cTurno  			:= Space( GetSx3Cache( "PJ_TURNO"		, "X3_TAMANHO" ) )
		cSemana				:= Space( GetSx3Cache( "PJ_SEMANA"		, "X3_TAMANHO" ) )	
		cTipoHE				:= Space( GetSx3Cache( "P4_TIPO"		, "X3_TAMANHO" ) )		
		nPercent			:= 0
	Endif
	
	//-- 'APO' para Apontamento e 'FEC' para Fechamento
	cRotina  := IF( Empty( cRotina )  , "APO" , Upper( cRotina  ) )
	cPeriodo := IF( Empty( cPeriodo ) , "D"   , Upper( cPeriodo ) )

	lRotFec  := ( cRotina == "FEC" )

	Begin Sequence
	
		IF ( lMvAcmHExt )
			ToScheduleOverTime(	aTabExtra		,;	//01 - Array contendo os Tipos de Horas Extras
								cTpExtra		,;	//02 - Tipo de Hora Extra a ser Gerado
								nThoras			,;	//03 - Numero de Horas Extras Autorizadas
								nTNhoras		,;	//04 - Numero de Horas Extras Nao Autorizadas
								aResult			,;	//05 - Array com os Resultados do Apontamento do Dia
								aTotais			,;	//06 - Array com os Totais Apontados por Evento do Dia
								dData			,;	//07 - Data da Gravacao
								cRotina			,;	//08 - Rotina Chamadora da Funcao
								cPeriodo		,;	//09 - Periodo de Apuracao
								lSoma			,;	//10 - Soma ao Valor Existente
								cCusto			,;	//11 - Centro de Custo Para Gravacao
								cTpMarc			,;	//12 - Tipo de Marcacao
								lSubstitui		,;	//13 - Se Substitui as Horas Existentes 
							 	/*cFuncao	*/	,;  //14 - Funcao para Gravacao
								/*cDepto	*/	,;  //15 - Depto para Gravacao
								/*cPosto	*/	,;  //16 - Posto para Gravacao
								/*cProcesso	*/	,;  //17 - Processo para Gravacao																								
								/*cPeriodo	*/	,;  //18 - Periodo para Gravacao
								/*cRoteiro	*/	,;  //19 - Processo para Gravacao								
								/*cNumPagto	*/	,;  //20 - NumPagto para Gravacao
								cTurno 			,;  //21 - Turno de Trabalho
								cSemana			,;  //22 - Semana/Sequencia do Turno 
								aTotDia    		,;	//23 - Totais diarios     
								dDataApo		; 	//24 - Data do Apontamento								
							  )
			Break
	    EndIF
		
		//--Gerar Array do Tipo Desejado
		aExTipo := GetExTipo( aTabExtra , @cTpExtra )

		IF ( lSoma )
			IF !( lRotFec )
				bEvalSomaA	:= { |x| IF(;
											(;
												( x[ ARESULT_DATA ] == dData );
												.and.;
												( x[ ARESULT_EVENTO ] == aExTipo[ nX , 4 ] );
												.and.;
												( x[ ARESULT_CC ] == cCusto );
												.and.;
												( x[ ARESULT_TPMARCA ] == cTpMarc );
											),;
											(;
												nThoras := SomaHoras( nThoras , x[ ARESULT_HORAS ] ),;
												x[ ARESULT_HORAS ] := 0;
											),;
											NIL;
										);
								}
				bEvalSomaN	:= { |x| IF(;
											(;
												( x[ ARESULT_DATA ] == dData );
												.and.;
												( x[ ARESULT_EVENTO ] == aExTipo[ nX , 5 ] );
												.and.;
												( x[ ARESULT_CC ] == cCusto );
												.and.;
												( x[ ARESULT_TPMARCA ] == cTpMarc );
											),;
											(;
												nTNhoras := SomaHoras( nTNhoras , x[ ARESULT_HORAS ] ),;
												x[ ARESULT_HORAS ] := 0;
											),;
											NIL;
										);
								}
			Else
				bEvalSomaA	:= { |x| IF(;
											(;
												( x[ ATOTAIS_DATA ] == dData );
												.and.;
												( x[ ATOTAIS_EVENTO_PONTO ] == aExTipo[ nX , 4 ] );
												.and.;
												( x[ ATOTAIS_CENTO_DE_CUSTO ] == cCusto );
											),;
											(;
												nThoras := SomaHoras( nThoras , x[ ATOTAIS_HORAS ] ),;
												x[ ATOTAIS_HORAS ] := 0;
											),;
											NIL;
										);
								}
				bEvalSomaN	:= { |x| IF(;
											(;
												( x[ ATOTAIS_DATA ] == dData );
												.and.;
												( x[ ATOTAIS_EVENTO_PONTO ] == aExTipo[ nX , 5 ] );
												.and.;
												( x[ ATOTAIS_CENTO_DE_CUSTO ] == cCusto );
											),;
											(;
												nTNhoras := SomaHoras( nTNhoras , x[ ATOTAIS_HORAS ] ),;
												x[ ATOTAIS_HORAS ] := 0;
											),;
											NIL;
										);
								}  
				nSaldoAnt	:=SubHoras(nTHoras, nHorasApo)				
			EndIF
			//--Soma Horas Quando Existir mais de uma Geracao para o mesmo dia
			nFornX	:= Len( aExTipo )
			For nX := 1 To nFornX
				IF !Empty( nThoras )
					IF ( lRotFec )
						aEval( aTotais , bEvalSomaA )
					Else
						aEval( aResult , bEvalSomaA )
					EndIF	
				EndIF
				IF !Empty( nTNhoras )
					IF ( lRotFec )
						aEval( aTotais , bEvalSomaN )
					Else
						aEval( aResult , bEvalSomaN )
					EndIF	
				EndIF
			Next nX
		EndIF

		//-- 1o. para Autorizado e 2o. para Nao Autorizada
		For nN := 1 To 2
			nResto := IF( nN == 1 , nThoras , nTNhoras )
			//-- Aplicar a Tabela de Horas Extras		
			While ( nResto > 0 )
				//--Procura a faixa de horas
				IF ( ( nPos := aScan( aExTipo , { |x| nResto >= x[2] .And. nResto <= x[3] } ) ) > 0 )
					cEvento := aExTipo[ nPos , IF( nN == 1 , 4 , 5 ) ]
					cTipoHE	:= aExTipo[ nPos , 1 ]
					nPercent:= aExTipo[ nPos , 6 ]
					nHoras  := SubHoras( nResto , SubHoras( aExTipo[ nPos , 2 ] , 0.01 ) )
					IF lPort1510	.and. ( lRotFec )
						/*
						зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Calculo das horas extras diarias para agregar ao aTotais 	  Ё
						Ё independente do periodo de apuracao das mesmas.			  Ё						
						юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
						IF nHorasApo > nHoras
							nHorasApo:= SubHoras( nHorasApo , nHoras) 
							nHorasAux:= nHoras
						Else
						    nHorasAux:= nHorasApo
						    nHorasApo:= 0
						Endif
					Endif
									
					//--Gerar no Array de Resultado e Totais
					IF !( lRotFec )
						fGeraRes(	@aResult		,; //01 -> Array com os Resultados
									dData			,; //02 -> Data da Gravacao	
									nHoras			,; //03 -> Valor a Ser Gravado	
									cEvento			,; //04 -> Codigo onde Gravar
									cCusto			,; //05 -> Centro de Custo Onde Gravar
									cTpMarc			,; //06 -> Tipo da Marcacao
									lSoma			,; //07 -> Se soma a valor ja Existente
									cPeriodo		,; //08 -> Periodo para a Tolerancia
									0				,; //09 -> Tolerancia
									"H"				,; //10 -> Tipo de Arredondamento a Ser considerado
									lSubstitui		,; //11 -> Substitui a(s) Hora(s) Existente(s)
									/*cFuncao	*/	,; //12 -> Funcao  
				  					/*cDepto	*/	,; //13 -> Depto para gravacao
									/*cPosto	*/	,; //14 -> Posto para gravacao
									/*cProcesso	*/	,; //15 -> Periodo para Gravacao
									/*cRoteiro	*/	,; //16 -> Processo para Gravacao
									/*cPerApo	*/	,; //17 -> Periodo para Gravacao
									/*cNumPagto	*/ 	,; //18 -> NumPagto para Gravacao
									cTurno 			,; //19 -> Turno de Trabalho
									cSemana			,; //20 -> Semana/Sequencia do Turno
									cTipoHE			,; //21 -> Tipo de Hora Extra
									nPercent		;  //22 -> Percentual de Valorizacao							
								 )
					Else
						IF ( lSubstitui == NIL )
							lSubstitui := !( lSoma )
						EndIF
						fGeraTot(	@aTotais 		,;	//01 -> Array com os Totais do Ponto
									dData			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
									nHoras			,;	//03 -> Horas para Soma ou Geracao
									0   			,;	//04 -> Valor para Soma ou Geracao
									cEvento			,;	//05 -> Evento do Ponto para Pesquisa
									cCusto			,;	//06 -> Centro de Custo para Comparacao
									SRA->RA_FILIAL	,;	//07 -> Filial para Pesquisa no SP9									
									NIL				,;	//08 -> Verba da Folha
									lSubstitui	 	,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais   
									/*cFuncao	*/	,;  //10 -> Funcao  
				  					/*cDepto	*/	,;  //11 -> Depto para gravacao
									/*cPosto	*/	,;  //12 -> Posto para gravacao
									/*cProcesso	*/	,;  //13 -> Periodo para Gravacao
									/*cRoteiro	*/	,;  //14 -> Processo para Gravacao
									/*cPerApo	*/	,;  //15 -> Periodo para Gravacao
									/*cNumPagto	*/ 	,;  //16 -> NumPagto para Gravacao
									cTurno 			,;  //17 -> Turno de Trabalho
									cSemana			,;  //18 -> Semana/Sequencia do Turno
									cTipoHE			,;  //19 -> Tipo de Hora Extra
									nPercent		;   //20 -> Percentual de valorizacao									
								)
						IF lPort1510
							/*
							зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
							Ё Geracao das horas extras diarias para agregar ao aTotais 	  Ё
							Ё independente do periodo de apuracao das mesmas.			  Ё						
							юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
							IF nHorasAux > 0
								fGeraTot(	@aTotDia 		,;	//01 -> Array com os Totais do Ponto
											dDataApo		,;	//02 -> Data para Pesquisa e Gravacao no aTotais
											nHorasAux		,;	//03 -> Horas para Soma ou Geracao
											0   			,;	//04 -> Valor para Soma ou Geracao
											cEvento			,;	//05 -> Evento do Ponto para Pesquisa
											cCusto			,;	//06 -> Centro de Custo para Comparacao
											SRA->RA_FILIAL	,;	//07 -> Filial para Pesquisa no SP9									
											NIL				,;	//08 -> Verba da Folha
											lSubstitui	 	,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais   
											/*cFuncao	*/	,;  //10 -> Funcao  
						  					/*cDepto	*/	,;  //11 -> Depto para gravacao
											/*cPosto	*/	,;  //12 -> Posto para gravacao
											/*cProcesso	*/	,;  //13 -> Periodo para Gravacao
											/*cRoteiro	*/	,;  //14 -> Processo para Gravacao
											/*cPerApo	*/	,;  //15 -> Periodo para Gravacao
											/*cNumPagto	*/ 	,;  //16 -> NumPagto para Gravacao
											cTurno 			,;  //17 -> Turno de Trabalho
											cSemana			,;  //18 -> Semana/Sequencia do Turno
											cTipoHE			,;  //19 -> Tipo de Hora Extra
											nPercent		;   //20 -> Percentual de valorizacao									
										)  
							Endif			
						Endif
					EndIF
					nResto  := SubHoras( nResto , SubHoras( nResto , SubHoras( aExTipo[ nPos , 2 ] , 0.01 ) ) )
				Else
					Exit
				EndIF
			End While
		
		Next nN

	End Sequence
	
EndIF
	
Return( NIL )

/*/
зддддддддддбддддддддддддддддддбддддддбдддддддддддддддддддбддддбдддддддддд©
ЁFun┤┘o    ЁToScheduleOverTimeЁAutor ЁMarinaldo de Jesus ЁDataЁ11/07/2002Ё
цддддддддддеддддддддддддддддддаддддддадддддддддддддддддддаддддадддддддддд╢
ЁDescri┤┘o ЁGerar Horas Extras Escalonads                                Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >								   	 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGeracao de Horas Extras                                      Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function ToScheduleOverTime(	aTabExtra	,;	//01 -> Array contendo os Tipos de Horas Extras
								cTpExtra	,;	//02 -> Tipo de Hora Extra a ser Gerado
								nThoras		,;	//03 -> Numero de Horas Extras Autorizadas
								nTNhoras	,;	//04 -> Numero de Horas Extras Nao Autorizadas
								aResult		,;	//05 -> Array com os Resultados do Apontamento do Dia
								aTotais		,;	//06 -> Array com os Totais Apontados por Evento do Dia
								dData		,;	//07 -> Data da Gravacao
								cRotina		,;	//08 -> Rotina Chamadora da Funcao
								cPeriodo	,;	//09 -> Periodo de Apuracao
								lSoma		,;	//10 -> Soma ao Valor Existente
								cCusto		,;	//11 -> Centro de Custo Para Gravacao
								cTpMarc		,;	//12 -> Tipo de Marcacao
								lSubstitui	,;	//13 -> Se Substitui as Horas Existentes  
								cFuncao		,;	//14 -> Funcao para Gravacao
								cDepto		,;	//15 -> Depto para Gravacao
								cPosto		,;	//16 -> Posto para Gravacao
								cProcesso	,;	//17 -> Processo para Gravacao																								
								cPeriodo	,;	//18 -> Periodo para Gravacao
								cRoteiro	,;	//19 -> Processo para Gravacao								
								cNumPagto	,;	//20 -> NumPagto para Gravacao
								cTurno 		,;	//21 -> Turno de Trabalho
								cSemana		,; 	//22 -> Semana/Sequencia do Turno 
								aTotDia     ,;	//23 -> Totais diarios     
								dDataApo	; 	//24 -> Data do Apontamento								
							)

Local aExTipo		:= {}
Local lAutoriza		:= .F.
Local lRotFec		:= ( cRotina == "FEC" )

Local cEvento
Local cTipoHE 
Local nPercent
Local cHeKeyAtu
Local cTipoDia

Local nResto
Local nHoras 
Local nHorasAux		:= 0 
Local nPos
Local nPosPlus1
Local nPos1  
Local nPos2  
Local nN
Local nLenExt
Local nLenGer
Local nPosTpDia 
Local dDataDia			

DEFAULT nThoras			:= 0
DEFAULT nTNhoras		:= 0
DEFAULT __aHeLastGera__	:= {}
DEFAULT __cHeLastKey__	:= "__cHeLastKey__"   

//-- Portaria 1.510
DEFAULT __lCpoTurno		:= IF( ( SPC->(FIELDPOS( "PC_TURNO" 	)) != 0 )  ,.T. , .F. 	)   
DEFAULT __lCpoSemana	:= IF( ( SPC->(FIELDPOS( "PC_SEMANA" 	)) != 0 )  ,.T. , .F. 	)   
DEFAULT __lCpoTipoHE	:= IF( ( SPC->(FIELDPOS( "PC_TIPOHE" 	)) != 0 )  ,.T. , .F. 	)   
DEFAULT __lCpoPercent	:= IF( ( SPC->(FIELDPOS( "PC_PERCENT" 	)) != 0 )  ,.T. , .F. 	)   
    
IF __lCpoTurno .and. __lCpoSemana .and. __lCpoTipoHE .and. __lCpoPercent
	DEFAULT cTurno  	:= Space( GetSx3Cache( "PC_TURNO"		, "X3_TAMANHO" ) )
	DEFAULT cSemana		:= Space( GetSx3Cache( "PC_SEMANA"		, "X3_TAMANHO" ) )	
	DEFAULT cTipoHE		:= Space( GetSx3Cache( "PC_TIPOHE"		, "X3_TAMANHO" ) )	
	DEFAULT nPercent	:= 0
Else
	cTurno  			:= Space( GetSx3Cache( "PJ_TURNO"		, "X3_TAMANHO" ) )
	cSemana				:= Space( GetSx3Cache( "PJ_SEMANA"		, "X3_TAMANHO" ) )	
	cTipoHE				:= Space( GetSx3Cache( "P4_TIPO"		, "X3_TAMANHO" ) )		
	nPercent			:= 0
Endif

//--Gerar Array do Tipo Desejado
aExTipo 	:= GetExTipo( aTabExtra , @cTpExtra )
nLenExt 	:= Len( aExTipo )
cTipoDia	:= GetDiaToEx( cTpExtra )

cHeKeyAtu	:= ( cEmpAnt + cFilAnt + SRA->RA_MAT + Dtos( dData ) )
IF !( cHeKeyAtu == __cHeLastKey__ )
	__aHeLastGera__	:= {}
	__cHeLastKey__	:= cHeKeyAtu

	aAdd( __aHeLastGera__ , { cTipoDia , nThoras , nTNhoras , {}, {} } )
	nPosTpDia := Len( __aHeLastGera__ )
Else
	IF ( ( nPosTpDia := aScan( __aHeLastGera__ , { |x| x[1] == cTipoDia } ) ) == 0 )
		aAdd( __aHeLastGera__ , { cTipoDia , 0 , 0 , {}, {} } )
		nPosTpDia := Len( __aHeLastGera__ )
	EndIF
	__aHeLastGera__[ nPosTpDia , 02 ] := SomaHoras( __aHeLastGera__[ nPosTpDia , 02 ] , nThoras  )
	__aHeLastGera__[ nPosTpDia , 03 ] := SomaHoras( __aHeLastGera__[ nPosTpDia , 03 ] , nTNhoras )
EndIF


//-- 1o. para Autorizado e 2o. para Nao Autorizada
For nN := 1 To 2
	lAutoriza := ( nN == 1 )
	nResto := IF( ( lAutoriza ) , __aHeLastGera__[ nPosTpDia , 02 ] , __aHeLastGera__[ nPosTpDia , 03 ] )
	nPos := 0
	While ( nResto > 0 ) .and. ( ++nPos <= nLenExt )
		//-- Aplicar a Tabela de Horas Extras
		nPosPlus1	:= Min( nPos + 1 , nLenExt )
		nHoras  	:= Min( nResto , SubHoras( aExTipo[ Min( nPosPlus1 , nLenExt ) , 02 ] , aExTipo[ nPos , 02 ] ) )
		nHoras 		:= IF( nHoras == 0 , nResto , nHoras )
		nResto		:= SubHoras( nResto , nHoras )
		cEvento 	:= aExTipo[ nPos , IF( ( lAutoriza ) , 04 , 05 ) ]
		cTipoHE		:= aExTipo[ nPos , 1 ]
		nPercent	:= aExTipo[ nPos , 6 ]			
		nPos1 		:= 0
		nLenGer 	:= Len( __aHeLastGera__[ nPosTpDia , 04 ] ) 
		
		//-- Subtrai da quantidade de Horas remanescentes o total de horas ja enviadas para 
		//-- o aResult
		While ( ++nPos1 <= nLenGer )
			IF ( ;
					__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 01 ] == nPos;
					.and.;
					__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 04 ] == lAutoriza;
					.and.;
					(;
						__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 03 ] <> cEvento;
						.or.;
						__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 05 ] <> cTpMarc;
						.or.;
						__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 09 ] <> dDataApo;
						.or.;
						__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 06 ] <> cCusto;
					);
				)
				nHoras  := SubHoras( nHoras , __aHeLastGera__[ nPosTpDia , 04 , nPos1 , 02 ] )
			EndIF
		End While  

		//-- Substitui o total de horas da faixa para o evento pelo total de horas calculadas
		IF ( nPos1 := aScan( __aHeLastGera__[ nPosTpDia , 04 ]	, { |x|	x[1] == nPos;
																		.and.;
																		x[3] == cEvento;
																		.and.;
																		x[4] == lAutoriza;
																		.and.;
																		x[5] == cTpMarc;
																		.and.;
																		x[9] == dDataApo;
																		.and.;
																		x[6] == cCusto;
												  	   			  };
							);
			 ) > 0
		
			__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 02 ] := nHoras
			
			nHorasAux:=	nHoras  
		
			dDataDia :=	__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 09 ]
		
		Else
			aAdd( __aHeLastGera__[ nPosTpDia , 04 ] , { nPos , nHoras , cEvento , lAutoriza , cTpMarc , cCusto, cTipoHE, nPercent, dDataApo } )
		    nHorasAux	:= nHoras 
		    dDataDia	:= dDataApo
		EndIF
		
		//--Gerar no Array de Resultado e Totais
		IF !Empty( nHoras )
			IF !( lRotFec )
				DEFAULT lSubstitui		:= .T.
				fGeraRes(	@aResult			,; //01 -> Array com os Resultados
							dData				,; //02 -> Data da Gravacao	
							nHoras				,; //03 -> Valor a Ser Gravado	
							cEvento				,; //04 -> Codigo onde Gravar
							cCusto				,; //05 -> Centro de Custo Onde Gravar
							cTpMarc				,; //06 -> Tipo da Marcacao
							lSoma				,; //07 -> Se soma a valor ja Existente
							cPeriodo			,; //08 -> Periodo para a Tolerancia
							0   				,; //09 -> Tolerancia
							"H" 				,; //10 -> Tipo de Arredondamento a ser Considerado
							lSubstitui			,; //11 -> Substitui a(s) Hora(s) Existente(s)
							/*cFuncao	*/		,; //12 -> Funcao  
		  					/*cDepto	*/		,; //13 -> Depto para gravacao
							/*cPosto	*/		,; //14 -> Posto para gravacao
							/*cProcesso	*/		,; //15 -> Periodo para Gravacao
							/*cRoteiro	*/		,; //16 -> Processo para Gravacao
							/*cPerApo	*/		,; //17 -> Periodo para Gravacao
							/*cNumPagto	*/ 		,; //18 -> NumPagto para Gravacao
							cTurno 				,; //19 -> Turno de Trabalho
							cSemana				,; //20 -> Semana/Sequencia do Turno
							cTipoHE				,; //21 -> Tipo de Hora Extra
							nPercent			;  //22 -> Percentual de valorizacao
						 )
			Else
				IF ( lSubstitui == NIL )
					lSubstitui := !( lSoma )
				EndIF
				fGeraTot(	@aTotais 		,;	//01 -> Array com os Totais do Ponto
							dData			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
							nHoras			,;	//03 -> Horas para Soma ou Geracao
							0   			,;	//04 -> Valor para Soma ou Geracao
							cEvento			,;	//05 -> Evento do Ponto para Pesquisa
							cCusto			,;	//06 -> Centro de Custo para Comparacao
							SRA->RA_FILIAL	,;	//07 -> Filial para Pesquisa no SP9
							NIL				,;	//08 -> Verba da Folha
							lSubstitui	 	,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais   
							/*cFuncao	*/	,;  //10 -> Funcao  
		  					/*cDepto	*/	,;  //11 -> Depto para gravacao
							/*cPosto	*/	,;  //12 -> Posto para gravacao
							/*cProcesso	*/	,;  //13 -> Periodo para Gravacao
							/*cRoteiro	*/	,;  //14 -> Processo para Gravacao
							/*cPerApo	*/	,;  //15 -> Periodo para Gravacao
							/*cNumPagto	*/ 	,;  //16 -> NumPagto para Gravacao
							cTurno 			,;  //17 -> Turno de Trabalho
							cSemana			,;  //18 -> Semana/Sequencia do Turno
							cTipoHE			,;  //19 -> Tipo de Hora Extra
							nPercent		;   //20 -> Percentual de valorizacao							
						) 
						IF lPort1510 .and. ( lRotFec )
							/*
							зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
							Ё Geracao das horas extras diarias para agregar ao aTotais 	  Ё
							Ё independente do periodo de apuracao das mesmas.			  Ё						
							юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
						
								fGeraTot(	@aTotDia 		,;	//01 -> Array com os Totais do Ponto
											dDataDia		,;	//02 -> Data para Pesquisa e Gravacao no aTotais
											nHorasAux		,;	//03 -> Horas para Soma ou Geracao
											0   			,;	//04 -> Valor para Soma ou Geracao
											cEvento			,;	//05 -> Evento do Ponto para Pesquisa
											cCusto			,;	//06 -> Centro de Custo para Comparacao
											SRA->RA_FILIAL	,;	//07 -> Filial para Pesquisa no SP9									
											NIL				,;	//08 -> Verba da Folha
											lSubstitui	 	,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais   
											/*cFuncao	*/	,;  //10 -> Funcao  
						  					/*cDepto	*/	,;  //11 -> Depto para gravacao
											/*cPosto	*/	,;  //12 -> Posto para gravacao
											/*cProcesso	*/	,;  //13 -> Periodo para Gravacao
											/*cRoteiro	*/	,;  //14 -> Processo para Gravacao
											/*cPerApo	*/	,;  //15 -> Periodo para Gravacao
											/*cNumPagto	*/ 	,;  //16 -> NumPagto para Gravacao
											cTurno 			,;  //17 -> Turno de Trabalho
											cSemana			,;  //18 -> Semana/Sequencia do Turno
											cTipoHE			,;  //19 -> Tipo de Hora Extra
											nPercent		;   //20 -> Percentual de valorizacao									
										)  
								
						Endif						
			EndIF
		EndIF
	End While	
Next nN

Return( NIL )

/*/
зддддддддддбдддддддддддддддддддддбдддбддддддддддддддддддбддддбдддддддддд©
ЁFun┤┘o    ЁRstToScheduleOverTimeЁAutЁMarinaldo de JesusЁDataЁ11/03/2003Ё
цддддддддддедддддддддддддддддддддадддаддддддддддддддддддаддддадддддддддд╢
ЁDescri┤┘o ЁReinicializa as Staticas utilizadas em ToScheduleOverTime() Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RstToScheduleOverTime()

__aHeLastGera__ := NIL
__cHeLastKey__	:= "__cHeLastKey__"

Return( NIL )

/*/
зддддддддддбддддддддддддддддддбддддддбдддддддддддддддддддбддддбдддддддддд©
ЁFun┤┘o    ЁGetExTipo		  ЁAutor ЁMarinaldo de Jesus ЁDataЁ28/08/2002Ё
цддддддддддеддддддддддддддддддаддддддадддддддддддддддддддаддддадддддддддд╢
ЁDescri┤┘o ЁRetorna Array com o Tipo de Hora Extra a ser utilizado       Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >								   	 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGeracao de Horas Extras                                      Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetExTipo( aTabExtra , cTpExtra )

Local aExTipo	:= {}
Local bEval		:= { |x| IF( x[1] == cTpExtra , aAdd( aExTipo , x ) , NIL ) }

aEval( aTabExtra , bEval )

//-- Quando nao Encotrar o Tipo de Hora Extra Exato, Procura o Tipo Correspondente
//-- 5=1;6=2;7=3;8=4	//HE Noturnas/Normais	
//-- B=A;D=C;F=E;H=G	//HE Intervalos Noturnas/Normais
IF Empty( aExTipo )
	Do Case
		Case ( cTpExtra $ "H_G" )			//Tipos de Intervalo Feriado
			IF ( cTpExtra == "H" )			//Hora Extra Intervalo Noturna Feriado
				cTpExtra	:= "8"			//Hora Extra Feriado Noturna
				aEval( aTabExtra , bEval )
				IF Empty( aExTipo )
					cTpExtra	:= "G"    	//Hora Extra Intervalo Diurna Feriado
					aEval( aTabExtra , bEval )
				EndIF
				IF Empty( aExTipo )
					cTpExtra	:= "4"		//Hora Extra Feriado Diurna
					aEval( aTabExtra , bEval )
				EndIF
			ElseIF ( cTpExtra == "G" )		//Hora Extra Intervalo Diurna Feriado
				cTpExtra	:= "4"			//Hora Extra Feriado Diurna
				aEval( aTabExtra , bEval )
			EndIF
		Case ( cTpExtra $ "F_E" )			//Tipos de Intervalo Compensado
			IF ( cTpExtra == "F" )			//Hora Extra Intervalo Noturna Compensado
				cTpExtra	:= "7"			//Hora Extra Compensado Noturna
				aEval( aTabExtra , bEval )
				IF Empty( aExTipo )
					cTpExtra	:= "E"	    //Hora Extra Intervalo Diurna Compensado
					aEval( aTabExtra , bEval )
				EndIF
				IF Empty( aExTipo )
					cTpExtra	:= "3"		//Hora Extra Compensado Diurna
					aEval( aTabExtra , bEval )
				EndIF
			ElseIF ( cTpExtra == "E" )		//Hora Extra Intervalo Diurna Compensado
				cTpExtra := "3"				//Hora Extra Compensado Diurna
				aEval( aTabExtra , bEval )
			EndIF
		Case ( cTpExtra $ "D_C" )			//Tipos de Intervalo DSR
			IF ( cTpExtra == "D" )			//Hora Extra Intervalo Noturna DSR
				cTpExtra	:= "6"			//Hora Extra DSR Noturna
				aEval( aTabExtra , bEval )
				IF Empty( aExTipo )
					cTpExtra := "C"			//Hora Extra Intervalo Diurna DSR
					aEval( aTabExtra , bEval )
				EndIF
				IF Empty( aExTipo )
					cTpExtra := "2"			//Hora Extra DSR Diurna
					aEval( aTabExtra , bEval )
				EndIF
			ElseIF ( cTpExtra == "C" )		//Hora Extra Intervalo Diurna DSR
				cTpExtra := "2"				//Hora Extra DSR Diurna
				aEval( aTabExtra , bEval )
			EndIF
		Case ( cTpExtra $ "B_A" )			//Tipos de Intervalo Normal
			IF ( cTpExtra == "B" )			//Hora Extra Intervalo Noturna Normal
				cTpExtra	:= "5"			//Hora Extra Noturna Normal
				aEval( aTabExtra , bEval )
				IF Empty( aExTipo )
					cTpExtra	:= "A"		//Hora Extra Intervalo Normal
					aEval( aTabExtra , bEval )
				EndIF
				IF Empty( aExTipo )
					cTpExtra := "1"			//Hora Extra Normal
					aEval( aTabExtra , bEval )
				EndIF
			ElseIF ( cTpExtra == "A" )		//Hora Extra Intervalo Normal
				cTpExtra := "1"				//Hora Extra Normal
				aEval( aTabExtra , bEval )
			EndIF	
		OtherWise							//Tipos de Horas Extras
			cTpExtra := IF( Val( cTpExtra ) > 4 , StrZero( Val( cTpExtra ) - 4 , 1 ) , cTpExtra )
			aEval( aTabExtra , bEval )
	EndCase
EndIF

Return( aExTipo )

/*/
зддддддддддбддддддддддддддддддбддддддбдддддддддддддддддддбддддбдддддддддд©
ЁFun┤┘o    ЁGetTpExInt		  ЁAutor ЁMarinaldo de Jesus ЁDataЁ10/09/2003Ё
цддддддддддеддддддддддддддддддаддддддадддддддддддддддддддаддддадддддддддд╢
ЁDescri┤┘o ЁRetorna Tipo de Hora Extra de Intervalo Conforme Tipo do Dia Ё
Ё          Ёou Tipo de Hora Extra										 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >								   	 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                     Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetTpExInt( cTpDiaExt , lNoturna )

Local cTpExtInt		:= "A"

DEFAULT cTpDiaExt	:= "S"
DEFAULT lNoturna	:= .F.

Do Case
	Case ( cTpDiaExt $ "F_8_4" ) ; ( cTpExtInt := IF( lNoturna , "H" , "G" ) )	//Feriado
	Case ( cTpDiaExt $ "C_7_3" ) ; ( cTpExtInt := IF( lNoturna , "F" , "E" ) )	//Compensado
	Case ( cTpDiaExt $ "D_6_2" ) ; ( cTpExtInt := IF( lNoturna , "D" , "C" ) )	//DSR
	Case ( cTpDiaExt $ "S_5_1" ) ; ( cTpExtInt := IF( lNoturna , "B" , "A" ) )	//Normal
End Case

Return( cTpExtInt )

/*/
зддддддддддбддддддддддддддддддбддддддбдддддддддддддддддддбддддбдддддддддд©
ЁFun┤┘o    ЁGetDiaToEx		  ЁAutor ЁMarinaldo de Jesus ЁDataЁ22/09/2003Ё
цддддддддддеддддддддддддддддддаддддддадддддддддддддддддддаддддадддддддддд╢
ЁDescri┤┘o ЁRetorna Tipo do Dia de Acordo com o Tipo de Horas Extras     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >								   	 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                     Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetDiaToEx( cTpExtra )

Local cTipoDia	:= ""

DEFAULT cTpExtra := "S"

Do Case
	Case ( cTpExtra $ "F_8_4" ) ; ( cTipoDia := "F" )	//Feriado
	Case ( cTpExtra $ "C_7_3" ) ; ( cTipoDia := "C" )	//Compensado
	Case ( cTpExtra $ "D_6_2" ) ; ( cTipoDia := "D" )	//DSR
	Case ( cTpExtra $ "S_5_1" ) ; ( cTipoDia := "S" )	//Normal
End Case

Return( cTipoDia )

/*/
зддддддддддбдддддддддддддбддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁfGeraRes     ЁAutor ЁEquipe Advanced RH   Ё Data Ё01/04/1997Ё
цддддддддддедддддддддддддаддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁGerar no Array a Result os Resultados do Apontamento        Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >								  	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >								  	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fGeraRes(	aResult		,; //01 -> Array com os Resultados do Dia
					dDtGer		,; //02 -> Data da Geracao
					nHoras		,; //03 -> Numero de Horas Resultantes
					cEvento		,; //04 -> Codigo do Evento
					cCusto		,; //05 -> Centro de Custo a ser Gravado
					cTpMarc		,; //06 -> Tipo de Marcacao
					lSoma		,; //07 -> True para Acumular as Horas
					cPeriodo	,; //08 -> Periodo de Apuracao
					nTole		,; //09 -> Tolerancia
					cArred		,; //10 -> Tipo de Arredondamento a Ser Utilizado
					lSubstitui	,; //11 -> Substitui a(s) Hora(s) Existente(s)
					cFuncao		,; //12 -> Funcao  
  					cDepto		,; //13 -> Depto para gravacao
					cPosto		,; //14 -> Posto para gravacao
					cProcesso	,; //15 -> Periodo para Gravacao
					cRoteiro	,; //16 -> Processo para Gravacao
					cPerApo		,; //17 -> Periodo para Gravacao
					cNumPagto	,; //18 -> NumPagto para Gravacao
					cTurno 		,; //19 -> Turno de Trabalho
					cSemana		,; //20 -> Semana/Sequencia do Turno
					cTipoHE		,; //21 -> Tipo de Hora Extra
					nPercent	;  //22 -> Percentual de Valorizacao
				  )
Local bAsc
Local nRes

DEFAULT cEvento 	:= ""
DEFAULT nHoras		:= 0
DEFAULT cPeriodo	:= ""
DEFAULT nTole		:= 0

IF !Empty( cEvento ) .and. ( nHoras > 0 ) .and. IF( cPeriodo == "D" , IF( ( nTole > 0 ) , ( nHoras > nTole ) , .T. ) , .T. )
 
	DEFAULT aResult 	:= {}
	DEFAULT dDtGer  	:= dDataBase
	DEFAULT cCusto  	:= Space( GetSx3Cache( "PC_CC"		, "X3_TAMANHO" ) )
	DEFAULT cTpMarc		:= Space( GetSx3Cache( "PC_TPMARCA"	, "X3_TAMANHO" ) )
	DEFAULT lSoma   	:= .F.
	DEFAULT cArred		:= ""
	DEFAULT lSubstitui	:= .F. 
	
	//-- Portaria 1.510
	DEFAULT __lCpoTurno		:= IF( ( SPC->(FIELDPOS( "PC_TURNO" 	)) != 0 )  ,.T. , .F. 	)   
	DEFAULT __lCpoSemana	:= IF( ( SPC->(FIELDPOS( "PC_SEMANA" 	)) != 0 )  ,.T. , .F. 	)   
	DEFAULT __lCpoTipoHE	:= IF( ( SPC->(FIELDPOS( "PC_TIPOHE" 	)) != 0 )  ,.T. , .F. 	)   
	DEFAULT __lCpoPercent	:= IF( ( SPC->(FIELDPOS( "PC_PERCENT" 	)) != 0 )  ,.T. , .F. 	)   
	    
	IF __lCpoTurno .and. __lCpoSemana .and. __lCpoTipoHE .and. __lCpoPercent
		DEFAULT cTurno  	:= Space( GetSx3Cache( "PC_TURNO"		, "X3_TAMANHO" ) )
		DEFAULT cSemana		:= Space( GetSx3Cache( "PC_SEMANA"		, "X3_TAMANHO" ) )	
		DEFAULT cTipoHE		:= Space( GetSx3Cache( "PC_TIPOHE"		, "X3_TAMANHO" ) )	
		DEFAULT nPercent	:= 0
	Else
		cTurno  			:= Space( GetSx3Cache( "PJ_TURNO"		, "X3_TAMANHO" ) )
		cSemana				:= Space( GetSx3Cache( "PJ_SEMANA"		, "X3_TAMANHO" ) )	
		cTipoHE				:= Space( GetSx3Cache( "P4_TIPO"		, "X3_TAMANHO" ) )		
		nPercent			:= 0
	Endif

	bAsc	:= { |x| x[ARESULT_DATA] == dDtGer .and. x[ARESULT_EVENTO] == cEvento .and. x[ARESULT_CC] == cCusto .and. x[ARESULT_TPMARCA] == cTpMarc }
	nRes	:= 0

	lSoma := IF( lSoma .and. lSubstitui , !( lSubstitui ) , lSoma )
	IF ( ( lSoma .or. lSubstitui ) .and. ( nRes := aScan( aResult , bAsc  ) ) > 0 )
		IF ( lSoma )
			aResult[ nRes , ARESULT_HORAS ] := SomaHoras( aResult[ nRes , ARESULT_HORAS ] , nHoras )
		ElseIF ( lSubstitui )
			aResult[ nRes , ARESULT_HORAS ] := nHoras
		EndIF
	Else
		aAdd( aResult , Array( ELEMENTOS_ARESULT ) )
		nRes := Len( aResult )
		aResult[ nRes , ARESULT_DATA 		] := dDtGer			//01 - Data da Geracao
		aResult[ nRes , ARESULT_EVENTO		] := cEvento		//02 - Codigo do Evento
		aResult[ nRes , ARESULT_HORAS		] := nHoras			//03 - Horas
		aResult[ nRes , ARESULT_CC			] := cCusto			//04 - Centro de Custo
		aResult[ nRes , ARESULT_TPMARCA		] := cTpMarc		//05 - Tipo da Marcacao
		aResult[ nRes , ARESULT_ARRED		] := cArred			//06 - Tipo de Arredondamento a Ser Utilizado
		aResult[ nRes , ARESULT_DTOS_DATA	] := Dtos( dDtGer )	//07 - String de Data
		aResult[ nRes , ARESULT_NUM_ABO_HRS	] := 0				//08 - Qtde Horas Abonadas do Evento
		aResult[ nRes , ARESULT_RESULT_APO	] := {}				//09 - Array de Horarios Abonados para o Evento
		/*aResult[ nRes , ARESULT_FUNCAO	] := cFuncao	*/	//10 - Funcao
		/*aResult[ nRes , ARESULT_DEPTO	    ] := cDepto		*/	//15 - Depto 
		/*aResult[ nRes , ARESULT_POSTO	    ] := cPosto		*/	//16 - Posto 
		/*aResult[ nRes , ARESULT_PROCESSO  ] := cProcesso	*/	//11 - Processo
		/*aResult[ nRes , ARESULT_PERIODO	] := cPerApo 	*/	//12 - Periodo
		/*aResult[ nRes , ARESULT_ROTEIRO	] := cRoteiro	*/	//13 - Roteiro 	
		/*aResult[ nRes , ARESULT_NUM_PAGTO ] := cNumPagto	*/	//14 - NumPagto			
		
		  aResult[ nRes , ARESULT_TURNO    	] := cTurno			//15 - Turno de trabalho
  		  aResult[ nRes , ARESULT_SEMANA   	] := cSemana		//16 - Semana/Sequencia do turno
		  aResult[ nRes , ARESULT_TIPOHE   	] := cTipoHE		//17 - Tipo de Horas Extras
		  aResult[ nRes , ARESULT_PERCENT  	] := nPercent		//18 - Percentual de Valorizacao

	EndIF

EndIF

Return( NIL )

/*/
зддддддддддбдддддддддддддбддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁAjustaResult ЁAutor ЁMarinaldo de Jesus   Ё Data Ё18/07/2004Ё
цддддддддддедддддддддддддаддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁAjustar as Horas em aResult os Resultados do Apontamento    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >								  	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >								  	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function AjustaResult( aResult )

Local aResAux
Local nRes
Local nResults

/*
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Acertando as Horas                                          Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
IF ( ( nResults := Len( aResult ) ) > 0 )
	For nRes := 1 To nResults
		/*
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Nao Mexer no Calculo abaixo. Ele eh utilizado para   efetuarЁ
		Ё a correta conversao das horas que ateh este ponto estao  comЁ
		Ё mais de 2 casas decimais ( Necessario para que o calculo dasЁ
		Ё Horas de Adicional Noturno Fiquem Ok )                      Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
		aResult[ nRes , ARESULT_HORAS ] := __TimeSum( __TimeSum( aResult[ nRes , ARESULT_HORAS ] , 0 ) , 0 )
	Next nRes
	/*
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Remonta o aResult Eliminaldo Apontamentos Zerados           Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
	IF ( aScan( aResult , { |x| x[ ARESULT_HORAS ] == 0 } ) > 0 )
		aResAux := aClone( aResult )
		aResult	:= {}
		For nRes := 1 To nResults
			IF !Empty( aResAux[ nRes , ARESULT_HORAS ] )
				aAdd( aResult , aClone( aResAux[ nRes ] ) )
			EndIF
		Next nRes
	EndIF
EndIF	

Return( NIL )

/*/
зддддддддддбдддддддддддддбддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁfGeraTot     ЁAutor ЁMarinaldo de Jesus   Ё Data Ё24/09/2002Ё
цддддддддддедддддддддддддаддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁGerar no Array aTotais os Totais Apontado					Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >								  	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >								  	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fGeraTot(	aTotais 		,;	//01 -> Array com os Totais do Ponto
					dData			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
					nHoras			,;	//03 -> Horas para Soma ou Geracao
					nValor			,;	//04 -> Valor para Soma ou Geracao
					cEvento			,;	//05 -> Evento do Ponto para Pesquisa
					cCusto			,;	//06 -> Centro de Custo para Comparacao
					cFil			,;	//07 -> Filial para Pesquisa no SP9
					cVerba			,;	//08 -> Verba da Folha
					lSubstitui		,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais   
					cFuncao			,;  //10 -> Funcao  
  					cDepto			,;  //11 -> Depto para gravacao
					cPosto			,;  //12 -> Posto para gravacao
					cProcesso		,;  //13 -> Periodo para Gravacao
					cRoteiro		,;  //14 -> Processo para Gravacao
					cPerApo			,;  //15 -> Periodo para Gravacao
					cNumPagto		,;  //16 -> NumPagto para Gravacao
					cTurno 			,;  //17 -> Turno de Trabalho
					cSemana			,;  //18 -> Semana/Sequencia do Turno
					cTipoHE			,;  //19 -> Tipo de Hora Extra   
					nPercent		;  	//20 -> Percentual de Valorizacao					
				  )

Local bAsc		:= { || .F. }
Local nPos		:= 0

DEFAULT aTotais		:= {}
DEFAULT dData		:= Ctod("//")
DEFAULT nHoras		:= 0
DEFAULT nValor		:= 0
DEFAULT cEvento		:= Space( GetSx3Cache( "PB_PD"	, "X3_TAMANHO" ) )
DEFAULT cCusto		:= Space( GetSx3Cache( "PB_CC"	, "X3_TAMANHO" ) )
DEFAULT cFil		:= fFilFunc( "SP9" )
DEFAULT cVerba		:= PosSP9( cEvento , cFil , "P9_CODFOL" , 1 )
DEFAULT lSubstitui	:= .F.  
DEFAULT cTipoHE		:= "" 
DEFAULT nPercent	:= 0
 
bAsc := { |x|	(;
					( x[ATOTAIS_EVENTO_PONTO] 	== cEvento );
					.and.;
					( x[ATOTAIS_DATA]			== dData );
					.and.;
					( x[ATOTAIS_CENTO_DE_CUSTO]	== cCusto );
				);
		}

IF ( ( nPos := aScan( aTotais , bAsc ) ) > 0 )
	IF ( lSubstitui )
		aTotais[ nPos , ATOTAIS_HORAS ] := nHoras
		aTotais[ nPos , ATOTAIS_VALOR ] := nValor
	Else
	    aTotais[ nPos , ATOTAIS_HORAS ] := SomaHoras( aTotais[ nPos , ATOTAIS_HORAS] , nHoras )
		aTotais[ nPos , ATOTAIS_VALOR ] += nValor
	EndIF
Else
	aAdd( aTotais , Array( ELEMENTOS_DO_ATOTAIS ) )
	nPos := Len( aTotais )
	aTotais[ nPos , ATOTAIS_DATA			] := dData				//01 - Data do Evento
	aTotais[ nPos , ATOTAIS_EVENTO_PONTO	] := cEvento			//02 - Codigo do Evento
	aTotais[ nPos , ATOTAIS_HORAS			] := nHoras				//03 - Quantidade do Evento
	aTotais[ nPos , ATOTAIS_CODIGO_FOLHA	] := cVerba				//04 - Codigo para a Folha
	aTotais[ nPos , ATOTAIS_CENTO_DE_CUSTO	] := cCusto				//05 - Centro de Custo do Evento
	aTotais[ nPos , ATOTAIS_VALOR			] := nValor				//06 - Valor do Evento
	aTotais[ nPos , ATOTAIS_DTOS_DATA		] := Dtos( dData )		//07 - String de Data   
	aTotais[ nPos , ATOTAIS_TIPOHE			] := cTipoHE			//08 - Tipo de Hora Extra
	aTotais[ nPos , ATOTAIS_PERCENT			] := nPercent			//09 - Percentual de Valorizacao da HE
EndIF

Return( nPos )
              

/*/
зддддддддддбдддддддддддддбддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁfGerRFF      ЁAutor ЁMauricio MR		  Ё Data Ё04/12/2009Ё
цддддддддддедддддддддддддаддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁGerar no Array aRFF os Totais Apontados para o SREP      	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >								  	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >								  	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fGerRFF(	aTotais 		,;	//01 -> Array com os Totais do Ponto
					dData			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
					cEvento			,;	//03 -> Evento do Ponto para Pesquisa
					cEveOrig		,;	//04 -> Codigo do Evento de Origem da Informacao
					nHoras			,;	//05 -> Horas para Soma ou Geracao     
					nAbonadas		,;  //06 -> Quantidade horas Abonadas
					nBanco			,;  //07 -> Quantidade horas Banco de Horas
					cCusto			,;	//08 -> Centro de Custo para Comparacao
					cPerApo			,;  //09 -> Periodo para Gravacao
					cTipoHE			,;  //10 -> Tipo de Hora Extra   
					nPercent		,; 	//11 -> Percentual de Valorizacao		
					lSubstitui		,;	//12 -> Substitui a(s) Hora(s) Existente(s) em aTotais   				  
					cSinal			;	//13 -> Sinal da quantidade horas
				  )

Local bAsc		:= { || .F. }
Local nPos		:= 0

DEFAULT aTotais		:= {}
DEFAULT dData		:= Ctod("//")
DEFAULT cEvento		:= Space( GetSx3Cache( "RFF_PD"	, "X3_TAMANHO" ) )
DEFAULT cEveOrig	:= Space( GetSx3Cache( "RFF_PD"	, "X3_TAMANHO" ) )
DEFAULT nHoras		:= 0
DEFAULT nAbonadas   := 0
DEFAULT nBanco		:= 0
DEFAULT cCusto		:= Space( GetSx3Cache( "RFF_CC"	, "X3_TAMANHO" ) )
DEFAULT cPerApo		:= ""   
DEFAULT cTipoHE		:= "" 
DEFAULT nPercent	:= 0
DEFAULT lSubstitui	:= .F.  
DEFAULT cSinal		:= "1" 

bAsc := { |x|	(;
					( x[ARFF_EVENTO_PONTO] 	== cEvento );
					.and.;
					( x[ARFF_DATA]			== dData );
					.and.;
					( x[ARFF_CENTRO_DE_CUSTO]	== cCusto );
				);
		}

IF ( ( nPos := aScan( aTotais , bAsc ) ) > 0 )
	IF ( lSubstitui )
		aTotais[ nPos , ARFF_HORAS ] 			:= nHoras
		aTotais[ nPos , ARFF_HORAS_ABONADAS ] 	:= nAbonadas
		aTotais[ nPos , ARFF_HORAS_BANCO 	] 	:= nBanco		
	Else
	    aTotais[ nPos , ARFF_HORAS ] 			:= SomaHoras( aTotais[ nPos , ARFF_HORAS] 			, nHoras )
	    aTotais[ nPos , ARFF_HORAS_ABONADAS ] 	:= SomaHoras( aTotais[ nPos , ARFF_HORAS_ABONADAS] 	, nAbonadas )	    
  		aTotais[ nPos , ARFF_HORAS_BANCO ] 		:= SomaHoras( aTotais[ nPos , ARFF_HORAS_BANCO] 	, nBanco )	    
	EndIF
Else
	aAdd( aTotais , Array( ELEMENTOS_DO_ARFF ) )
	nPos := Len( aTotais )
	aTotais[ nPos , ARFF_DATA			] := dData				//01 - Data do Evento
	aTotais[ nPos , ARFF_EVENTO_PONTO	] := cEvento			//02 - Codigo do Evento
	aTotais[ nPos , ARFF_HORAS			] := nHoras				//03 - Quantidade do Evento
	aTotais[ nPos , ARFF_CENTRO_DE_CUSTO] := cCusto				//04 - Centro de Custo do Evento
	aTotais[ nPos , ARFF_DTOS_DATA		] := Dtos( dData )		//05 - String de Data   
	aTotais[ nPos , ARFF_EVENTO_ORIGEM	] := cEveOrig			//06 - Codigo do Evento de Origem da Informacao
	aTotais[ nPos , ARFF_HORAS_ABONADAS	] := nAbonadas			//07 - Quantidade horas Abonadas
	aTotais[ nPos , ARFF_HORAS_BANCO	] := nBanco				//08 - Quantidade horas para Banco de Horas
	aTotais[ nPos , ARFF_PERIODO_APO	] := cPerApo			//09 - Quantidade do Evento     
	aTotais[ nPos , ARFF_TIPOHE			] := cTipoHE			//10 - Tipo de Hora Extra
	aTotais[ nPos , ARFF_PERCENT		] := nPercent			//11 - Percentual de Valorizacao da HE     
	aTotais[ nPos , ARFF_HORAS_SINAL	] := cSinal				//12 - Sinal da quantidade. '1' - Positivo '2' - Negativo

EndIF

Return( nPos )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁfDiasFolgaЁ Autor ЁEquipe Advanced RH     Ё Data Ё11/02/1999Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁAltera aTabCalend de Forma a Transformar o Dia em DSR       Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁfDiasFolga(aMarcacoes,aTabCalend,dPerIni,dPerFim...)		Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fDiasFolga(	aMarcacoes		,;	//01 -> Array padrao contendo as marcacoes           
						aTabCalend		,;	//02 -> Array padrao contendo o calendario do func.  
						dPerIni			,;	//03 -> Inicio do Periodo de Apontamento             
						dPerFim			,;	//04 -> Final do Periodo de Apontamento              
						cCodDsrAutPa	,;	//05 -> Codigo do DSR Ult. Semana do Periodo Anterior
						lAcumulado		,;	//06 -> Se a Pesquisa deve ser Feita nos Acumulados  
						lGrava			 ;	//07 -> Nao Gravar o Evento
					)

Local aFaltas		:= {}
Local aDomingo		:= {}
Local cOrdem		:= ""
Local cGeraDSR		:= "N"
Local cUltOrd		:= ""
Local cUltOrdDom	:= ""
Local cAliasPesq	:= "SPC"
Local cFilSRA		:= NIL 
Local cFilSR6		:= xFilial( "SR6", SRA->RA_FILIAL ) 
Local cMatSRA		:= NIL 
Local cPrefixo		:= ""
Local cTipAfas		:= ""
Local cMsgErr		:= ""
Local dData			:= Ctod("//")
Local dUltDiaTab	:= dData
Local dIniAfas		:= dData
Local dFimAfas		:= dData
Local lCodDSRAutPa	:= .F.
Local lGerDSRAutPa	:= .F.
Local lRet			:= .F.
Local lLock			:= .F.
Local nDias			:= 0
Local nCount		:= 0
Local nX			:= 0
Local nPos			:= 0
Local nPos2			:= 0
Local nProxD		:= 0
Local nCt			:= 0	
Local nFornCt		:= 0
Local nLenTab		:= 0
Local nRecDSRAutPa	:= 0

DEFAULT aMarcacoes	:= {}
DEFAULT aTabCalend	:= {}
DEFAULT dPerIni		:= dDataBase
DEFAULT dPerFim		:= dDataBase
DEFAULT cCodDsrAutPa:= ""
DEFAULT lAcumulado	:= .F.
DEFAULT lGrava		:= .T.
DEFAULT cFilSRA		:= SRA->RA_FILIAL
DEFAULT cMatSRA		:= SRA->RA_MAT

IF lAcumulado
	cAliasPesq	:= "SPH"
EndIF

cAliasPesq		:= Upper( AllTrim( cAliasPesq ) )
cPrefixo		:= ( PrefixoCpo( cAliasPesq ) + "_" )
nLenTab			:= Len(aTabCalend)
nDias			:= ( ( dPerFim - dPerIni ) + 1 )
dData			:= dPerIni
lCodDSRAutPa	:= !( cCodDsrAutPa == "@" .or. Empty(cCodDsrAutPa) )
cUltOrd			:= aTabCalend[nLenTab,CALEND_POS_ORDEM]

IF ( nPos := aScan( aTabCalend , { |x| x[CALEND_POS_ORDEM] == cUltOrd .and. x[CALEND_POS_TIPO_MARC] == "1E" } ) ) > 0
	dUltDiaTab	:= aTabCalend[ nPos , CALEND_POS_DATA ]
EndIF

aEval( aTabCalend , {;
						 |x,y|;
						 		 IF( x[CALEND_POS_TIPO_MARC]=="1E" .and. Dow(x[CALEND_POS_DATA]) == 1 ,;
						 		 	 cUltOrdDom := aTabCalend[y,CALEND_POS_ORDEM] ,;
						 		 	 NIL;
						 		 	);
					 };
	  )

For nCount := 1 To nDias

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Guarda a Ordem da Tabela									  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	cOrdem := StrZero( nCount , __nTamP8Ordem )
	IF (nPos := aScan(aTabCalend, {|x| x[CALEND_POS_ORDEM] == cOrdem})) > 0
		dData := aTabCalend[nPos,CALEND_POS_DATA]
	Else
		dData++
		Loop
	EndIF

	IF Dow(dUltDiaTab) != 1
		IF lCodDSRAutPa
			IF ( cAliasPesq )->( MsSeek( cFilSRA + cMatSRA + cCodDsrAutPa + Dtos(dPerFim+1) ) )
				nRecDSRAutPa := SPC->( Recno() )
			EndIF
		EndIF
	EndIF

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Verifica as Trocas de Turno								  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( fBscTnoFolga(cFilSR6,aTabCalend[nPos,CALEND_POS_TURNO]) # "S" )

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Se a semana iniciou-se com um turno com DSR automatico,iden Ё
		Ё tifica-se a parte da semana com DSR automatico ate a data	  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF	 cGeraDSR == "S"   
		    //-- Calcula a segunda-feira que antecedeu a data atual
		    aAdd( aDomingo,{ dData , If( Dow(dData) == 1, (dData-6), dData -( Dow(dData) - 2 )  ) } )
		EndIF
		cGeraDSR := "N"
		dData++
		Loop
	EndIF

	cGeraDSR := "S"

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Obtem o Inicio e Fim de Cada Semana para Verifica se a FaltaЁ
	Ё Esta ou Nao Dentro da Mesma								  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( Dow(dData) == 1 )
		aAdd(aDomingo,{dData,dData-6})
	ElseIF ( dData == dPerFim )
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica qual o Proximo Domingo							  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		While ( Dow( dData ) != 1 )
			++dData
		End While
		aAdd(aDomingo,{dData,dData-6})
		dData := dPerFim
	EndIF

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Marca┤└o anterior a Admiss└o.                               Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF SRA->(;
				( RA_SITFOLH == Space( GetSx3Cache( "RA_SITFOLH" , "X3_TAMANHO" ) ) );
				.and.;
				( dData < RA_ADMISSA );
			)
		dData++
		Loop
	EndIF

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Marca┤└o posterior a Demiss└o ou Transferencia              Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF SRA->( RA_SITFOLH $ "DЗT" .and. !Empty(RA_DEMISSA) .and. dData > RA_DEMISSA )
		dData ++
		Loop
	EndIF

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Marca┤└o dentro de intervalo de Afastamento.                Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	cTipAfas	:=	aTabCalend[ nPos , CALEND_POS_TIP_AFAST ]
	dIniAfas	:=	aTabCalend[ nPos , CALEND_POS_INI_AFAST ]
	dFimAfas	:=	aTabCalend[ nPos , CALEND_POS_FIM_AFAST ]
	IF aTabCalend[ nPos , CALEND_POS_AFAST ] .and. ;
		( dData >= dIniAfas .And. dData <= IF( Empty( dFimAfas ) , dData , dFimAfas ) )
		IF ( ( SR6->R6_APODFER == "S" ) .And. ( cTipAfas == "F" ) )
			dData := dData
		Else
			dData ++
			Loop
		EndIF
	EndIF

	/*
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Verifica quais os dias sao faltas, caso este dia nao tenha  Ё
	| lancamento e o mesmo seja um feriado, ele nao e considerado |
	| uma falta.							 					  |
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды	
	*/
	If !aTabCalend[ nPos, CALEND_POS_FERIADO]
		IF ( nPos := aScan( aMarcacoes, { |x| x[3] == cOrdem } ) ) == 0 
			aAdd(aFaltas, dData )
		EndIF
	EndIf
	
Next nCount

nFornCt := Len(aDomingo)
For nCt := 1 To nFornCt

	dData := aDomingo[nCt,1]

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Verifica a Qual Semana a Falta Pertence                     Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( nPos := aScan( aFaltas, {|x| x <= aDomingo[nCt,1] .and. x >= aDomingo[nCt,2] } ) ) > 0
		dData := aFaltas[nPos]
	EndIF

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Se for a Primeira Semana Verifica se Ja Teve DSR na   UltimaЁ
	Ё Semana do Periodo de Apontamento Anterior e Nao Gera o   DSRЁ
	Ё Automatico para a Semana.									  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( ( nCt == 1 ) .and. ( lCodDSRAutPa ) )
		IF ( cAliasPesq )->( MsSeek( cFilSRA + cMatSRa + cCodDsrAutPa + Dtos(dPerIni) ) )
			Loop
		EndIF
	EndIF

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Se ja houver excecao para a data em questao nao altera o  HoЁ
	Ё rario														  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( nPos2 := aScan(aTabCalend, { |x| x[CALEND_POS_DATA] == dData .and. x[CALEND_POS_TIPO_MARC] == "1E" } ) ) > 0 .and.;
	   ( fBscTnoFolga(cFilSR6,aTabCalend[nPos2,CALEND_POS_TURNO]) == "S" )
		nX		:= nPos2
		lRet	:= .T.
		While ( ( nX <= nLenTab ) .and. aTabCalend[nPos2,CALEND_POS_ORDEM] == aTabCalend[nX,CALEND_POS_ORDEM] )
			IF aTabCalend[nX,CALEND_POS_EXCECAO] # "E"
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Atualiza a folga diretamente em aTabCalend				  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF ( ( nX - nPos2 ) < 2 )
					aTabCalend[ nX , CALEND_POS_HORA        ] := 0											//Hora
					aTabCalend[ nX , CALEND_POS_TIPO_DIA    ] := "D"										//Tipo do Dia
					aTabCalend[ nX , CALEND_POS_HRS_INTER   ] := 0											//Intervalo
					aTabCalend[ nX , CALEND_POS_MOT_EXECAO  ] := STR0101									//*/** DSR Automatico ***
					aTabCalend[ nX , CALEND_POS_TIPO_HE_NOR ] := SR6->(IF(Empty(R6_TPEXT),"2",R6_TPEXT))	//Tipo de Horas Extras Normais
					aTabCalend[ nX , CALEND_POS_TIPO_HE_NOT ] := SR6->(IF(Empty(R6_TPEXTN),"6",R6_TPEXTN))	//Tipo de Horas Extras Noturnas
				Else
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Elimina os Elementos que Nao serao Utilizados em aTabCalend Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					aDel(aTabCalend,nX)
					aSize(aTabCalend,--nLenTab)
					--nX
				EndIF	
			EndIF
			nX++
		End While
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Quando For a Ultima Semana e o Dia Nao For um Domingo e   TiЁ
		Ёver Sido Gerado um DSR Grava o Evento de DSR Automatico   MesЁ
		ЁAnterior Para o Proximo Mes								  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( ( Dow(dUltDiaTab) != 1 ) .and. !( lAcumulado ) .and. ( lGrava ) )
			IF ( ( lCodDSRAutPa ) .and. ( aTabCalend[ nPos2 , CALEND_POS_ORDEM ] >= cUltOrdDom ) .and. ( aTabCalend[ nPos2 , CALEND_POS_ORDEM ] <= cUltOrd ) )
				lGerDSRAutPa := .T.
				IF(  Dow( aTabCalend[ nPos2 , CALEND_POS_DATA ] ) == 1 )
					IF ( ( nProxD := aScan( aTabCalend , { |x| x[CALEND_POS_DATA] == ( aTabCalend[ nPos2 , CALEND_POS_DATA ] + 1 ) .and. x[CALEND_POS_TIPO_MARC] == "1E" } ) ) > 0 )
						/*/
						зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Nao Gera quando for o Domingo da Penultima Semana		      Ё
						юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						lGerDSRAutPa := !( Dow( aTabCalend[ nProxD , CALEND_POS_DATA ] ) == 2 ) 
					EndIF
				EndIF	
				IF ( lGerDSRAutPa )
					IF !Empty( nRecDSRAutPa )
						( cAliasPesq )->( dbGoto( nRecDSRAutPa ) )
						lLock := ( cAliasPesq )->( RecLock( cAliasPesq , .F. , .F. ) )
					Else
						lLock := RecLock( cAliasPesq , .T. , .F. )
					EndIF
					IF ( lLock )
						( cAliasPesq )->( &(cPrefixo+"FILIAL")	)	:= cFilSRA
						( cAliasPesq )->( &(cPrefixo+"MAT")		)	:= cMatSRA
						( cAliasPesq )->( &(cPrefixo+"DATA")	)	:= ( dPerFim + 1 )
						( cAliasPesq )->( &(cPrefixo+"PD")		)	:= cCodDsrAutPa
						( cAliasPesq )->( &(cPrefixo+"CC")		)	:= SRA->RA_CC
						( cAliasPesq )->( &(cPrefixo+"QUANTC")	)	:= 0.01
						( cAliasPesq )->( MsUnLock() )
					EndIF
				EndIF
			EndIF
		EndIF
	EndIF
Next

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁQuando nao Houver DSR Automatico a Ser Gerado e Ja Existir  oЁ
ЁEvento, Exclui.											  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( !( lAcumulado ) .and. ( lGrava ) )
	IF ( !( lGerDSRAutPa ) .and. !Empty( nRecDSRAutPa ) )
		( cAliasPesq )->( dbGoto( nRecDSRAutPa ) )
		IF ( cAliasPesq )->( RecLock( cAliasPesq , .F. , .F. ) )
			IF !( cAliasPesq )->( FkDelete( @cMsgErr ) )
				( cAliasPesq )->( RollBackDelTran( cMsgErr ) )
			EndIF
			( cAliasPesq )->( MsUnLock() )
		EndIF	
	EndIF
EndIF

Return( lRet )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁfBscTnoFolga ЁAutorЁ Equipe Advanced RH   Ё Data Ё10/02/1999Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o Ё Retorna (S/N) parametro do Turno - 1a.Falta da Semana=FolgaЁ
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁfBscTnoFolga( cFil , cTno )                                 Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       Ё fDiasFolga()	                                            Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function fBscTnoFolga( cFil , cTno )

Local aArea			:= GetArea()
Local aSr6Return	:= ""
Local cR6AsFolga	:= ""
Local nPosTr 		:= 0

IF ( nPosTr := aScan( aSr6Info , { |x| x[1] == cFil .and. x[2] == cTno } ) ) == 0
	#IFDEF TOP
			
		cCondSR6 := "% R6_FILIAL = '"+cFil+"' AND "
		cCondSR6 += "R6_TURNO  = '"+cTno+"' %"
						
		cQrySR6 := GetNextAlias()
		
		BeginSql alias cQrySR6
			SELECT R6_INIHNOT, R6_FIMHNOT, R6_MINHNOT, R6_APODFER, R6_TPEXFER, R6_TPEXFEN, R6_AUTOHEF, R6_ASFOLGA, R6_TNOOPC, R_E_C_N_O_ RECNO
			FROM %table:SR6% SR6
			WHERE
			%exp:cCondSR6% AND SR6.%NotDel%
		EndSql
		
		If (cQrySr6)->(!Eof())
			aAdd( aSr6Info, { cFilSPJ, cTno, (cQrySr6)->(R6_INIHNOT), (cQrySr6)->(R6_FIMHNOT), (cQrySr6)->(R6_MINHNOT), (cQrySr6)->(R6_APODFER), (cQrySr6)->(R6_TPEXFER), (cQrySr6)->(R6_TPEXFEN), (cQrySr6)->(R6_AUTOHEF), (cQrySr6)->RECNO, (cQrySr6)->(R6_ASFOLGA), (cQrySr6)->(R6_TNOOPC) } )
			SR6->( MsGoto( (cQrySR6)->RECNO ) )						
			cR6AsFolga	:= (cQrySr6)->(R6_ASFOLGA)
			(cQrySR6)->(dbCloseArea())			
		EndIf
		
	#ELSE

		aSr6Return:= PosSR6( cTno , cFil , aSr6Struct , 01 , .F. )
		aAdd( aSr6Info, { cFil, cTno, aSr6Return[1], aSr6Return[2], aSr6Return[3], aSr6Return[4], aSr6Return[5], aSr6Return[6], aSr6Return[7], SR6->( Recno() ), aSr6Return[8], aSr6Return[9] } )				
		cR6AsFolga	:= aSr6Return[8]

	#ENDIF

Else
	SR6->( MsGoto( aSr6Info[nPosTr, 10] ) )
	cR6AsFolga	:= aSr6Info[nPosTr, 11]
EndIf

RestArea(aArea)

Return( cR6AsFolga )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁPosSP9	  Ё Autor Ё Marinaldo de Jesus	  Ё Data Ё17/01/2003Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁSintaxe   Ё< vide parametros formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< vide parametros formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁcCompKey	= Chave Complementar para Pesquisa			  	Ё
Ё          ЁcFil    	= Filial do Evento que deseja 	 			  	Ё
Ё          ЁcCampo  	= Campo  do Evento que Deseja Pesquisar 		Ё
Ё          ЁnOrdem  	= Ordem  da Pesquisa                    		Ё
Ё          ЁlMsGoto 	= Se Deve Reposicionar Recno            		Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   Ё Generico 													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PosSP9( cCompKey , cFil , uCampo , nOrdem , lMsGoto )
DEFAULT lMsGoto := .T.
Return( PosAlias( "SP9" , cCompKey , cFil , uCampo , nOrdem , lMsGoto ) )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁPosSPA	  Ё Autor Ё Marinaldo de Jesus	  Ё Data Ё17/01/2003Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁPosiciona no Evento Desejado no SPA							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< vide parametros formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< vide parametros formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerico 													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PosSPA( cCompKey , cFil , uCampo , nOrdem , lMsGoto )
DEFAULT lMsGoto := .T.
Return( PosAlias( "SPA" , cCompKey , cFil , uCampo , nOrdem , lMsGoto ) )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁPosSR6	  Ё Autor Ё Marinaldo de Jesus	  Ё Data Ё17/01/2003Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁPosiciona no Turno Desejado no SR6							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< vide parametros formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< vide parametros formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerico 													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PosSR6( cCompKey , cFil , uCampo , nOrdem , lMsGoto )
DEFAULT lMsGoto := .T.
Return( PosAlias( "SR6" , cCompKey , cFil , uCampo , nOrdem , lMsGoto ) )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁPosSP6	  Ё Autor Ё Marinaldo de Jesus	  Ё Data Ё17/01/2003Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁPosiciona no Abono Desejado no SP6						    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< vide parametros formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< vide parametros formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerico 													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PosSP6( cCompKey , cFil , uCampo , nOrdem , lMsGoto )
DEFAULT lMsGoto := .T.
Return( PosAlias( "SP6" , cCompKey , cFil , uCampo , nOrdem , lMsGoto ) )

/*/
зддддддддддбддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁfQualSeq    Ё Autor ЁMarinaldo de Jesus    Ё Data Ё26/10/2000Ё
цддддддддддеддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRetorna o numero da Seq do Turno de Acordo com a Data InicialЁ
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁfQualSeq( aTabCalend , aTabPadrao , dPerIni , cTurno )		 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁaTabCalend -> Calendario do Periodo Atual          		     Ё
Ё          ЁaTabPadrao -> Calendario Padrao                    		     Ё
Ё          ЁdPerIni    -> Data do Periodo Inicial para achar a Seq.		 Ё
Ё          ЁcTurno     -> Turno Atual do Funcionario           		     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁcSeq - Sequencia Inicial da Tabela de Horario Padrao		 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                     Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fQualSeq( aTabCalend , aTabPadrao , dPerIni , cTurno, aTurnos )

Local aSeq		:= {}
Local cSeq		:= ""
Local cFil		:= xFilial( "SPJ" , SRA->RA_FILIAL )
Local dQualSeg  := dPerIni
Local dSegAtu   := Ctod('//')
Local dSvSegAt  := Ctod('//')
Local nLenTurno	:= 0
Local nPosTab	:= 0
Local nSegund   := 0
Local nSvPosT	:= 0
Local nX		:= 0
Local nFornX	:= 0

Default aTurnos := {}

cTurno 		:= IF( cTurno == NIL , SRA->RA_TNOTRAB , cTurno )
nLenTurno 	:= Len( aTurnos )

If nLenTurno > 0
	nPosTab := aScan( aTabCalend , { |x| x[CALEND_POS_TIPO_MARC] == "1E" .And. x[CALEND_POS_DATA] == aTurnos[nLenTurno, 2] } )
Else
	nPosTab := aScan( aTabCalend , { |x| x[CALEND_POS_TIPO_MARC] == "1E" } )
EndIf

IF ( nPosTab > 0 )
	dSegAtu := aTabCalend[ nPosTab , CALEND_POS_DATA 		]
	cSeq	:= aTabCalend[ nPosTab , CALEND_POS_SEQ_TURNO	]
	cTurno	:= aTabCalend[ nPosTab , CALEND_POS_TURNO		]
Else
	cSeq	:= SRA->RA_SEQTURN
	dSegAtu := dPerIni
EndIF

IF ( ( nPosTab := aScan( aTabPadrao , { |x| x[1] == cFil .and. x[ 2 ] == cTurno } ) ) > 0 )
	nFornX := Len( aTabPadrao[ nPosTab , 3 ] )
	For nX := 1 To nFornX
		IF ( aScan( aSeq , { |x| x[ 1 ] == aTabPadrao[ nPosTab , 3 , nX , 19 ] } ) == 0 )
			aAdd( aSeq , { aTabPadrao[ nPosTab , 3 , nX , 19 ] , '' } )
		EndIF
	Next nX
EndIF

IF ( Dow( dQualSeg ) != 2 )
	While ( Dow( --dQualSeg ) != 2 )
	End While
EndIF

IF ( Dow( dSegAtu ) != 2 )
	While ( Dow( --dSegAtu ) != 2 )
	End While
EndIF

IF ( !Empty( aSeq ) .and. ( Len( aSeq ) > 1 ) )
	IF ( ( nPosTab := aScan( aSeq, { |x| x[ 1 ] == cSeq } ) ) > 0 )
       	aSeq[ nPosTab , 2 ] := dSegAtu
		nSvPosT	 := nPosTab
        dSvSegAt := dSegAtu
		While ( ++nPosTab <= Len( aSeq ) )
			aSeq[ nPosTab , 2 ] := ( dSegAtu := ( dSegAtu + 7 ) )
		End While
		nPosTab := nSvPosT
        dSegAtu := dSvSegAt
		While ( --nPosTab >= 1 )
        	aSeq[ nPosTab , 2 ] := ( dSegAtu := ( dSegAtu - 7 ) )
		End While
		dSegAtu := dSvSegAt
		IF ( ( nTotSeq := Len( aSeq ) ) > 1 )
			nPosTab := nSvPosT
            IF ( dSegAtu > dQualSeg )
	            nSegund := ( dSegAtu - dQualSeg ) / 7
       			While ( --nSegund >= 0 )
					IF ( nPosTab == 1 )
						nPosTab := nTotSeq
					Else
						--nPosTab
					EndIF
				End While
			Else
                nSegund := ( dQualSeg - dSegAtu ) / 7
                While ( --nSegund >= 0 )
					IF ( nPosTab == nTotSeq )
						nPosTab := 1
					Else
						++nPosTab
					EndIF
				End While
			EndIF
            cSeq := aSeq[ nPosTab , 1 ]
        Else
			cSeq := aSeq[ 1 , 1 ]
		EndIF
	EndIF
EndIF

Return( cSeq )

/*/
зддддддддддбддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁfHrsTrabGat Ё Autor ЁMarinaldo de Jesus    Ё Data Ё24/10/2000Ё
цддддддддддеддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁCalcula Total de Horas da Tabela de Horario Padrao		     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁfHrsTrabGat()												 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁcTipo  -> "H"oras, "I"ntervalo, "T"otal de Horas			 Ё
Ё          ЁcAlias -> "SPJ" Tabela de Horario Padrao ou "SP2" Excecoes	 Ё
Ё          ЁcObj   -> "GD" GetDatos, "MB" mBrowse ou "DB" Arquivo		 Ё
Ё          ЁcInt   -> Quando cTipo = "I", qual Intervalo "1", "2" ou "3" Ё
Ё          Ё          Quando cTipo = "H", qual Periodo "1","2","3" ou "4"Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁnHoras									                     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGatilho                                                      Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fHrsTrabGat( cTipo , cAlias , cObj , cInt )

Local nHoras		:= 0
Local cVar			:= IF( cObj == "DB" , "" , Upper( AllTrim( ReadVar() ) ) )
Local cPrefixo		:= ""
Local dE1			:= dDataBase
Local dS1			:= Ctod('//')
Local dE2			:= Ctod('//')
Local dS2			:= Ctod('//')
Local dE3			:= Ctod('//')
Local dS3			:= Ctod('//')
Local dE4			:= Ctod('//')
Local dS4			:= Ctod('//')
Local lHnotTab		:= .F.
Local lHnotTbI		:= .F.
Local lNoExecGat	:= ( Type( "lHrsTrbGat" ) == "L" .and. !( lHrsTrbGat ) )
Local nE1			:= 0
Local nS1			:= 0
Local nE2			:= 0
Local nS2			:= 0
Local nE3			:= 0
Local nS3			:= 0
Local nE4			:= 0
Local nS4			:= 0
Local nI1			:= 0
Local nI2			:= 0
Local nI3			:= 0
Local nI1c			:= 0
Local nI2c			:= 0
Local nI3c			:= 0
Local nHr1			:= 0
Local nHr2			:= 0
Local nHr3			:= 0
Local nHr4			:= 0
Local nJn1			:= 0
Local nJn2			:= 0
Local nJn3			:= 0
Local nJn4			:= 0
Local nIniHnot		:= 0
Local nFimHnot		:= 23.59
Local nMinHnot		:= 60

cTipo		:= IF(cTipo == NIL .or. ValType(cTipo) != "C", "H"  ,IF(!(Upper(AllTrim(cTipo ))$"I_H_T"),"H",Upper(AllTrim(cTipo))))
cAlias		:= IF(cAlias == NIL .or. ValType(cTipo)!= "C", "SPJ" , Upper( AllTrim( cAlias ) ) )
cObj		:= IF(cObj == NIL .or. ValType(cTipo) != "C", "GD" ,IF(!(Upper(AllTrim(cObj ))$"GD_MB_DB"),"GD",Upper(AllTrim(cObj))))
cObj		:= IF(cAlias == "SP2" .and. Type("lGatForceGd") == "L" .and. cObj != "DB" , IF( lGatForceGd , "GD" , cObj ) , cObj )
cInt		:= IF(cInt == NIL .or. ValType(cInt) != "C", ""  ,IF(!(Upper(AllTrim(cInt ))$"1_2_3_4"),"",AllTrim(cInt)))
cPrefixo	:= ( PrefixoCpo( cAlias ) + "_" )

Begin Sequence

	IF ( lNoExecGat )
		Break
	EndIF

	IF ( cAlias == "SPJ" )
		lHnotTab	:= ( SR6->R6_HNOTTAB == "S" )
		lHnotTbI	:= ( SR6->R6_HNOTTBI == "S" )
		nIniHnot	:= SR6->R6_INIHNOT
		nFimHnot	:= SR6->R6_FIMHNOT
		nMinHnot	:= SR6->R6_MINHNOT
	ElseIF ( cAlias == "SP2" )
		IF ( cObj == "GD" )
			lHnotTab	:= ( GdFieldGet( cPrefixo+"HNOTTAB") == "S" )
			lHnotTbI	:= ( GdFieldGet( cPrefixo+"HNOTTBI") == "S" )
			nIniHnot	:= GdFieldGet( cPrefixo+"INIHNOT")
			nFimHnot	:= GdFieldGet( cPrefixo+"FIMHNOT")
			nMinHnot	:= GdFieldGet( cPrefixo+"MINHNOT")
		ElseIF ( cObj == "MB" )
			lHnotTab	:= ( GetMemVar( "P2_HNOTTAB" ) == "S" )
			lHnotTbI	:= ( GetMemVar( "P2_HNOTTBI" ) == "S" )
			nIniHnot	:= GetMemVar( "P2_INIHNOT" )
			nFimHnot	:= GetMemVar( "P2_FIMHNOT" )
			nMinHnot	:= GetMemVar( "P2_MINHNOT" )
		ElseIF	( cObj == "DB" )
			lHnotTab	:= (cAlias)->( &( cPrefixo+"HNOTTAB") == "S" )
			lHnotTbI	:= (cAlias)->( &( cPrefixo+"HNOTTBI") == "S" )
			nIniHnot	:= (cAlias)->( &( cPrefixo+"INIHNOT") )
			nFimHnot	:= (cAlias)->( &( cPrefixo+"FIMHNOT") )
			nMinHnot	:= (cAlias)->( &( cPrefixo+"MINHNOT") )
		EndIF
	EndIF
	
	IF ( cObj == "GD" )
		
		nE1		:= GdFieldPos( cPrefixo+"ENTRA1" )
		nS1		:= GdFieldPos( cPrefixo+"SAIDA1" )
		nE2		:= GdFieldPos( cPrefixo+"ENTRA2" )
		nS2		:= GdFieldPos( cPrefixo+"SAIDA2" )
		nE3		:= GdFieldPos( cPrefixo+"ENTRA3" )
		nS3		:= GdFieldPos( cPrefixo+"SAIDA3" )
		nE4		:= GdFieldPos( cPrefixo+"ENTRA4" )
		nS4		:= GdFieldPos( cPrefixo+"SAIDA4" )
		nI1		:= GdFieldPos( IF( cAlias == "SPJ" , "PJ_HRSINT1" , "P2_HRINTV1" )  )
		nI2		:= GdFieldPos( IF( cAlias == "SPJ" , "PJ_HRSINT2" , "P2_HRINTV2" )  )
		nI3		:= GdFieldPos( IF( cAlias == "SPJ" , "PJ_HRSINT3" , "P2_HRINTV3" )  )
		nI1c	:= GdFieldPos( cPrefixo+"INTERV1" )
		nI2c	:= GdFieldPos( cPrefixo+"INTERV2" )
		nI3c	:= GdFieldPos( cPrefixo+"INTERV3" )
		nHr1	:= GdFieldPos( cPrefixo+"HRSTRAB" )
		nHr2	:= GdFieldPos( cPrefixo+"HRSTRA2" )
		nHr3	:= GdFieldPos( cPrefixo+"HRSTRA3" )
		nHr4	:= GdFieldPos( cPrefixo+"HRSTRA4" )
		nJn1	:= GdFieldPos( cPrefixo+"JND1CON" )
		nJn2	:= GdFieldPos( cPrefixo+"JND2CON" )
		nJn3	:= GdFieldPos( cPrefixo+"JND3CON" )
		nJn4	:= GdFieldPos( cPrefixo+"JND4CON" )
	
		dS1		:= IF( aCols[ n , nS1 ] >= aCols[ n , nE1 ] , dE1 , dE1 + 1 )
		dS1		:= IF( aCols[ n , nS1 ] >= aCols[ n , nE1 ] .and. aCols[ n , nJn1 ] == "S", dS1 + 1 , dS1 )
		dE2		:= IF( aCols[ n , nE2 ] >= aCols[ n , nS1 ] , dS1 , dS1 + 1 )
		dS2		:= IF( aCols[ n , nS2 ] >= aCols[ n , nE2 ] , dE2 , dE2 + 1 )
		dS2		:= IF( aCols[ n , nS2 ] >= aCols[ n , nE2 ] .and. aCols[ n , nJn2 ] == "S", dS2 + 1 , dS2 )
		dE3		:= IF( aCols[ n , nE3 ] >= aCols[ n , nS2 ] , dS2 , dS2 + 1 )
		dS3		:= IF( aCols[ n , nS3 ] >= aCols[ n , nE3 ] , dE3 , dE3 + 1 )
		dS3		:= IF( aCols[ n , nS3 ] >= aCols[ n , nE3 ] .and. aCols[ n , nJn3 ] == "S", dS3 + 1 , dS3 )
		dE4		:= IF( aCols[ n , nE4 ] >= aCols[ n , nS3 ] , dS3 , dS3 + 1 )
		dS4		:= IF( aCols[ n , nS4 ] >= aCols[ n , nE4 ] , dE4 , dE4 + 1 )
		dS4		:= IF( aCols[ n , nS4 ] >= aCols[ n , nE4 ] .and. aCols[ n , nJn4 ] == "S", dS4 + 1 , dS4 )
	
	ElseIF ( cObj == "MB" )
		
		dS1 := IF( IF( cAlias == "SP2" , GetMemVar( "P2_SAIDA1" ) >= GetMemVar( "P2_ENTRA1" ) , GetMemVar( "PJ_SAIDA1" ) >= GetMemVar( "PJ_ENTRA1" ) ) , dE1 , dE1 + 1 )
		dS1 := IF( IF( cAlias == "SP2" , GetMemVar( "P2_SAIDA1" ) >= GetMemVar( "P2_ENTRA1" ) .and. GetMemVar( "P2_JND1CON" ) == "S" , GetMemVar( "PJ_SAIDA1" ) >= GetMemVar( "PJ_ENTRA1" ) .and. GetMemVar( "PJ_JND1CON" ) == "S" ) , dS1 + 1 , dS1 )
		dE2 := IF( IF( cAlias == "SP2" , GetMemVar( "P2_ENTRA2" ) >= GetMemVar( "P2_SAIDA1" ) , GetMemVar( "PJ_SAIDA1" ) >= GetMemVar( "PJ_ENTRA1" ) ) , dS1 , dS1 + 1 )
		dS2 := IF( IF( cAlias == "SP2" , GetMemVar( "P2_SAIDA2" ) >= GetMemVar( "P2_ENTRA2" ) , GetMemVar( "PJ_SAIDA1" ) >= GetMemVar( "PJ_ENTRA1" ) ) , dE2 , dE2 + 1 )
		dS2 := IF( IF( cAlias == "SP2" , GetMemVar( "P2_SAIDA2" ) >= GetMemVar( "P2_ENTRA2" ) .and. GetMemVar( "P2_JND2CON" ) == "S" , GetMemVar( "PJ_SAIDA1" ) >= GetMemVar( "PJ_ENTRA1" ) .and. GetMemVar( "PJ_JND2CON" ) == "S" ) , dS2 + 1 , dS2 )
		dE3 := IF( IF( cAlias == "SP2" , GetMemVar( "P2_ENTRA3" ) >= GetMemVar( "P2_SAIDA2" ) , GetMemVar( "PJ_SAIDA1" ) >= GetMemVar( "PJ_ENTRA1" ) ) , dS2 , dS2 + 1 )
		dS3 := IF( IF( cAlias == "SP2" , GetMemVar( "P2_SAIDA3" ) >= GetMemVar( "P2_ENTRA3" ) , GetMemVar( "PJ_SAIDA1" ) >= GetMemVar( "PJ_ENTRA1" ) ) , dE3 , dE3 + 1 )
		dS3 := IF( IF( cAlias == "SP2" , GetMemVar( "P2_SAIDA3" ) >= GetMemVar( "P2_ENTRA3" ) .and. GetMemVar( "P2_JND3CON" ) == "S" , GetMemVar( "PJ_SAIDA1" ) >= GetMemVar( "PJ_ENTRA1" ) .and. GetMemVar( "PJ_JND3CON" ) == "S" ) , dS3 + 1 , dS3 )
		dE4 := IF( IF( cAlias == "SP2" , GetMemVar( "P2_ENTRA4" ) >= GetMemVar( "P2_SAIDA3" ) , GetMemVar( "PJ_SAIDA1" ) >= GetMemVar( "PJ_ENTRA1" ) ) , dS3 , dS3 + 1 )
		dS4 := IF( IF( cAlias == "SP2" , GetMemVar( "P2_SAIDA4" ) >= GetMemVar( "P2_ENTRA4" ) , GetMemVar( "PJ_SAIDA1" ) >= GetMemVar( "PJ_ENTRA1" ) ) , dE4 , dE4 + 1 )
		dS4 := IF( IF( cAlias == "SP2" , GetMemVar( "P2_SAIDA4" ) >= GetMemVar( "P2_ENTRA4" ) .and. GetMemVar( "P2_JND4CON" ) == "S" , GetMemVar( "PJ_SAIDA1" ) >= GetMemVar( "PJ_ENTRA1" ) .and. GetMemVar( "PJ_JND4CON" ) == "S" ) , dS4 + 1 , dS4 )
	
	ElseIF ( cObj == "DB" )
	
		dS1 := (cAlias)->(IF( &(cPrefixo+"SAIDA1") >= &(cPrefixo+"ENTRA1") ,dE1 , dE1 + 1 ))
		dS1 := (cAlias)->(IF( &(cPrefixo+"SAIDA1") >= &(cPrefixo+"ENTRA1") .and. &(cPrefixo+"JND1CON") == "S" ,dS1 + 1 , dS1 ))
		dE2 := (cAlias)->(IF( &(cPrefixo+"ENTRA2") >= &(cPrefixo+"SAIDA1") ,dS1 , dS1 + 1 ))
		dS2 := (cAlias)->(IF( &(cPrefixo+"SAIDA2") >= &(cPrefixo+"ENTRA2") ,dE2 , dE2 + 1 ))
		dS2 := (cAlias)->(IF( &(cPrefixo+"SAIDA2") >= &(cPrefixo+"ENTRA2") .and. &(cPrefixo+"JND1CON") == "S" ,dS2 + 1 , dS2 ))
		dE3 := (cAlias)->(IF( &(cPrefixo+"ENTRA3") >= &(cPrefixo+"SAIDA2") ,dS2 , dS2 + 1 ))
		dS3 := (cAlias)->(IF( &(cPrefixo+"SAIDA3") >= &(cPrefixo+"ENTRA3") ,dE3 , dE3 + 1 ))
		dS3 := (cAlias)->(IF( &(cPrefixo+"SAIDA3") >= &(cPrefixo+"ENTRA3") .and. &(cPrefixo+"JND1CON") == "S" ,dS3 + 1 , dS3 ))
		dE4 := (cAlias)->(IF( &(cPrefixo+"ENTRA4") >= &(cPrefixo+"SAIDA3") ,dS3 , dS3 + 1 ))
		dS4 := (cAlias)->(IF( &(cPrefixo+"SAIDA4") >= &(cPrefixo+"ENTRA4") ,dE4 , dE4 + 1 ))
		dS4 := (cAlias)->(IF( &(cPrefixo+"SAIDA4") >= &(cPrefixo+"ENTRA4") .and. &(cPrefixo+"JND1CON") == "S" ,dS4 + 1 , dS4 ))
	
	EndIF	
	
	IF cTipo == "H"
		IF cObj == "GD"
			IF cInt == "1"
				nHoras := fCalHoras( dE1 , aCols[ n , nE1 ] , dS1 , aCols[ n , nS1 ] , NIL , NIL , lHnotTab , dE1 , NIL , nIniHnot , nFimHnot , nMinHnot )
			ElseIF cInt == "2"
				nHoras := fCalHoras( dE2 , aCols[ n , nE2 ] , dS2 , aCols[ n , nS2 ] , NIL , NIL , lHnotTab , dE2 , NIL , nIniHnot , nFimHnot , nMinHnot )
			ElseIF cInt == "3"
				nHoras := fCalHoras( dE3 , aCols[ n , nE3 ] , dS3 , aCols[ n , nS3 ] , NIL , NIL , lHnotTab , dE3 , NIL , nIniHnot , nFimHnot , nMinHnot )
			ElseIF cInt == "4"
				nHoras := fCalHoras( dE4 , aCols[ n , nE4 ] , dS4 , aCols[ n , nS4 ] , NIL , NIL , lHnotTab , dE4 , NIL , nIniHnot , nFimHnot , nMinHnot )
			EndIF	
		ElseIF cObj == "MB"
			IF cAlias == "SP2"
				IF cInt == "1"
					nHoras := fCalHoras( dE1 , GetMemVar( "P2_ENTRA1" ) , dS1 , GetMemVar( "P2_SAIDA1" ) , NIL , NIL , lHnotTab , dE1 ,NIL , nIniHnot , nFimHnot , nMinHnot )
				ElseIF cInt == "2"
					nHoras := fCalHoras( dE2 , GetMemVar( "P2_ENTRA2" ) , dS2 , GetMemVar( "P2_SAIDA2" ) , NIL , NIL , lHnotTab , dE2 ,NIL , nIniHnot , nFimHnot , nMinHnot )
				ElseIF cInt == "3"
					nHoras := fCalHoras( dE3 , GetMemVar( "P2_ENTRA3" ) , dS3 , GetMemVar( "P2_SAIDA3" ) , NIL , NIL , lHnotTab , dE3 ,NIL , nIniHnot , nFimHnot , nMinHnot )
				ElseIF cInt == "4"
					nHoras := fCalHoras( dE4 , GetMemVar( "P2_ENTRA4" ) , dS4 , GetMemVar( "P2_SAIDA4" ) , NIL , NIL , lHnotTab , dE4 ,NIL , nIniHnot , nFimHnot , nMinHnot )
				EndIF
			ElseIF cAlias == "SPJ"
				IF cInt == "1"
					nHoras := fCalHoras( dE1 , GetMemVar( "PJ_ENTRA1" ) , dS1 , GetMemVar( "PJ_SAIDA1" ) , NIL , NIL , lHnotTab , dE1 , NIL , nIniHnot , nFimHnot , nMinHnot )
				ElseIF cInt == "2"
					nHoras := fCalHoras( dE2 , GetMemVar( "PJ_ENTRA2" ) , dS2 , GetMemVar( "PJ_SAIDA2" ) , NIL , NIL , lHnotTab , dE2 , NIL , nIniHnot , nFimHnot , nMinHnot )
				ElseIF cInt == "3"
					nHoras := fCalHoras( dE3 , GetMemVar( "PJ_ENTRA3" ) , dS3 , GetMemVar( "PJ_SAIDA3" ) , NIL , NIL , lHnotTab , dE3 , NIL , nIniHnot , nFimHnot , nMinHnot )
				ElseIF cInt == "4"
					nHoras := fCalHoras( dE4 , GetMemVar( "PJ_ENTRA4" ) , dS4 , GetMemVar( "PJ_SAIDA4" ) , NIL , NIL , lHnotTab , dE4 , NIL , nIniHnot , nFimHnot , nMinHnot )
				EndIF
			EndIF
		ElseIF cObj == "DB"
			IF cInt == "1"
				nHoras := (cAlias)->(fCalHoras(dE1,&(cPrefixo+"ENTRA1"),dS1,&(cPrefixo+"SAIDA1"),NIL,NIL,lHnotTab,dE1,NIL,nIniHnot,nFimHnot,nMinHnot))
			ElseIF cInt == "2"
				nHoras := (cAlias)->(fCalHoras(dE2,&(cPrefixo+"ENTRA2"),dS2,&(cPrefixo+"SAIDA2"),NIL,NIL,lHnotTab,dE2,NIL,nIniHnot,nFimHnot,nMinHnot))
			ElseIF cInt == "3"
				nHoras := (cAlias)->(fCalHoras(dE3,&(cPrefixo+"ENTRA3"),dS3,&(cPrefixo+"SAIDA3"),NIL,NIL,lHnotTab,dE3,NIL,nIniHnot,nFimHnot,nMinHnot))
			ElseIF cInt == "4"
				nHoras := (cAlias)->(fCalHoras(dE4,&(cPrefixo+"ENTRA4"),dS4,&(cPrefixo+"SAIDA4"),NIL,NIL,lHnotTab,dE4,NIL,nIniHnot,nFimHnot,nMinHnot))
			EndIF
		EndIF
	ElseIF cTipo == "I"
		IF cInt == "1" .or. cVar $ ( cPrefixo+"INTERV1" )
			IF cObj == "GD"
				IF aCols[ n , nI1c ] == "S"
					nHoras := fCalHoras( dS1 , aCols[ n , nS1 ] , dE2 , aCols[ n , nE2 ] , NIL , NIL , lHnotTbI , dE1 , NIL , nIniHnot , nFimHnot , nMinHnot )
				EndIF
			ElseIF cObj == "MB"
				IF IF( cAlias == "SP2" , GetMemVar( "P2_INTERV1" ) , GetMemVar( "PJ_INTERV1" ) ) == "S"
					nHoras := fCalHoras(dS1,IF(cAlias=="SP2",GetMemVar( "P2_SAIDA1" ),GetMemVar( "PJ_SAIDA1" )),dE2,IF(cAlias=="SP2",GetMemVar( "P2_ENTRA2" ),GetMemVar( "PJ_ENTRA2" )),0,0,lHnotTbI,dE1,NIL,nIniHnot,nFimHnot,nMinHnot)
				EndIF
			ElseIF cObj == "DB"
				IF (cAlias)->( &(cPrefixo+"INTERV1") == "S" )
					nHoras := (cAlias)->(fCalHoras(dS1,&(cPrefixo+"SAIDA1"),dE2,&(cPrefixo+"ENTRA2"),NIL,NIL,lHnotTbI,dE1,NIL,nIniHnot,nFimHnot,nMinHnot))
				EndIF		
			EndIF
		ElseIF cInt == "2" .or. cVar $ ( cPrefixo+"INTERV2" )
			IF cObj == "GD"
				IF aCols[ n , nI2c ] == "S"
					nHoras := fCalHoras( dS2 , aCols[ n , nS2 ] , dE3 , aCols[ n , nE3 ] , 0 , 0 , lHnotTbI , dE2 , NIL , nIniHnot , nFimHnot , nMinHnot )
				EndIF
			ElseIF cObj == "MB"
				IF IF( cAlias == "SP2" , GetMemVar( "P2_INTERV2" ) , GetMemVar( "PJ_INTERV2" ) ) == "S"
					nHoras := fCalHoras(dS2,IF(cAlias=="SP2",GetMemVar( "P2_SAIDA2" ),GetMemVar( "PJ_SAIDA2" )),dE3,IF(cAlias=="SP2",GetMemVar( "P2_ENTRA3" ),GetMemVar( "PJ_ENTRA3" )),NIL,NIL,lHnotTbI,dE2,NIL,nIniHnot,nFimHnot,nMinHnot)
				EndIF
			ElseIF cObj == "DB"
				IF (cAlias)->( &(cPrefixo+"INTERV2") == "S" )
					nHoras := (cAlias)->(fCalHoras(dS2,&(cPrefixo+"SAIDA2"),dE3,&(cPrefixo+"ENTRA3"),NIL,NIL,lHnotTbI,dE2,NIL,nIniHnot,nFimHnot,nMinHnot))
				EndIF	
			EndIF
		ElseIF cInt == "3" .or. cVar $ ( cPrefixo+"INTERV3" )
			IF cObj == "GD"
				IF aCols[ n , nI3c ] == "S"
					nHoras := fCalHoras( dS3 , aCols[ n , nS3 ] , dE4 , aCols[ n , nE4 ] , NIL , NIL , lHnotTbI , dE3 , NIL , nIniHnot , nFimHnot , nMinHnot )
				EndIF	
			ElseIF cObj == "MB"
				IF IF( cAlias == "SP2" , GetMemVar( "P2_INTERV3" ) , GetMemVar( "PJ_INTERV3" ) ) == "S"
					nHoras := fCalHoras(dS3,IF(cAlias=="SP2",GetMemVar( "P2_SAIDA3" ),GetMemVar( "PJ_SAIDA3" )),dE4,IF(cAlias=="SP2",GetMemVar( "P2_ENTRA4" ),GetMemVar( "PJ_ENTRA4" )),NIL,NIL,lHnotTbI,dE3,NIL,nIniHnot,nFimHnot,nMinHnot)
				EndIF    
			ElseIF cObj == "DB"
				IF (cAlias)->( &(cPrefixo+"INTERV3") == "S" )
					nHoras := (cAlias)->(fCalHoras(dS3,&(cPrefixo+"SAIDA3"),dE4,&(cPrefixo+"ENTRA4"),NIL,NIL,lHnotTbI,dE3,NIL,nIniHnot,nFimHnot,nMinHnot))
				EndIF
			EndIF
		EndIF
	ElseIF cTipo == "T"
		IF cObj == "GD"
	 		nHoras := SomaHoras( nHoras , aCols[ n , nI1  ] )
			nHoras := SomaHoras( nHoras , aCols[ n , nI2  ] )
			nHoras := SomaHoras( nHoras , aCols[ n , nI3  ] )
			nHoras := SomaHoras( nHoras , aCols[ n , nHr1 ] )
			nHoras := SomaHoras( nHoras , aCols[ n , nHr2 ] )
			nHoras := SomaHoras( nHoras , aCols[ n , nHr3 ] )
			nHoras := SomaHoras( nHoras , aCols[ n , nHr4 ] )
		ElseIF cObj == "DB"
	 		nHoras := SomaHoras( nHoras , (cAlias)->(IF(cAlias=="SP2",P2_HRINTV1,PJ_HRSINT1) ) )
			nHoras := SomaHoras( nHoras , (cAlias)->(IF(cAlias=="SP2",P2_HRINTV2,PJ_HRSINT2) ) )
			nHoras := SomaHoras( nHoras , (cAlias)->(IF(cAlias=="SP2",P2_HRINTV3,PJ_HRSINT3) ) )
			nHoras := SomaHoras( nHoras , (cAlias)->( &(cPrefixo+"HRSTRAB") ) )
			nHoras := SomaHoras( nHoras , (cAlias)->( &(cPrefixo+"HRSTRA2") ) )
			nHoras := SomaHoras( nHoras , (cAlias)->( &(cPrefixo+"HRSTRA3") ) )
			nHoras := SomaHoras( nHoras , (cAlias)->( &(cPrefixo+"HRSTRA4") ) )
		ElseIF cObj == "MB"
	 		nHoras := SomaHoras( nHoras , IF( cAlias == "SP2",GetMemVar( "P2_HRINTV1" ),GetMemVar( "PJ_HRSINT1" ) ) )
			nHoras := SomaHoras( nHoras , IF( cAlias == "SP2",GetMemVar( "P2_HRINTV2" ),GetMemVar( "PJ_HRSINT2" ) ) )
			nHoras := SomaHoras( nHoras , IF( cAlias == "SP2",GetMemVar( "P2_HRINTV3" ),GetMemVar( "PJ_HRSINT3" ) ) )
			nHoras := SomaHoras( nHoras , IF( cAlias == "SP2",GetMemVar( "P2_HRSTRAB" ),GetMemVar( "PJ_HRSTRAB" ) ) )
			nHoras := SomaHoras( nHoras , IF( cAlias == "SP2",GetMemVar( "P2_HRSTRA2" ),GetMemVar( "PJ_HRSTRA2" ) ) )
			nHoras := SomaHoras( nHoras , IF( cAlias == "SP2",GetMemVar( "P2_HRSTRA3" ),GetMemVar( "PJ_HRSTRA3" ) ) )
			nHoras := SomaHoras( nHoras , IF( cAlias == "SP2",GetMemVar( "P2_HRSTRA4" ),GetMemVar( "PJ_HRSTRA4" ) ) )
		EndIF
	EndIF

End Sequence
	
Return(__TimeSum(__TimeSum( nHoras, 0 ), 0) )

/*/
зддддддддддбдддддддддддбддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    Ё__Excecoes ЁAutor Ё Equipe Advanced RH    Ё Data Ё19/04/2001Ё
цддддддддддедддддддддддаддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁCarrega a Tabela de Exce┤■es                	            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё__Excecoes(aArray,cTurno,cCC,cMat,dData,nRecno,aExcePer)	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁPar┐metrosЁ< Vide Parametros Formais >							        Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObs.:     ЁMatida a Funcao Apenas Para Compatibilidade com os ProgramasЁ
Ё          ЁEspecificos que ja Estao Sendo Utilizados nos Cliente.  RecoЁ
Ё          Ёmendado o uso da GetExcecoes()								Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁSIGAPON                                                     Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function __Excecoes(aArray,cTurno,cCC,cMat,dData,nRecno,aExcePer)

Local cFil 		:= SRA->RA_MAT
Local lExcecao	:= .F.

DEFAULT aArray		:= {}
DEFAULT cTurno		:= SRA->RA_TNOTRAB
DEFAULT cCC			:= SRA->RA_CC
DEFAULT cMat		:= SRA->RA_MAT
DEFAULT dData		:= dDataBase
DEFAULT nRecno		:= 0
DEFAULT aExceper	:= {}	

lExcecao := GetExcecoes(	@aArray		,; // 01 - Array a ser Carregado com as Exce┤oes
							cTno		,; // 02 - Turno de Trabalho do Funcion═rio
							cCC			,; // 03 - Centro de Custo do Funcion═rio
							cFil		,; // 04 - Filial do Funcionario
							cMat		,; // 05 - Matricula do Funcion═rio
							dData		,; // 06 - Data a ser pesquisada
							""			,; // 07 - Tipo do Dia Para a Excecao
							aExcePer	,; // 08 - Array com Todas as Exce┤oes do Periodo
							NIL			,; // 09 - Periodo Inicial Para Carga de aExcePer
							NIL			,; // 10 - Periodo Final   Para Carga de aExcePer
							.F.			,; // 11 - True para Carregar Todas as Excecoes do Periodo
							.F.			 ; // 12 - Mostrar Dialogo na IndRegua
						)

Return( lExcecao )

/*/
зддддддддддбдддддддддддбддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGetExcecoesЁAutor Ё Marinaldo de Jesus    Ё Data Ё19/04/2001Ё
цддддддддддедддддддддддаддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁCarrega a Tabela de Exce┤■es                	            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGetExcecoes()												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁPar┐metrosЁ< Vide Parametros Formais >							        Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObs.:     ЁQuando a procura For Feita em Arquivo (SP2) ira posicionar oЁ
Ё          ЁRecno Correspondente `a Excecao.                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁSIGAPON                                                     Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetExcecoes(	aArray		,; // 01 - Array a ser Carregado com as Exce┤oes
						cTno		,; // 02 - Turno de Trabalho do Funcion═rio
						cCC			,; // 03 - Centro de Custo do Funcion═rio
						cFil		,; // 04 - Filial do Funcionario
						cMat		,; // 05 - Matricula do Funcion═rio
						dData		,; // 06 - Data a ser pesquisada
						cTipoDia 	,; // 07 - Tipo do Dia Para a Excecao             					
						aExcePer	,; // 08 - Array com Todas as Exce┤oes do Periodo
						dPerIni		,; // 09 - Periodo Inicial Para Carga de aExcePer
						dPerFim		,; // 10 - Periodo Final   Para Carga de aExcePer 
						lPeriodo	,; // 11 - True para Carregar Todas as Excecoes do Periodo
						lShowDialog ,; // 12 - Mostrar Dialogo na IndRegua
						lForceGoto	 ; // 13 - Se, quando pesquisa em array, forca o posicionamento no SP2	
					 )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Variaveis de Inicializacao Obrigatoria					  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Local aExceTip		:= {}
Local cRegra		:= SRA->RA_REGRA
Local cSpcTipoDia	:= Space( GetSx3Cache( "P2_TIPODIA" , "X3_TAMANHO" ) ) 
Local lExcecao		:= .F.
Local lArray		:= .F.
Local nFornY		:= RetCondExce()

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Variaveis que serao inicializadas no Corpo da Funcao		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Local aString
Local baScan
Local bCond
Local bLoop
Local bExce
Local cArqInd
Local nFornX
Local nX
Local nY
Local nPos
Local nRecno

Static	cIndKeyExc
Static	nOrderExce

DEFAULT aArray		:= {}
DEFAULT cTno		:= SRA->RA_TNOTRAB
DEFAULT cCC			:= SRA->RA_CC
DEFAULT cFil		:= SRA->RA_FILIAL
DEFAULT cMat		:= SRA->RA_MAT
DEFAULT dData		:= dDataBase       
DEFAULT cTipoDia	:= cSpcTipoDia
DEFAULT aExcePer	:= {}
DEFAULT dPerIni		:= dDataBase
DEFAULT dPerFim		:= dDataBase
DEFAULT lPeriodo	:= .F.
DEFAULT lShowDialog := .F.
DEFAULT lForceGoto	:= .F.

Begin Sequence
	
	IF ( ( ValType( aExcePer ) == "A" ) .and. ( lArray := ( Len(aExcePer) > 0 ) ) )  //Pesquizando em Array

		baScan := { |x| x[2] + Dtos( x[3] ) + Dtos( x[4] ) == aExcePer[ nX , 35 ] + Dtos( aExceper[ nX , 02 ] ) + Dtos( aExceper[ nX , 03 ] ) }
		
		bCond := { |x| ( x[1] + x[6] + x[5] + x[4] + Dtos( x[2] ) ) == aString[1]  .or. ;
					   ( x[1] + x[6] + x[5] + x[4]                ) == aString[2]     	;
				 }

		bExce := { |e| dData >= aExcePer[e,2] .and. dData <= IF(!Empty(aExcePer[e,3]),aExcePer[e,3],aExcePer[e,2]) }

	   	bLoop := { |e,f| IF( f == "L" , aExcePer[e,1] + aExcePer[e,6] + aExcePer[e,5] + aExcePer[e,4] != aString[2] ,;
						   			    aExcePer[e,1] + aExcePer[e,6] + aExcePer[e,5] + aExcePer[e,4] == aString[2]  ;
							)																						 ;
	   			 }
		
		For nY := 1 To nFornY
			
			aString  := RetCondExce( cFil , cMat , cTno , cCC , dData , nY )
			
			IF ( ( nPos := aScan( aExcePer, bCond ) ) > 0 )
				nFornX  := ( nFornX := Len( aExcePer ) )
				For nX := nPos To nFornX
					IF ( nX > nFornX )
						Exit
					EndIF	
					IF Eval( bLoop , nX , "L" ) 
						IF Eval( bLoop , nFornX , "F" ) .and. Eval( bExce , nFornX )
							lExcecao := .T.
							IF ( Empty( aExceTip ) .or. ( aScan( aExceTip , baScan ) == 0 ) )
								aAdd( aExceTip , {   			   			 ;
													nFornX		   			,;	//01 -> Indice da Excecao em aExcePer
													aExcePer[ nFornX , 35 ]	,;	//02 -> Tipo do Dia Para Excecao
													aExceper[ nFornX , 02 ]	,;	//03 -> Data Inicial da Excecao
													aExceper[ nFornX , 03 ] ,;	//04 -> Data Final da Excecao
													aExceper[ nFornX , 01 ] ,;	//05 -> Filial
													aExceper[ nFornX , 06 ] ,;	//06 -> Matricula do Funcionario
													aExceper[ nFornX , 05 ] ,;	//07 -> Centro de Custo
													aExceper[ nFornX , 04 ]	,;	//08 -> Turno 
													aExcePer[ nFornX , 27 ]  ;	//09 -> Recno
												  };
									 )
								--nFornX	 
							EndIF
						Else
							--nFornX
						EndIF
						Loop
					EndIF
					IF Eval( bExce , nX )
						lExcecao := .T.
						IF ( Empty( aExceTip ) .or. ( aScan( aExceTip , baScan ) == 0 ) )
							aAdd( aExceTip , {   					 ;
												nX					,;	//01 -> Indice da Excecao em aExcePer
												aExcePer[ nX , 35 ]	,;	//02 -> Tipo do Dia Para Excecao
												aExceper[ nX , 02 ]	,;	//03 -> Data Inicial da Excecao
												aExceper[ nX , 03 ] ,;	//04 -> Data Final da Excecao
												aExceper[ nX , 01 ] ,;	//05 -> Filial
												aExceper[ nX , 06 ] ,;	//06 -> Matricula do Funcionario
												aExceper[ nX , 05 ] ,;	//07 -> Centro de Custo
												aExceper[ nX , 04 ]	,;	//08 -> Turno 
												aExcePer[ nX , 27 ]  ;	//09 -> Recno
											   };
								 )
						EndIF
					EndIF
					IF Eval( bLoop , nFornX , "F" )  .and. Eval( bExce , nFornX )
						lExcecao := .T.
						IF ( Empty( aExceTip ) .or. ( aScan( aExceTip , baScan ) == 0 ) )
							aAdd( aExceTip , {   			   			 ;
												nFornX		   			,;	//01 -> Indice da Excecao em aExcePer
												aExcePer[ nFornX , 35 ]	,;	//02 -> Tipo do Dia Para Excecao
												aExceper[ nFornX , 02 ]	,;	//03 -> Data Inicial da Excecao
												aExceper[ nFornX , 03 ] ,;	//04 -> Data Final da Excecao
												aExceper[ nFornX , 01 ] ,;	//05 -> Filial
												aExceper[ nFornX , 06 ] ,;	//06 -> Matricula do Funcionario
												aExceper[ nFornX , 05 ] ,;	//07 -> Centro de Custo
												aExceper[ nFornX , 04 ]	,;	//08 -> Turno 
												aExcePer[ nFornX , 27 ]  ;	//09 -> Recno
											   };
								 )
							--nFornX	 
						EndIF
					Else
						--nFornX
					EndIF
				Next nX
			EndIF
	    
	    Next nY

	ElseIF !( lPeriodo ) //Pesquizando em Arquivo

		DEFAULT cIndKeyExc	:= "P2_FILIAL+P2_MAT+P2_CC+P2_TURNO+DtoS(P2_DATA)+P2_TIPODIA"
		DEFAULT nOrderExce	:= RetOrdem( "SP2" , cIndKeyExc )

		IF SP2->( IndexOrd() <> nOrderExce )
			IF !fContemStr( cIndKeyExc , SP2->( IndexKey() ) )
				SP2->( dbSetOrder( nOrderExce ) )
			EndIF
		EndIF

		baScan := { |x| x[2] + Dtos( x[3] ) + Dtos( x[4] ) == P2_TIPODIA + Dtos( P2_DATA ) + Dtos( P2_DATAATE ) }
		bExce  := { || dData >= P2_DATA .and. dData <= IF(!Empty(P2_DATAATE),P2_DATAATE,P2_DATA) }
		bLoop  := { || P2_FILIAL + P2_MAT + P2_CC + P2_TURNO == aString[1]  .or.	;
					   P2_FILIAL + P2_MAT + P2_CC + P2_TURNO == aString[2]  		;
				   }

		For nY := 1 To nFornY

			aString := RetCondExce( cFil , cMat , cTno , cCC , dData , nY )

			IF SP2->(dbSeek( aString[1] , .F.) .or. dbSeek( aString[2] , .F.) ) 
				While SP2->( !Eof() .and. Eval( bLoop ) )
					IF ( lExcecao := SP2->( Eval( bExce ) ) ) 
						While SP2->( !Eof() .and. Eval( bLoop ) )
							IF SP2->( Eval( bExce ) )
								IF Empty( aExceTip ) .or. SP2->( aScan( aExceTip , baScan ) ) == 0
									++nX
									SP2->( aAdd( aExceTip , {				 ;
																nX			,;	//01 -> Indice da Excecao em aExcePer
																P2_TIPODIA	,;	//02 -> Tipo do Dia para a Excecao
																P2_DATA		,;	//03 -> Data Inicial da Excecao
																P2_DATAATE	,;	//04 -> Data Final da Excecao
																P2_FILIAL   ,;	//05 -> Filial
																P2_MAT      ,;	//06 -> Matricula do Funcionario
																P2_CC		,;	//07 -> Centro de Custo
																P2_TURNO    ,;	//08 -> Turno
																Recno()		 ;	//09 -> Recno
															 };
												);
										  )
								EndIF
								SP2->( dbSkip() )
							Else
								Break
							EndIF
						End While
					Else
						SP2->( dbSkip() )
					EndIF
				End While
			EndIF
	
		Next nY
		
	EndIF

End Sequence

lExcecao := .F.
IF !( lPeriodo )

	nPos := 0
	IF !Empty( aExceTip )

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Procura Excecao sem o Tipo do Dia                            Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	   	baScan	:= { |e| (;
	   						(;
	   							e[5] +			;	//Filial
	   							e[6] +			;	//Matricula
	   							e[7] +			;	//Centro de Custo
	   							e[8] + 			;	//Turno
	   							e[2]			;	//Tipo do Dia
	   						);	
	   						==					;
							(;
								aString[2] +	;
								cSpcTipoDia		;
							);	
	   					 );
		   			 }
	
		For nY := 1 To nFornY
	
			aString := RetCondExce( cFil , cMat , cTno , cCC , dData , nY )
			IF ( ( nPos := aScan( aExceTip , baScan ) ) > 0 )
	        	Exit
	        EndIF
	
		Next nY
	
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Procura Excecao Expecifica para o Tipo do Dia                Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( ( nPos == 0 ) )
	    
		   	baScan	:= { |e| (;
		   						(;
		   							e[5] +			;	//Filial
		   							e[6] +			;	//Matricula
		   							e[7] +			;	//Centro de Custo
		   							e[8] +			;	//Turno
		   							e[2]			;	//Tipo do Dia
		   						);	
		   						==					;
		   						(;
		   							aString[2] +	;
		   							cTipoDia		;
		   						);	
		   					 );
			   			 }
		
			For nY := 1 To nFornY
		
				aString := RetCondExce( cFil , cMat , cTno , cCC , dData , nY )
				IF ( ( nPos := aScan( aExceTip , baScan ) ) > 0 )
		        	Exit
		        EndIF
		
			Next nY
	
		EndIF
		
	EndIF

	IF ( lExcecao := ( nPos > 0 ) )
	
		cTipoDia	:= aExceTip[ nPos , 02 ]
		nRecno      := aExceTip[ nPos , 09 ]
	
		IF !( lArray )
			IF ( SP2->( Recno() ) != nRecno )
				SP2->( dbGoto( nRecno ) )
			EndIF
		Else
			IF ( lForceGoto )
				IF ( SP2->( Recno() ) != nRecno )
					SP2->( dbGoto( nRecno ) )
				EndIF
			EndIF
			nPos := aExceTip[ nPos , 01 ]
		EndIF
	
		SP2->( fAddExce( @aArray , lArray , aExceper , nPos , dData , cRegra , nRecno ) )

	EndIF
	
ElseIF ( lPeriodo )

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Neste Ponto a Chamada devera ser Feita Pela Processa()       Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	SP2->( ProcRegua( RecCount() ) , dbGoTop() )

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁDepura o Arquivo de Excecoes Carregando as Excecoes do PeriodoЁ
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	fDepuraSP2( @cArqInd , dPerIni , dPerFim , lShowDialog )

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Carrega as Excecoes do Periodo                             Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	aExcePer := {}
	While SP2->( !Eof() )
		IncProc(OemToAnsi(STR0060))	// 'Carregando as Exce┤■es do Per║odo...'
		SP2->( fAddExce( @aExcePer , NIL , NIL , NIL , NIL , cRegra , Recno() ) )
		SP2->( dbSkip() )
	End While

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Restaura Indices do SP2 e Apaga Indice Temporario          Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF !Empty( cArqInd )
		RetIndex("SP2")
		SP2->( dbSetOrder( nOrderExce ) )
		fErase( cArqInd + OrdBagExt() )
	EndIF

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Carrega o Retorno da Funcao                                Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	lExcecao := ( Len( aExcePer ) > 0 )

EndIF

Return( lExcecao )

/*/
зддддддддддбддддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁRetCondExce	  Ё Autor ЁMarinaldo de Jesus    Ё Data Ё19/04/2001Ё
цддддддддддеддддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRetorna Array com Chaves para a Pesquisa das Excecoes          Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁRetCondExce( cFil , cMat , cTno , cCC , dData , nInd )		   Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ                                         					   Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁxRet ->	Qdo PCount() = 0 , Numero de Condicoes Existentes, casoЁ
Ё          Ё       	Contrario, Array de 2 Posicoes contendo as Chaves  paraЁ
Ё          Ё       	a Pesquisa das Excecoes.                               Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	       Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGetExcecoes()												   Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function RetCondExce( cFil , cMat , cTno , cCC , dData , nInd )

Local cSpcP2Mat	:= Space( GetSx3Cache( "P2_MAT    " , "X3_TAMANHO" ) ) 
Local cSpcP2Cc	:= Space( GetSx3Cache( "P2_CC     " , "X3_TAMANHO" ) ) 
Local cSpcP2Tno	:= Space( GetSx3Cache( "P2_TURNO  " , "X3_TAMANHO" ) ) 
Local xRet		:= NIL

IF Empty( PCount() )
	xRet := 8.00
Else
	xRet := Array( 02 )
	IF nInd == 1		//Pesquisando Mat + CC + Turno
		xRet[1]		:=  ( cFil + cMat + cCC + cTno + Dtos( dData ) )
		xRet[2]		:=  ( cFil + cMat + cCC + cTno )
	ElseIF nInd == 2	//Pesquisando Mat + CC + ЧЧЧЧЧ
		xRet[1]		:=	( cFil + cMat + cCC + cSpcP2Tno + Dtos( dData ) )
		xRet[2]		:=  ( cFil + cMat + cCC + cSpcP2Tno )
	ElseIF nInd == 3	//Pesquisando Mat + ЧЧ + Turno
		xRet[1]		:=	( cFil + cMat + cSpcP2Cc + cTno + Dtos( dData ) )
		xRet[2]		:=  ( cFil + cMat + cSpcP2Cc + cTno )
	ElseIF nInd == 4	//Pesquisando Mat + ЧЧ + ЧЧЧЧЧ
		xRet[1]		:=	( cFil + cMat + cSpcP2Cc + cSpcP2Tno + Dtos( dData ) )
		xRet[2]		:=  ( cFil + cMat + cSpcP2Cc + cSpcP2Tno )
	ElseIF nInd == 5	//Pesquisando ЧЧЧ + CC + Turno
		xRet[1]		:=  ( cFil + cSpcP2Mat + cCC + cTno + Dtos( dData ) )
		xRet[2]		:=  ( cFil + cSpcP2Mat + cCC + cTno )
	ElseIF nInd == 6	//Pesquisando ЧЧЧ + ЧЧ + Turno
		xRet[1]		:=  ( cFil + cSpcP2Mat + cSpcP2Cc + cTno + Dtos( dData ) )
	    xRet[2]		:=  ( cFil + cSpcP2Mat + cSpcP2Cc + cTno )
	ElseIF nInd == 7	//Pesquisando ЧЧЧ + CC + ЧЧЧЧЧ
		xRet[1]		:=  ( cFil + cSpcP2Mat + cCC + cSpcP2Tno + Dtos( dData ) ) 
	    xRet[2]		:=  ( cFil + cSpcP2Mat + cCC + cSpcP2Tno )
	ElseIF nInd == 8	//Pesquisando ЧЧЧ + ЧЧ + ЧЧЧЧЧ
		xRet[1]		:=  ( cFil + cSpcP2Mat + cSpcP2Cc + cSpcP2Tno + Dtos( dData ) )
		xRet[2]		:=  ( cFil + cSpcP2Mat + cSpcP2Cc + cSpcP2Tno )
	EndIF
EndIF
	
Return( xRet )

/*/
зддддддддддбдддддддддддбддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGetExceTop ЁAutor Ё Marinaldo de Jesus    Ё Data Ё07/06/2001Ё
цддддддддддедддддддддддаддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁCarrega a Tabela de Exce┤■es                	            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGetExcecoes()												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁPar┐metrosЁ< Vide Parametros Formais >							        Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁPonto Eletronico RDD TOPCONNECT                             Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetExceTop( cFil		,; //01 -> Filial
					 cMat 		,; //02 -> Matricula
					 cCc		,; //03 -> Centro de Custo
					 aTurnos	,; //04 -> Array com os Turnos do Funcionario
					 dPerIni	,; //05 -> Periodo Inicial
					 dPerFim	,; //06 -> Periodo Final
					 aArray  	 ; //07 -> Array a ser carregado com as Excecoes
					)

Local aSvAlias  := GetArea()
Local lRet		:= .F.

#IFDEF TOP

	Local baScan		:= { || NIL }
	Local cPerIni		:= Dtos( dPerIni )
	Local cPerFim		:= Dtos( dPerFim )
	Local cRegra		:= SRA->RA_REGRA
	Local cSpaceMat		:= Space( GetSx3Cache( "RA_MAT    " , "X3_TAMANHO" ) )
	Local cSpaceCus 	:= Space( GetSx3Cache( "RA_CC     " , "X3_TAMANHO" ) )
	Local cSpaceTur 	:= Space( GetSx3Cache( "RA_TNOTRAB" , "X3_TAMANHO" ) )
	Local cQuery		:= ""
	Local cTno			:= ""
	Local cAliasQuery	:= "__QSP2QRY"
	Local cInitSqlName	:= InitSqlName("SP2")
	Local lQueryOpened	:= .F.
	Local nLenTurno		:= 0
	Local nX			:= 0
	Local nY			:= 0
	Local nSvOrder		:= SP2->( IndexOrd() )
	
	Static aStruSP2
	Static cIndKeyExc
	Static cQrySp2Fields
	Static nOrderExce
	Static nFieldsSP2
	
	DEFAULT cIndKeyExc	:= "P2_FILIAL+P2_MAT+P2_CC+P2_TURNO+DtoS(P2_DATA)+P2_TIPODIA"
	DEFAULT nOrderExce	:= RetOrdem( "SP2" , cIndKeyExc )

	IF ( aStruSP2	== NIL )
		aStruSP2	:= SP2->( dbStruct() )
		nFieldsSP2	:= Len( aStruSP2 )
	EndIF	

 	IF ( cQrySp2Fields == NIL )
		cQrySp2Fields := ""
		For nX := 1 To nFieldsSP2
			cQrySp2Fields += aStruSP2[ nX , 01 ] + ", "
		Next nX
    EndIF

	aArray := {}
	
	IF ( nOrderExce == nSvOrder )
		SP2->( dbSetOrder( nOrderExce ) )
	EndIF    

	baScan	:= { |x| x[1] ==  (cAliasQuery)->P2_FILIAL	.AND. ; //Filial
			  		 x[2] ==  (cAliasQuery)->P2_DATA	.AND. ; //Data De
					 x[3] ==  (cAliasQuery)->P2_DATAATE	.AND. ; //Data Ate
					 x[4] ==  (cAliasQuery)->P2_TURNO	.AND. ; //Turno
					 x[5] ==  (cAliasQuery)->P2_CC		.AND. ; //Centro de Custo
					 x[6] ==  (cAliasQuery)->P2_MAT		.AND. ; //Matricula
					 x[35] == (cAliasQuery)->P2_TIPODIA		  ; //Tipo do Dia Para Excecao
	            }
	
	nLenTurno := Len( aTurnos )
	For nY := 1 To nLenTurno

		cTno	:= aTurnos[ nY , 01 ]
		cQuery	:= "SELECT "
		cQuery  += cQrySp2Fields
		cQuery	+= "R_E_C_N_O_ RECNO"
		cQuery	+= " FROM "
		cQuery	+= cInitSqlName
		cQuery	+= " WHERE "
		cQuery	+= "("
		cQuery	+=	"("
		cQuery	+= 		"("
		cQuery	+= 			"P2_FILIAL='"+cFil+"' AND P2_MAT='"+cMat+"' AND P2_CC='"+cCc+"' AND P2_TURNO='"+cTno+"'"
		cQuery	+= 		")"
		cQuery	+= 		" OR "
		cQuery	+= 		"("
		cQuery	+= 			"P2_FILIAL='"+cFil+"' AND P2_MAT='"+cMat+"' AND P2_CC='"+cCc+"' AND P2_TURNO='"+cSpaceTur+"'"
		cQuery	+= 		")"
		cQuery	+= 		" OR "
		cQuery	+= 		"("
		cQuery	+= 			"P2_FILIAL='"+cFil+"' AND P2_MAT='"+cMat+"' AND P2_CC='"+cSpaceCus+"' AND P2_TURNO='"+cTno+"'"
		cQuery	+=		")"
		cQuery	+=		" OR "
		cQuery	+= 		"("
		cQuery	+= 			"P2_FILIAL='"+cFil+"' AND P2_MAT='"+cMat+"' AND P2_CC='"+cSpaceCus+"' AND P2_TURNO='"+cSpaceTur+"'"
		cQuery	+=		")"
		cQuery	+=		" OR "
		cQuery	+= 		"("
		cQuery	+= 			"P2_FILIAL='"+cFil+"' AND P2_MAT='"+cSpaceMat+"' AND P2_CC='"+cCc+"' AND P2_TURNO='"+cTno+"'"
		cQuery	+= 		")"
		cQuery	+= 		" OR "
		cQuery	+= 		"("
		cQuery	+= 			"P2_FILIAL='"+cFil+"' AND P2_MAT='"+cSpaceMat+"' AND P2_CC='"+cSpaceCus+"' AND P2_TURNO='"+cTno+"'"
		cQuery	+= 		")"
		cQuery	+= 		" OR "
		cQuery	+= 		"("
		cQuery	+= 			"P2_FILIAL='"+cFil+"' AND P2_MAT='"+cSpaceMat+"' AND P2_CC='"+cCc+"' AND P2_TURNO='"+cSpaceTur+"'"
		cQuery	+= 		")"
		cQuery	+= 		" OR "
		cQuery	+= 		"("
		cQuery	+= 			"P2_FILIAL='"+cFil+"' AND P2_MAT='"+cSpaceMat+"' AND P2_CC='"+cSpaceCus+"' AND P2_TURNO='"+cSpaceTur+"'"
		cQuery	+=		")"
		cQuery	+=		" AND "
		cQuery	+= 		"("
		cQuery	+= 			"("
		cQuery	+= 			 	"P2_DATAATE BETWEEN '"+cPerIni+"' AND '"+cPerFim+"'" 
		cQuery	+= 			")"
		cQuery	+= 			" OR "
		cQuery	+= 			"("
		cQuery	+= 				"P2_DATA BETWEEN '"+cPerIni+"' AND '"+cPerFim+"'"
		cQuery	+= 			")"
		cQuery	+= 			" OR "
		cQuery	+= 			"("
		cQuery	+= 				"P2_DATAATE >='"+cPerFim+"' AND P2_DATA<='"+cPerIni+"'"
		cQuery	+= 			")"
		cQuery	+= 		")"
		cQuery	+=	")"
		cQuery	+=	" AND D_E_L_E_T_=' '"
		cQuery	+= ")"
		cQuery	+= " ORDER BY "+SqlOrder( SP2->( IndexKey() ) )
		cQuery	:= ChangeQuery( cQuery )
		
		IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )

			For nX := 1 To nFieldsSP2
				IF ( aStruSP2[nX,02] <> "C" )
					TcSetField(cAliasQuery,aStruSP2[nX,01],aStruSP2[nX,02],aStruSP2[nX,03],aStruSP2[nX,04])
				EndIF
			Next nX
	
			While ( cAliasQuery )->( !Eof() )
	
				IF aScan( aArray , baScan ) == 0
					( cAliasQuery )->( fAddExce( @aArray , NIL , NIL , NIL , NIL , cRegra , RECNO ) )
				EndIF
				
				( cAliasQuery )->( dbSkip() )
			
			End While
			
			( cAliasQuery )->( dbCloseArea() )

		EndIF
			
	Next nY	

	IF ( nOrderExce == nSvOrder )
		SP2->( dbSetOrder( nSvOrder ) )
	EndIF

	lRet := !( Empty( aArray ) )

#ENDIF

RestArea( aSvAlias )
	
Return( lRet )

/*/
зддддддддддбддддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁfAddExce      Ё Autor ЁMarinaldo de Jesus    Ё Data Ё18/07/2001Ё
цддддддддддеддддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁCarregar o Array de Excecoes com Informacoes do SP2            Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁSP2>->( fAddExce( @aArray ) )                          		   Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ                                         					   Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁaArray   -> Array que contera as Excecoes do SP2               Ё
Ё          ЁlArray   -> Quando True Carrega Excecao de aExcePer            Ё
Ё          ЁaExcePer -> Array com as Excecoes por Periodo                  Ё
Ё          ЁnPos     -> Posicao da Excecao em aExcePer                     Ё
Ё          ЁdData    -> Data da Excecao                                    Ё
Ё          ЁcRegra   -> Regra de Apontamento do Cadastro de Funcionarios   Ё
Ё          ЁnRecno   -> Recno Correspondente a Excecao                     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	       Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGetExcecoes() e GetExceTop()								   Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function fAddExce( aArray , lArray , aExceper , nPos , dData , cRegra , nRecno )

Local nLenArray := 0
Local cHerdHor	:= "N"

IF !( lArray )
	cRegra		:=	IF( Empty( P2_REGRA ) , cRegra , P2_REGRA )
	cHerdHor	:=	IF( ( P2_HERDHOR == "S" ) , "S", "N" )
EndIF

IF ( dData == NIL ) //Carrega as Excecoes Por Periodo
	aAdd(aArray, Array( 48 ) )
	nLenArray := Len( aArray )
	aArray[nLenArray,01] := P2_FILIAL	//01 - Filial
	aArray[nLenArray,02] := P2_DATA		//02 - Data da Excecao
	aArray[nLenArray,03] := P2_DATAATE	//03 - Data Final da Excecao
	aArray[nLenArray,04] := P2_TURNO	//04 - Turno para a Excecao
	aArray[nLenArray,05] := P2_CC		//05 - Centro de Custo para a Excecao
	aArray[nLenArray,06] := P2_MAT		//06 - Matricula para a Excecao
	aArray[nLenArray,07] := P2_ENTRA1	//07 - 1a. Entrada
	aArray[nLenArray,08] := P2_SAIDA1	//08 - 1a. Saida
	aArray[nLenArray,09] := P2_ENTRA2	//09 - 2a. Entrada
	aArray[nLenArray,10] := P2_SAIDA2	//10 - 2a. Saida
	aArray[nLenArray,11] := P2_ENTRA3	//11 - 3a. Entrada
	aArray[nLenArray,12] := P2_SAIDA3	//12 - 3a. Saida
	aArray[nLenArray,13] := P2_ENTRA4	//13 - 4a. Entrada
	aArray[nLenArray,14] := P2_SAIDA4	//14 - 4a. Saida
	aArray[nLenArray,15] := P2_INTERV1	//15 - Primeira Saida Intervalo
	aArray[nLenArray,16] := P2_INTERV2	//16 - Segunda Saida Intervalo
	aArray[nLenArray,17] := P2_INTERV3	//17 - Terceira Saida Intervalo
	aArray[nLenArray,18] := P2_HRSTRAB	//18 - Horas Trabalhadas 1a. Jornada
	aArray[nLenArray,19] := P2_HRSTRA2	//19 - Horas Trabalhadas 2a. Jornada
	aArray[nLenArray,20] := P2_HRSTRA3	//20 - Horas Trabalhadas 3a. Jornada
	aArray[nLenArray,21] := P2_HRSTRA4	//21 - Horas Trabalhadas 4a. Jornada
	aArray[nLenArray,22] := 0			//22 - Numero de Marcacoes da Tabela (Nao usado)
	aArray[nLenArray,23] := P2_MOTIVO	//23 - Motivo da Excecao
	aArray[nLenArray,24] := P2_CODHEXT	//24 - Codigo da Hora Extra Normal
	aArray[nLenArray,25] := P2_TRABA	//25 - Dia Trabalhado
	aArray[nLenArray,26] := P2_CODHNOT	//26 - Codigo da Hora Extra Noturna
	aArray[nLenArray,27] := nRecno		//27 - Registro da Excecao
	aArray[nLenArray,28] := P2_HRINTV1	//28 - Horas do Primeiro Intervalo
	aArray[nLenArray,29] := P2_HRINTV2	//29 - Horas do Segundo Intervalo
	aArray[nLenArray,30] := P2_HRINTV3	//30 - Horas do Terceiro Intervalo
	aArray[nLenArray,31] := P2_CCPER01	//31 - Centro de Custo da 1a. Jornada
	aArray[nLenArray,32] := P2_CCPER02	//32 - Centro de Custo da 2a. Jornada
	aArray[nLenArray,33] := P2_CCPER03	//33 - Centro de Custo da 3a. Jornada
	aArray[nLenArray,34] := P2_CCPER04	//34 - Centro de Custo da 4a. Jornada
	aArray[nLenArray,35] := P2_TIPODIA	//35 - Tipo do Dia para a Excecao
	aArray[nLenArray,36] := P2_NONAHOR	//36 - Aponta Nona Hora
	aArray[nLenArray,37] := P2_HORMENO	//37 - Limite de Horario Inicial
	aArray[nLenArray,38] := P2_HORMAIS	//38 - Limite de Horario Final
	aArray[nLenArray,39] := P2_JND1CON	//39 - 1a. Jornada Continua
	aArray[nLenArray,40] := P2_JND2CON	//40 - 2a. Jornada Continua
	aArray[nLenArray,41] := P2_JND3CON	//41 - 2a. Jornada Continua
	aArray[nLenArray,42] := P2_JND4CON	//42 - 2a. Jornada Continua
	aArray[nLenArray,43] := P2_CODREF	//43 - Codigo da Refeicao
	aArray[nLenArray,44] := cRegra		//44 - Regra de Apontamento
	aArray[nLenArray,45] := P2_INIHNOT	//45 - Inicio da Hora Noturna
	aArray[nLenArray,46] := P2_FIMHNOT	//46 - Final da Hora Noturna
	aArray[nLenArray,47] := P2_MINHNOT	//47 - Minutos da Hora Noturna 
	aArray[nLenArray,48] := cHerdHor	//48 - Herda Hora (Mantem o Horario do Calendario) 
Else //Carrega as Excecoes na Data
	aAdd( aArray , Array( 46 ) )
	nLenArray := Len( aArray )
	aArray[nLenArray,01] := dData					//01 - Data
	IF ( lArray )
		aArray[nLenArray,02] := aExcePer[nPos,04]	//02 - Turno
		aArray[nLenArray,03] := aExcePer[nPos,05]	//03 - CC
		aArray[nLenArray,04] := aExcePer[nPos,06]	//04 - Mat
		aArray[nLenArray,05] := aExcePer[nPos,07]	//05 - Entra1
		aArray[nLenArray,06] := aExcePer[nPos,08]	//06 - Saida1
		aArray[nLenArray,07] := aExcePer[nPos,09]	//07 - Entra2
		aArray[nLenArray,08] := aExcePer[nPos,10]	//08 - Saida2
		aArray[nLenArray,09] := aExcePer[nPos,11]	//09 - Entra3
		aArray[nLenArray,10] := aExcePer[nPos,12]	//10 - Saida3
		aArray[nLenArray,11] := aExcePer[nPos,13]	//11 - Entra4
		aArray[nLenArray,12] := aExcePer[nPos,14]	//12 - Saida4
		aArray[nLenArray,13] := aExcePer[nPos,15]	//13 - Intervalo1
		aArray[nLenArray,14] := aExcePer[nPos,16]	//14 - Intervalo2
		aArray[nLenArray,15] := aExcePer[nPos,17]	//15 - Intervalo3
		aArray[nLenArray,16] := aExcePer[nPos,18]	//16 - Horas Trabalhadas 1a. Jornada
		aArray[nLenArray,17] := aExcePer[nPos,19]	//17 - Horas Trabalhadas 2a. Jornada
		aArray[nLenArray,18] := aExcePer[nPos,20]	//18 - Horas Trabalhadas 3a. Jornada
		aArray[nLenArray,19] := aExcePer[nPos,21]	//19 - Horas Trabalhadas 4a. Jornada
		aArray[nLenArray,20] := aExcePer[nPos,22]	//20 - TabMarc("SP2") Numero de Marcacoes da Tabela
		aArray[nLenArray,21] := aExcePer[nPos,23]	//21 - Motivo
		aArray[nLenArray,22] := aExcePer[nPos,24]	//22 - HExt
		aArray[nLenArray,23] := aExcePer[nPos,25]	//23 - Traba
		aArray[nLenArray,24] := aExcePer[nPos,26]	//24 - HENot
		aArray[nLenArray,25] := aExcePer[nPos,27]	//25 - Recno
		aArray[nLenArray,26] := aExcePer[nPos,28]	//26 - Horas do 1o. Intervalo	
		aArray[nLenArray,27] := aExcePer[nPos,29]	//27 - Horas do 2o. Intervalo
		aArray[nLenArray,28] := aExcePer[nPos,30]	//28 - Horas do 3o. Intervalo
		aArray[nLenArray,29] := aExcePer[nPos,31]	//29 - Centro de Custo Periodo 1 (1a.E-1a.S)
		aArray[nLenArray,30] := aExcePer[nPos,32]	//30 - Centro de Custo Periodo 2 (2a.E-2a.S)
		aArray[nLenArray,31] := aExcePer[nPos,33]	//31 - Centro de Custo Periodo 3 (3a.E-3a.S)
		aArray[nLenArray,32] := aExcePer[nPos,34]	//32 - Centro de Custo Periodo 4 (4a.E-4a.S)
		aArray[nLenArray,33] := aExcePer[nPos,35]	//33 - Tipo do Dia para a Excecao
		aArray[nLenArray,34] := aExcePer[nPos,36]	//34 - Aponta Nona Hora
		aArray[nLenArray,35] := aExcePer[nPos,37]	//35 - Limite de Horario Inicial
		aArray[nLenArray,36] := aExcePer[nPos,38]	//36 - Limite de Horario Inicial
		aArray[nLenArray,37] := aExcePer[nPos,39]	//37 - 1a. Jornada Continua
		aArray[nLenArray,38] := aExcePer[nPos,40]	//38 - 2a. Jornada Continua
		aArray[nLenArray,39] := aExcePer[nPos,41]	//39 - 2a. Jornada Continua
		aArray[nLenArray,40] := aExcePer[nPos,42]	//40 - 2a. Jornada Continua
		aArray[nLenArray,41] := aExcePer[nPos,43]	//41 - Codigo da Refeicao
		aArray[nLenArray,42] := aExcePer[nPos,44]	//42 - Regra de Apontamento
		aArray[nLenArray,43] := aExcePer[nPos,45]	//43 - Inicio da Hora Noturna
		aArray[nLenArray,44] := aExcePer[nPos,46]	//44 - Final da Hora Noturna
		aArray[nLenArray,45] := aExcePer[nPos,47]	//45 - Minutos da Hora Noturna  
		aArray[nLenArray,46] := aExcePer[nPos,48]	//46 - Herda Hora (Mantem o Horario do Calendario) 
	Else
		aArray[nLenArray,02] :=	P2_TURNO			//02 - Turno
		aArray[nLenArray,03] := P2_CC				//03 - CC
		aArray[nLenArray,04] := P2_MAT				//04 - Mat
		aArray[nLenArray,05] := P2_ENTRA1			//05 - Entra1
		aArray[nLenArray,06] := P2_SAIDA1			//06 - Saida1
		aArray[nLenArray,07] := P2_ENTRA2			//07 - Entra2
		aArray[nLenArray,08] := P2_SAIDA2			//08 - Saida2
		aArray[nLenArray,09] := P2_ENTRA3			//09 - Entra3
		aArray[nLenArray,10] := P2_SAIDA3			//10 - Saida3
		aArray[nLenArray,11] := P2_ENTRA4			//11 - Entra4
		aArray[nLenArray,12] := P2_SAIDA4			//12 - Saida4
		aArray[nLenArray,13] := P2_INTERV1			//13 - Intervalo1
		aArray[nLenArray,14] := P2_INTERV2			//14 - Intervalo2
		aArray[nLenArray,15] := P2_INTERV3			//15 - Intervalo3
		aArray[nLenArray,16] := P2_HRSTRAB			//16 - Horas Trabalhadas 1a. Jornada
		aArray[nLenArray,17] := P2_HRSTRA2			//17 - Horas Trabalhadas 2a. Jornada
		aArray[nLenArray,18] := P2_HRSTRA3			//18 - Horas Trabalhadas 3a. Jornada
		aArray[nLenArray,19] := P2_HRSTRA4			//19 - Horas Trabalhadas 4a. Jornada
		aArray[nLenArray,20] := 0					//20 - TabMarc("SP2") Numero de Marcacoes da Tabela
		aArray[nLenArray,21] := P2_MOTIVO			//21 - Motivo
		aArray[nLenArray,22] := P2_CODHEXT			//22 - HExt
		aArray[nLenArray,23] := P2_TRABA			//23 - Traba
		aArray[nLenArray,24] := P2_CODHNOT			//24 - HENot
		aArray[nLenArray,25] := nRecno				//25 - Recno
		aArray[nLenArray,26] := P2_HRINTV1			//26 - Horas do 1o. Intervalo	
		aArray[nLenArray,27] := P2_HRINTV2			//27 - Horas do 2o. Intervalo
		aArray[nLenArray,28] := P2_HRINTV3			//28 - Horas do 3o. Intervalo
		aArray[nLenArray,29] := P2_CCPER01			//29 - Centro de Custo Periodo 1 (1a.E-1a.S)
		aArray[nLenArray,30] := P2_CCPER02			//30 - Centro de Custo Periodo 2 (2a.E-2a.S)
		aArray[nLenArray,31] := P2_CCPER03			//31 - Centro de Custo Periodo 3 (3a.E-3a.S)
		aArray[nLenArray,32] := P2_CCPER04			//32 - Centro de Custo Periodo 4 (4a.E-4a.S)
		aArray[nLenArray,33] := P2_TIPODIA			//33 - Tipo do Dia para a Excecao
		aArray[nLenArray,34] := P2_NONAHOR			//34 - Aponta Nona Hora
		aArray[nLenArray,35] := P2_HORMENO			//35 - Limite de Horario Inicial
		aArray[nLenArray,36] := P2_HORMAIS			//36 - Limite de Horario Inicial
		aArray[nLenArray,37] := P2_JND1CON			//37 - 1a. Jornada Continua
		aArray[nLenArray,38] := P2_JND2CON			//38 - 2a. Jornada Continua
		aArray[nLenArray,39] := P2_JND3CON			//39 - 2a. Jornada Continua
		aArray[nLenArray,40] := P2_JND4CON			//40 - 2a. Jornada Continua
		aArray[nLenArray,41] := P2_CODREF			//41 - Codigo da Refeicao
		aArray[nLenArray,42] := cRegra				//42 - Regra de Apontamento
		aArray[nLenArray,43] := P2_INIHNOT			//43 - Inicio da Hora Noturna
		aArray[nLenArray,44] := P2_FIMHNOT			//44 - Final da Hora Noturna
		aArray[nLenArray,45] := P2_MINHNOT			//45 - Minutos da Hora Noturna
		aArray[nLenArray,46] := cHerdHor			//46 - Herda Hora (Mantem o Horario do Calendario) 
	EndIF
EndIF
	
Return( NIL )

/*/
зддддддддддбдддддддддддбддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁPutHrsTab  ЁAutor Ё Marinaldo de Jesus    Ё Data Ё27/04/2001Ё
цддддддддддедддддддддддаддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁAtualiza as Horas da Tabela de Horario/Excecoes		        Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁPutHrsTab( cAlias , lProcess )								Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁPar┐metrosЁcAlias   -> Alias da Tabela a Ser Atualizada                Ё
Ё          Ё            "SP2" -> Excecoes                               Ё
Ё          Ё            "SPJ" -> Tabela de Horario Padrao               Ё
Ё          ЁlProcess -> False Executa via Processa()                    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       Ё                                                            Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PutHrsTab( cAlias , lProcess )

Local bEval			:= { |e| &(e) }
Local cCond			:= ""
Local cPerg			:= ""
Local cPref			:= ""
Local cSeek			:= ""
Local nHoras		:= 0

Private lAbortPrint := .F.

DEFAULT cAlias	 := "SPJ"
DEFAULT lProcess := .F.

cAlias	:= Upper( AllTrim( cAlias ) )
cPerg	:= IF( cAlias == "SPJ" , "PNCAPJ" , "PNCAP2" )
cPref	:= ( PrefixoCpo( cAlias ) + "_" )

IF cAlias == "SPJ"
	cCond := "PJ_FILIAL+PJ_TURNO"
Else
	cCond := "P2_FILIAL+DTOS(P2_DATA)"
EndIF	

IF !( lProcess )
	IF Pergunte( cPerg , .T. )
		Processa( { || PutHrsTab( cAlias , .T. ) } , IF( cAlias == "SPJ" , STR0061 , STR0062 ) ,, .T. )
		Return( NIL )
	EndIF
Else
	Pergunte( cPerg , .F. )
	dbSelectArea( cAlias )
	( cAlias )->( ProcRegua( RecCount() ) , dbGotop() , dbSetOrder( RetOrdem( cAlias , cCond ) ) )
	IF !Empty( xFilial( cAlias ) )
		cSeek := ( MV_PAR01 + IF( cAlias == "SPJ" , MV_PAR03 , Dtos( MV_PAR03 ) ) )
	Else
		cSeek := ( Space( 02 ) + IF( cAlias == "SPJ" , MV_PAR03 , Dtos( MV_PAR03 ) ) )
	EndIF
	( cAlias )->( dbSeek( cSeek , .T. ) )
	While ( cAlias )->( !Eof() .and. Eval( bEval , cCond ) <= MV_PAR02 + IF( cAlias == "SPJ" , MV_PAR04 , Dtos( MV_PAR04 ) ) )
	    IncProc( STR0063 )
	    IF ( lAbortPrint )
	    	Exit
	    EndIF	
	    IF RecLock( cAlias , .F. , .F. )
			nHoras := 0
			nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAlias )->( IF( cAlias == "SPJ" , PJ_HRSINT1 , P2_HRINTV1 ) )	:= fHrsTrabGat( "I" , cAlias , "DB" , "1" ) ) ), 0 )
			nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAlias )->( IF( cAlias == "SPJ" , PJ_HRSINT2 , P2_HRINTV2 ) ) := fHrsTrabGat( "I" , cAlias , "DB" , "2" ) ) ), 0 )
			nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAlias )->( IF( cAlias == "SPJ" , PJ_HRSINT3 , P2_HRINTV3 ) ) := fHrsTrabGat( "I" , cAlias , "DB" , "3" ) ) ), 0 )
			nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAlias )->( &(cPref+"HRSTRAB") ) := fHrsTrabGat( "H" , cAlias , "DB" , "1" ) ) ) ,0 )
			nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAlias )->( &(cPref+"HRSTRA2") ) := fHrsTrabGat( "H" , cAlias , "DB" , "2" ) ) ) ,0 )
			nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAlias )->( &(cPref+"HRSTRA3") ) := fHrsTrabGat( "H" , cAlias , "DB" , "3" ) ) ) ,0 )
			nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAlias )->( &(cPref+"HRSTRA4") ) := fHrsTrabGat( "H" , cAlias , "DB" , "4" ) ) ) ,0 )
			( cAlias )->( IF( cAlias == "SPJ" , PJ_HRTOTAL , P2_TOTHORA ) ) := nHoras
			( cAlias )->( MsUnLock() )
		EndIF	
		( cAlias )->( dbSkip() ) 
	End While
EndIF
	
Return( NIL )

/*/
зддддддддддбддддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁCheckPonMes   Ё Autor ЁMarinaldo de Jesus    Ё Data Ё14/05/2001Ё
цддддддддддеддддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁValida o Parametro de Fechamento do Ponto em Relacao ao PeriodoЁ
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide parametros Formais>									   Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide parametros Formais>									   Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlRet -> Se a Competencia e' Valida                             Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	       Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerica                                                       Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function CheckPonMes(	dPerIni			,;	//Periodo Inicial de Apontamento
						dPerFim 		,;	//Periodo Final   de Apontamento
						lPut			,;	//Se True Grava Novo Periodo no Parametro do SX6
						lContinua		,;	//Se True Mesmo que o Periodo Nao For Valido ira contornar True.
						lShowHelp		,;	//Se False Nao Mostra o Help. DEFAULT True
						cFil			,;	//Filial para PerAponta()
						lNewPer			,;	//Se eh para gerar novo periodo (Para PerAponta())
						lPerCompleto	 ;	//Se o periodo esta preenchido com AAAAMMDD/AAAAMMDD ou AAAAMMDDAAAAMMDD (por referencia)
					 )

Local cHelp			:= ""
Local cPerg			:= "PONMES"
Local dIniFec		:= Ctod("//")
Local dFimFec		:= Ctod("//")
Local lRet			:= .T.
Local lExistPonMes	:= .T.
Local lModPer		:= .T.
Local uSaveMvPar	:= IF( Type("MV_PAR01") != "U" , MV_PAR01 , NIL )

DEFAULT	dPerIni		:= Ctod("//")
DEFAULT	dPerFim 	:= Ctod("//")
DEFAULT lPut		:= .F.
DEFAULT lContinua	:= .F.
DEFAULT lShowHelp	:= .T.
DEFAULT cFil		:= cFilAnt
DEFAULT lNewPer		:= .F.

IF ( lRet := CheckModSPO() )
	IF ( lRet := ( GetPonMesDat( @dIniFec , @dFimFec , cFil ) .and. !lPut ) )
		IF ( lRet := PerAponta( @dPerIni , @dPerFim , NIL , lShowHelp , cFil , NIL , @lPerCompleto ) )
			lRet := ( ( dIniFec == dPerIni ) .and. ( dFimFec <= dPerFim ) )
			IF ( !lRet .and. !lContinua .and. lShowHelp )
				cHelp += ( STR0064 + Dtoc( dIniFec ) + Chr(13) )					//'Data Inicial: '
				cHelp += ( STR0065 + Dtoc( dFimFec ) )								//'Data Final  : '
				Help( " " , 1 , "PERIIVALID" , , cHelp , 4 , 0 )
			ElseIF ( lContinua .and. !lRet )
				cHelp += STR0066													//'O Periodo de Apontamento: '
				cHelp += Dtoc( dIniFec )
				cHelp += STR0067													//' a '
				cHelp += Dtoc( dFimFec )                                        	
				cHelp += STR0068													//'ainda n└o foi Fechado. Deseja Continuar?'
				IF ( lShowHelp )
					lRet := MsgNoYes( OemToAnsi( cHelp ) , OemToAnsi( STR0069 ) )	//"Aten┤└o"
				Else
					lRet := .T.
				EndIF
			EndIF
		EndIF
	Else
		IF !( lPut )
			IF ( lShowHelp )
				IF SX1->( dbSeek( cPerg+"01" ) )
					dbSelectArea("SX1")
					IF RecLock("SX1",.F.,.F.)
						SX1->X1_CNT01 := "'  /  /  '"
						SX1->( MsUnLock() )
					EndIF
				EndIF
				Pergunte( cPerg , .T. )
			EndIF
		EndIF
		IF ( lRet := PerAponta( @dPerIni , @dPerFim , IF( lPut , ( ++dPerFim ) , IF( Empty( MV_PAR01 ) .or. !( ValType( MV_PAR01 ) == "D" ) , dDataBase , MV_PAR01 ) ) , lShowHelp , cFil , lNewPer , @lPerCompleto ) )
			IF ( lPut .or. ( !lPut .and. !Empty( MV_PAR01 ) ) )
				IF !( lExistPonMes := PutMvFil( "MV_PONMES" , ( Dtos( dPerIni ) + "/" + Dtos( dPerFim ) ) , cFil ) )
					cHelp := OemToAnsi( STR0115 )										//'N└o Existe o Parametro MV_PONMES Para a Filial : '
					cHelp += CRLF
					cHelp += OemToAnsi( STR0116 )										//'Deseja Inclui-lo?'
					IF ( lShowHelp )
						IF MsgNoYes( OemToAnsi( cHelp ) , OemToAnsi( STR0069 ) )		//"Aten┤└o"
							IF ( lExistPonMes := CheckModSPO() )
								IF ( lExistPonMes := PutMvFil( "MV_PONMES" , ( Dtos( dPerIni ) + "/" + Dtos( dPerFim ) ) , cFil ) )
									lPut := .T.
								EndIF
							EndIF	
						EndIF
					EndIF
				Else
					lPut := .T.
				EndIF
		    EndIF
		    IF ( !( lPut ) .and. lExistPonMes )
			    IF ( lShowHelp )
			    	lRet := CheckPonMes( @dPerIni , @dPerFim , .F. , lContinua , lShowHelp , cFil , lNewPer )
	    		EndIF
	    	ElseIF !( lExistPonMes )
	    		IF ( lShowHelp )
	    			Help( " " , 1 , "NOMVPONMES" , , ( STR0114 + cFil ) , 4 , 0 ) //"Filial: "
	    		EndIF	
	    	EndIF                
	    Else
			IF ( lModPer )
				IF ( lShowHelp )
					lModPer := PonModPer( lModPer , cFil )
					lRet	:= CheckPonMes( @dPerIni , @dPerFim , .F. , .F. , .F. , cFil , .F. )
				EndIF
			EndIF
	    EndIF
	EndIF
EndIF
	
IF !Empty( uSaveMvPar )
	MV_PAR01 := uSaveMvPar
EndIF

Return( lRet )

/*/
зддддддддддбддддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁValidArqPon   Ё Autor ЁMarinaldo de Jesus    Ё Data Ё14/05/2001Ё
цддддддддддеддддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁValida o Relacionamentos dos Arquivos do Ponto Eletronico      Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁValidArqPon( lShowHelp )                           			   Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ                                         					   Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlRet -> Se todos os Arquivos Estao com o Relacionamento CorretoЁ
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	       Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerica                                                       Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function ValidArqPon( lShowHelp )
Return( PonRelationFile( lShowHelp ) )

/*/
зддддддддддбдддддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁPonRelationFileЁ Autor ЁMarinaldo de Jesus   Ё Data Ё14/05/2001Ё
цддддддддддедддддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁValida o Relacionamentos dos Arquivos do Ponto Eletronico      Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁPonRelationFile( void )                            			   Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ                                         					   Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlRet -> Se todos os Arquivos Estao com o Relacionamento CorretoЁ
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	       Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerica                                                       Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PonRelationFile( lShowHelp )

Local cMsg			:= ""
Local lRetModo		:= .T.

Static lPonChkRel
Static cLastEmpChk

DEFAULT lShowHelp	:= .T.

DEFAULT lRF0ChkTable	:= fVerTabRF0()  	//Verifica a Existencia da Tabela de Pre-Abonos e se a mesm possui registro

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Coloca o Ponteiro do Mouse em Estado de Espera               Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( lShowHelp )
	CursorWait()
EndIF	

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Consiste o Modo de Acesso dos Arquivos                       Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Begin Sequence
	DEFAULT lPonChkRel 	:= .T.
	DEFAULT cLastEmpChk	:= cEmpAnt
	IF ( cLastEmpChk <> cEmpAnt )
		lPonChkRel := .T.
	EndIF
	IF !( lPonChkRel )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SP2",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SP5",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SP8",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPB",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPC",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPF",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPG",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPH",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPI",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPK",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPL",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPN",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPS",lShowHelp) )
		Break
	EndIF	
	IF !( lRetModo := xRetModo("SRA","SPT",lShowHelp) )
		Break
	EndIF	
	
	//-- Se Existir a tabela de Pre-abonos, checa modo de acesso compativel
	IF lRF0ChkTable
		IF !( lRetModo := xRetModo("SRA","RF0",lShowHelp) )
			Break
		EndIF	
	Endif

	IF !( lRetModo := xRetModo("SR6","SPJ",lShowHelp) )
		Break
	EndIF
	IF !Empty( xFilial( "SP9" ) )
		IF !( lRetModo := xRetModo("SP9","SP4",lShowHelp) )
			Break
		EndIF
	EndIF	
	IF !( lRetModo := xRetModo("SP1","SPM",lShowHelp) )
		Break
	EndIF  
	
	IF lPort1510
		IF !( lRetModo := xRetModo("RFB","RFE",lShowHelp) )
			Break
		Endif
	Endif
	
	IF lPort1510
		IF !( lRetModo := xRetModo("SRA","SP0",lShowHelp) )
			Break
		Endif
	Endif

	IF ( GetMv( "MV_SP0SPEM" , NIL , "S" ) == "S" )
		IF !( lRetModo := xRetModo("SPE","SP0",lShowHelp) )
			Break
		EndIF
	EndIF
	IF !( lRetModo := xRetModo("SPU","SPV",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SPU","SPX",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SPY","SPZ",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := ( __nTamP8Ordem == __nTamPGOrdem  ) )
		cMsg := STR0157	//'O Tamanho do Campo P8_ORDEM e diferente do Tamanho do Campo PG_ORDEM'
		cMsg += CRLF
		cMsg += STR0158 //'Contacte o Administrador do Sistema para compatibilizar os campos'
		Break
	EndIF
	lPonChkRel := .F.
End Sequence

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Restaura o Ponteiro do Mouse                                 Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( lShowHelp )
	CursorArrow()
EndIF	

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Se estiver Tudo Ok nao verifica Novamente					   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( ( lPonChkRel := !( lRetModo ) ) .and. !Empty( cMsg ) )
	IF ( lShowHelp )
		MsgInfo( OemToAnsi( cMsg ) , OemToAnsi( STR0158 ) )	//  'Aten┤└o!'
	EndIF
EndIF

Return( lRetModo )

/*/Apenas para Compatibilizacao com Versoes Anterior*/
Function Classifica( aMarcacoes , aTabCalend  )       
Return( PutOrdMarc( aMarcacoes , aTabCalend ) )

/*/
зддддддддддбддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁPutOrdMarc  Ё Autor ЁMarinaldo de Jesus    Ё Data Ё23/05/2001Ё
цддддддддддеддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁCarrega as Ordens no Array a Marcacoes de Acordo com o  CalenЁ
Ё          Ёdario de Marcacoes.                                          Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁPutOrdMarc( @aMarcacoes , aTabCalend )						 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁaMarcacoes -> Array com as Marcacoes do Periodo    		     Ё
Ё          ЁaTabCalend -> Calendario de Marcacoes do Periodo   		     Ё
Ё          ЁlNotFlag   -> Exclui os Flags de Marcacao forcando o ReapontaЁ
Ё          Ё              mento.										 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                                                  	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁApontamento                                                  Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PutOrdMarc( aMarcacoes , aTabCalend , lNotFlag, lAjustMarc, dPerIni, dPerFim, cFil, cMat )

Local aJaProc		:= {} 
Local aMarNextPer   := {}
Local aTabClone		:= {}
Local aOrd			:= {}   
Local aDataApo		:= {}
Local cSpaceOrd		:= Space( __nTamP8Ordem )

Local bSemOrdem
Local bNoFlag
Local cOrd 
Local dDataApo 
Local cOrdAnt	:= ""  
Local cTurnoAnt	:= ""
Local cSeqAnt	:= ""  
Local dDataAnt  := Ctod("")
Local cMarc
Local cTno
Local cSeq
Local cSpacePer
Local cPerAponta  
Local cPerAnt
Local cUltOrdem  
Local cChave 
Local dDataOrd	:=Ctod(Space(8))
Local nPosUltOrdem
Local nTab
Local nVezTab
Local nMar 
Local nMar1 
Local nPrimMarc
Local nMarcSemOrdem	:= 0  
Local nOrd			:= 0
Local nVezMar
Local nVezMar1
Local nSvTab
Local nQtde
Local nHours      
Local nHoursTot	:= 0      
Local nPosDt
Local nTamPer

DEFAULT lNotFlag		:= .F.   
DEFAULT lAjustMarc   	:= .F.
DEFAULT dPerIni			:= Ctod("//")
DEFAULT dPerFim			:= Ctod("//")
DEFAULT cFil			:= SRA->RA_FILIAL
DEFAULT cMat			:= SRA->RA_MAT

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Obtem o Tamanho do campo P8_PAPONTA						   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
nTamPer := GetSx3Cache( "P8_PAPONTA" , "X3_TAMANHO" )
DEFAULT nTamPer := 16
cSpacePer := Space( nTamPer )


/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Desflega  Marcacoes Apontados conforme lNotFlag			   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/		  
bNoFlag :=	 { 	|x|   IF( lNotFlag , ( x[AMARC_APONTA] := "N" ) , NIL );		//Desflega Apontamento conforme lNotFlag
		 	 }

Begin Sequence

	IF ( Empty( aMarcacoes ) .or. Empty( aTabCalend ) )
		Break
	EndIF
	
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁObtem o Numero de Elementos do Calendario de Marcacoes        Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	nVezTab := Len( aTabCalend )

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁObtem o Periodo de Apontamento Conforme Calenario de MarcacoesЁ
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	cPerAponta		:= Dtos( aTabCalend[ 01 , CALEND_POS_DATA ] )
	cUltOrdem		:= aTabCalend[ nVezTab	, CALEND_POS_ORDEM	]
	nPosUltOrdem    := aScan( aTabCalend , { |x| ( x[ CALEND_POS_ORDEM ] == cUltOrdem  ) .and. ( x[CALEND_POS_TIPO_MARC] == "1E" ) } )
	cPerAponta		+= Dtos( aTabCalend[ nPosUltOrdem , CALEND_POS_DATA ] )

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Obtem o HorMais e HorMenos                                   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	For nTab := 1 To nVezTab
		IF ( Empty( cOrd ) .or. ( cOrd != aTabCalend[ nTab , CALEND_POS_ORDEM ] ) )
			cOrd := aTabCalend[ nTab , CALEND_POS_ORDEM ]
		EndIF
		IF ( Empty( cTno ) .or. ( cTno != aTabCalend[ nTab , CALEND_POS_TURNO ] ) )
			cTno := aTabCalend[ nTab , CALEND_POS_TURNO ]
		EndIF	
		IF ( Empty( cSeq ) .or. ( cSeq != aTabCalend[ nTab , CALEND_POS_SEQ_TURNO ] ) )
			cSeq := aTabCalend[ nTab , CALEND_POS_SEQ_TURNO ]
		EndIF	                                 
		IF ( Empty( dDataApo) .or. ( dDataApo != aTabCalend[ nTab , CALEND_POS_DATA_APO ] ) )
			dDataApo := aTabCalend[ nTab , CALEND_POS_DATA_APO ]
		EndIF		
		IF !Empty( aTabCalend[ nTab , CALEND_POS_LIM_MARCACAO , 1 ] )
			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Se a Ordem for Diferente da Ordem Lida Anteriormente		   Ё
			Ё recalcula as Horas Trabalhadas para a Ordem				   Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			If (cOrdAnt <> cOrd)
			  cOrdAnt	:= cOrd
			  nHours 	:= 0 
			  aEval( aTabCalend , { |x| IF( x[CALEND_POS_ORDEM] == cOrd , nHours := SomaHoras( nHours , x[CALEND_POS_HRS_TRABA] ) , NIL ) }, nTab )
			  dDataAnt  := dDataApo
			Endif
			cMarc := DataHora2Str( aTabCalend[ nTab , CALEND_POS_LIM_MARCACAO , 1 ] , aTabCalend[ nTab , CALEND_POS_LIM_MARCACAO , 2 ] )
			aAdd( aOrd ,  {	cOrd									,;	//01 - Ordem da Marcacao
					    	cTno									,; 	//02 - Turno da Marcacao
						    IF( Empty( nHours ) , "" , cMarc )		,; 	//03 - String para Comparacao correspondente ao HorMeno/HorMais para Dias Com Horas na Tabela
							aTabCalend[ nTab , CALEND_POS_DATA ] 	,; 	//04 - Data de Referencia da Ordem
							cMarc									,;	//05 - String para Comparacao correspondente ao HorMeno/HorMais para Marcacoes Nao Ordenadas
							cSeq									,;	//06 - Sequencia do Turno
							dDataApo								;	//07 - Data de Apontamento da Marcacao							
					      };
				 )
		EndIF	
		nHoursTot := SomaHoras( nHoursTot , aTabCalend[nTab, CALEND_POS_HRS_TRABA] ) 
	Next nTab
	
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Corre Todas as Marcacoes 									   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	nVezMar := Len( aMarcacoes )
	nVezTab := Len( aOrd )
	nSvTab	:= 1

	For nMar := 1 To nVezMar  
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Limpa Todas as Ordens de Marcacoes nao Infomadas/Modificadas Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	    IF !aMarcacoes[nMar, AMARC_L_ORIGEM] 
	         aMarcacoes[nMar, AMARC_ORDEM]		:= cSpaceOrd 
	         aMarcacoes[nMar, AMARC_DATAAPO]	:= Ctod("")
	    Endif
    	/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Ordena as Marcacoes com Horario no Calendario de Marcacoes   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/   	
		IF !Empty( nHoursTot )
			IF Empty( cMarc := aMarcacoes[ nMar , AMARC_DTHR2STR ] )
				cMarc	:= DataHora2Str( aMarcacoes[ nMar , AMARC_DATA ] , aMarcacoes[ nMar , AMARC_HORA ] )
			EndIF	
			For nTab := nSvTab To nVezTab Step 2
				IF ( ( cMarc >= aOrd[ nTab , 3 ] ) .and. ( cMarc <= aOrd[ nTab + 1 , 3 ] ) )
					IF !( aMarcacoes[ nMar , AMARC_L_ORIGEM ] )
						aMarcacoes[ nMar , AMARC_ORDEM ]:= aOrd[ nTab , 1 ]
						aMarcacoes[ nMar , AMARC_DATAAPO ] 	:= aOrd[ nTab , 7 ]	
					EndIF
					aMarcacoes[ nMar , AMARC_TURNO ] 	:= aOrd[ nTab , 2 ]
					aMarcacoes[ nMar , AMARC_DTHR2STR ]	:= cMarc           
					aMarcacoes[ nMar , AMARC_SEQ 	] 	:= aOrd[ nTab , 6 ]
					nSvTab := nTab
					Exit
				EndIF	
			Next nTab
		Endif
		
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Obtem a Primeira Marcacao sem Ordem						   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/   	
		If Empty( nMarcSemOrdem ) 
		   If Empty( aMarcacoes[nMar, AMARC_ORDEM] )
		      nMarcSemOrdem:= nMar
		   Endif
		Endif
   		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Refaz Status da Marcacao para Reapontar ou Nao			   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		Eval(bNoFlag, aMarcacoes[nMar])
		
	Next nMar

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Ordena as Marcacoes sem Horario no Calendario de Marcacoes   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( !Empty(nMarcSemOrdem) )
	    nMar	:= nMarcSemOrdem
		For nMar := nMarcSemOrdem To nVezMar
			cOrd 		:= ""
			cTno 		:= ""
			cSeq 		:= ""	 
			dDataApo	:= Ctod("")			
			IF ( ( nMar := aScan( aMarcacoes , { |x| Empty( x[AMARC_ORDEM] ) } ) ) == 0 )
				Exit
			EndIF
			IF ( aScan( aJaProc , { |x| x == nMar } ) == 0 )
				aAdd( aJaProc , nMar )
			Else
				Exit
			EndIF	
			For nSvTab := nMar To nVezMar
				IF ( Empty( cOrd ) .and. ( ( nTab := aScan( aOrd , { |x| Empty( x[3] ) .and. x[4] == aMarcacoes[ nMar , AMARC_DATA ] } ) ) > 0 ) )
					IF Empty( cMarc := aMarcacoes[ nMar , AMARC_DTHR2STR ] )
						cMarc := DataHora2Str( aMarcacoes[ nMar , AMARC_DATA ] , aMarcacoes[ nMar , AMARC_HORA ] )
					EndIF	
					cOrd  		:= aOrd[ nTab , 01 ]
					cTno  		:= aOrd[ nTab , 02 ]
					cSeq  		:= aOrd[ nTab , 06 ]  
					dDataApo	:= aOrd[ nTab , 07 ]					
					If nTab >= nVezTab
					     aOrd[ nTab , 03 ] := cMarc
					Else
					     aOrd[ nTab , 03 ] := aOrd[ nTab + 1 , 03 ] := cMarc
					EndIf
				EndIF
				IF Empty( cOrd )
					cOrd 		:= "__NaoOrdenada__"	//Ordem Nao Encontrada
					dDataApo	:= "__NaoOrdenada__"	//Data de Apontamento Nao Encontrada
					IF ( ( nPosDt := aScan( aMarcacoes , { |x| x[ AMARC_DATA ] == aMarcacoes[ nSvTab , AMARC_DATA ] .and. !Empty( x[AMARC_ORDEM] ) } ) ) > 0 )
						IF (;
								(;
									nQtde := 0 ,;
									aEval( aMarcacoes, { |x| IF( x[AMARC_ORDEM] == aMarcacoes[ nPosDt , AMARC_ORDEM ] , nQtde++ , NIL ) } ),;
									( nQtde % 2 > 0 );
								 );
							 )
							cOrd 	:= aMarcacoes[ nPosDt , AMARC_ORDEM 	]
							cTno 	:= aMarcacoes[ nPosDt , AMARC_TURNO 	]
							cSeq 	:= aMarcacoes[ nPosDt , AMARC_SEQ 	  	]  
							dDataApo:= aMarcacoes[ nPosDt , AMARC_DATAAPO 	]
						EndIF
					EndIF
				EndIF
				IF (;
						Empty( aMarcacoes[ nSvTab , AMARC_ORDEM ] ) .and.;
						(;
						 	( aMarcacoes[ nSvTab , AMARC_DATA ] == aMarcacoes[ nMar , AMARC_DATA ] ) .or.;
							(;
								nQtde := 0 ,;
								aEval( aMarcacoes, { |x| IF( x[AMARC_ORDEM] == cOrd , nQtde++ , NIL ) } ),;
								( nQtde % 2 > 0 );
							);
						  );
					 )
					aMarcacoes[ nSvTab , AMARC_ORDEM ] 	:= cOrd
					aMarcacoes[ nSvTab , AMARC_TURNO ] 	:= cTno
					aMarcacoes[ nSvTab , AMARC_SEQ   ] 	:= cSeq  
					aMarcacoes[ nSvTab , AMARC_DATAAPO]	:= dDataApo					
				Else
					Exit
				EndIF    
				/*/
				здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Refaz Status da Marcacao para Reapontar ou Nao			   Ё
				юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				Eval(bNoFlag, aMarcacoes[nMar] )
			Next nSvTab
		Next nMar
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Encaixa as Marcacoes Perdidas                                Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( ( nMar := aScan( aMarcacoes , { |x| ( x[AMARC_ORDEM] == "__NaoOrdenada__" ) } ) ) > 0 )
			For nMar := nMar To nVezMar
				/*/
				здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Despreza Marcacoes ja Ordenadas                              Ё
				юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF !( aMarcacoes[ nMar , AMARC_ORDEM ] == "__NaoOrdenada__" )
					Loop
				EndIF
				IF Empty( cMarc := aMarcacoes[ nMar , AMARC_DTHR2STR ] )
					cMarc := DataHora2Str( aMarcacoes[ nMar , AMARC_DATA ] , aMarcacoes[ nMar , AMARC_HORA ] )
				EndIF
				For nTab := 1 To nVezTab Step 2
					IF ( cMarc >= aOrd[ nTab , 5 ] ) .and. ( cMarc <= aOrd[ nTab + 1 , 5 ] )
						IF !( aMarcacoes[ nMar , AMARC_L_ORIGEM ] )
							aMarcacoes[ nMar , AMARC_ORDEM ]:= aOrd[ nTab , 1 ]
						EndIF
						aMarcacoes[ nMar , AMARC_TURNO ] 	:= aOrd[ nTab , 2 ]  
						aMarcacoes[ nMar , AMARC_DTHR2STR ]	:= cMarc
						aMarcacoes[ nMar , AMARC_SEQ 	] 	:= aOrd[ nTab , 6 ] 
						aMarcacoes[ nMar , AMARC_DATAAPO ] 	:= aOrd[ nTab , 7 ]  						
						Exit
					EndIF
				Next nTab             
 
			Next nMar
		EndIF
	EndIF
	
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Tratamento  de modo a ajustar as marcacoes de saida de jorna Ё
	Ё da que devido a horas extras recairam na ordem seguinte.     Ё
	Ё (Inicialmente para tratamento de extras em jornada continua) Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	If lAjustMarc
	 	/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁReordena Calendario conforme Ordem							  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		aSort( @aMarcacoes , NIL , NIL , { |x,y|	(x[AMARC_ORDEM] + x[AMARC_DTHR2STR] );
									 				<;
									     			(y[AMARC_ORDEM] + y[AMARC_DTHR2STR] );
							     		  };
	 		  )

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Corre Todas as Marcacoes 									   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		nNumMar	:= 0
		cOrdAnt	:= "!!" 
		dDataAnt:= "!!"
		For nMar := 1 To nVezMar
		  	
		  	cOrd	:= aMarcacoes[ nMar , AMARC_ORDEM ] 
	  		dDataApo:= aMarcacoes[ nMar , AMARC_DATAAPO ] 
		  	//-- Se a data da primeira marcacao da ordem for maior ou igual a data final do periodo nЦo considera a 
		  	//-- marcacao pois provavelmente nao foram lidas todas as marcacoes do dia.
		  	If nNumMar == 0 
		  	   	dDataOrd:= aMarcacoes[nMar, AMARC_DATA]
		  	   	If dDataOrd	> dPerFim
		  	   		Loop
		  	   	Endif  
		  	   	
		  	Endif
		  	
			//- Se a ordem mudou  ou se for a Ultima Marcacao
			If ( cOrd <> cOrdAnt ) .or. ( nMar == nVezMar  .and. dDataOrd == aTabCalend[ nPosUltOrdem , CALEND_POS_DATA ])
			   //-- Verifica se houve marcacoes em quantidade impar  para o dia 
			   If (nNumMar % 2) > 0 .or. (  nMar == nVezMar )
			       
			       //-- Obtem as informacoes da ordem anterior a quebra de ordem
		           If ( nMar == nVezMar )
						/*/
						зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Cria array com as marca┤■es do Proximo Periodo 		  	  Ё
						юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			            aMarNextPer	:= {}  
			            aTabClone	:= {}
						GetMarcacoes(	@aMarNextPer				,;	//01 -> Marcacoes dos Funcionarios
										@aTabClone					,;	//02 -> Calendario de Marcacoes
										NIL							,;  //03 -> Tabela Padrao
										NIL							,;  //04 -> Turnos de Trabalho  
										dPerFim+1					,;  //05 -> Periodo Inicial
										dPerFim+7					,;  //06 -> Periodo Final
										cFil						,;  //07 -> Filial
										cMat						,;  //08 -> Matricula 
										NIL							,;	//09 -> Turno
										NIL							,;	//10 -> Sequencia de Turno
										NIL							,;	//11 -> Centro de Custo
										NIL							,;	//12 -> Alias para Carga das Marcacoes
										NIL							,;	//13 -> Se carrega Recno em aMarcacoes
										NIL							,;	//14 -> Se considera Apenas Ordenadas
										NIL							,;  //15 -> Verifica as Folgas Automaticas
										NIL							,;  //16 -> Se Grava Evento de Folga Mes Anterior
										NIL							,;	//17 -> Se Carrega as Marcacoes Automaticas
										NIL							,;	//18 -> Registros de Marcacoes Automaticas que deverao ser Deletados
										NIL							,;	//19 -> Bloco para avaliar as Marcacoes Automaticas que deverao ser Desprezadas
										.F.							,;	//20 -> Se Considera o Periodo de Apontamento das Marcacoes
										.F.							 ;	//21 -> Se Efetua o Sincronismo dos Horarios na Criacao do Calendario
								 	)  

						 /*/
						зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Ordena as marca┤■es                                         Ё
						юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						PutOrdMarc( @aMarNextPer , aTabClone , .T. )   
				  
					    //-- Inicializa contador de quantidade de marcacoes para a ordem
				        nNumMar:= 0 
				        cOrdAnt:=cOrd  
				        dDataAnt:=dDataApo  
				        nVezMar1:= Len(aMarNextPer)
					      
			            //-- Obtem as marcacoes para a primeira ordem do periodo seguinte
			            cOrd	:= "!!" 
			            dDataApo:= "!!"
			            For nMar1 := 1 To nVezMar1        
			                //-- Conta a quantidade de marcacoes para a proxima ordem
			                If ( aMarNextPer[ nMar1 , AMARC_RECNO ] <> aMarcacoes[nMar,AMARC_RECNO])
							    If cOrd == "!!"
			                    	cOrd		:= aMarNextPer[ nMar1 , AMARC_ORDEM ] 
		                    		dDataApo	:= aMarNextPer[ nMar1 , AMARC_DATAAPO ]
			                    	nPrimMarc  	:= nMar1 
			                    Endif
			                    
			                	If aMarNextPer[nMar1, AMARC_ORDEM] == cOrd  
			                   		nNumMar++
			                	Else
			                		Exit
				                Endif
							Endif
			            Next nMar1   
			            
			            //-- Se a quantidade de marcacoes da ordem seguinte for impar
			            //-- Ajusta a primeira marcacao da ordem para a ordem anterior
			            If (nNumMar % 2) > 0  
			                AADD(aMarcacoes, aClone( aMarNextPer[nPrimMarc] ) )
			                //Aeval(aMarNextPer, {|x|  AADD( aMarcacoes[ Len( aMarcacoes ) ], aClone( a ) ) } )
						    //-- Seta aMar
	                        nMar := Len(aMarcacoes)
					    Else
					    	Exit
					    Endif                  

		           Else
					    //-- Inicializa contador de quantidade de marcacoes para a ordem
				        nNumMar:= 0  
			            For nMar1 := nMar To nVezMar        
			                //-- Conta a quantidade de marcacoes para a proxima ordem
			                If aMarcacoes[nMar1, AMARC_ORDEM] == cOrd
			                   nNumMar++
			                Else
			                	  Exit
			                Endif
			            Next nMar1    
                   Endif 
                   
   			       
   			       //-- Se a quantidade de marcacoes da ordem seguinte for impar
		           //-- Ajusta a primeira marcacao da ordem para a ordem anterior
		           If (nNumMar % 2) > 0  
				  	   aMarcacoes[ nMar , AMARC_ORDEM 		] := cOrdAnt
				  	   aMarcacoes[ nMar , AMARC_TURNO 		] := cTurnoAnt  
				  	   aMarcacoes[ nMar , AMARC_PERAPONTA 	] := cPerAnt    
				  	   aMarcacoes[ nMar , AMARC_SEQ 		] := cSeqAnt 
					   aMarcacoes[ nMar , AMARC_DATAAPO 	] := dDataAnt				  	    
				  	   	/*/
						здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Refaz Status da Marcacao para Reapontar ou Nao			   Ё
						юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						Eval(bNoFlag, aMarcacoes[nMar])
					    nNumMar		:= 0    			       
					    cOrdAnt		:= "!!"
					    dDataAnt	:= "!!"
						Loop
				   Endif 
			   Endif    
		       cOrdAnt		:= aMarcacoes[ nMar , AMARC_ORDEM 		]    
		       cTurnoAnt	:= aMarcacoes[ nMar , AMARC_TURNO 		]   
		       cPerAnt		:= aMarcacoes[ nMar , AMARC_PERAPONTA 	]   
		       cSeqAnt		:= aMarcacoes[ nMar , AMARC_SEQ 		] 
		       dDataAnt		:= aMarcacoes[ nMar , AMARC_DATAAPO		]  		       
			   nNumMar		:= 0    			       
			Endif
			
			nNumMar++
		Next nMar

    Endif
    
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Refaz Status da Marcacao em funcao de estar ou nao ordenada  Ё
	Ё e atualiza o periodo de apontamento						   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	PutCposRep( @aMarcacoes,cSpaceOrd,cSpacePer,cPerAponta)
    
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Inclui Data de Apontamento na RFE para as s marcacoes originais  Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	If lPort1510
		RFEDataApo(aMarcacoes , aTabCalend, cFil)		
	EndIf
    
End Sequence
	
Return( NIL )

/*/
зддддддддддбддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁRFEDataApo  Ё Autor ЁLeandro Drumond       Ё Data Ё25/03/2010Ё
цддддддддддеддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁCarrega a Data de Apontamento na tabela RFE de acordo com as Ё
Ё          Ёmarcacoes.                                                   Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁRFEDataApo( aMarcacoes , aTabCalend )						 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁaMarcacoes -> Array com as Marcacoes do Periodo    		     Ё
Ё          ЁaTabCalend -> Calendario de Marcacoes do Periodo   		     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                                                  	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁApontamento                                                  Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RFEDataApo(aMarcacoes , aTabCalend, cFil)

Local cChave  		:= ""
Local cPerAponta	:= ""
Local cUltOrdem     := ""
Local nMar	  		:= 0
Local nPosUltOrdem	:= 0
Local nVezMar 		:= 0
Local nVezTab 		:= 0

DEFAULT cFil		:= SRA->RA_FILIAL

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁObtem o Numero de Elementos do Calendario de Marcacoes        Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
nVezTab := Len( aTabCalend )

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁObtem o Periodo de Apontamento Conforme Calenario de MarcacoesЁ
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
cPerAponta		:= Dtos( aTabCalend[ 01 , CALEND_POS_DATA ] )
cUltOrdem		:= aTabCalend[ nVezTab	, CALEND_POS_ORDEM	]
nPosUltOrdem    := aScan( aTabCalend , { |x| ( x[ CALEND_POS_ORDEM ] == cUltOrdem  ) .and. ( x[CALEND_POS_TIPO_MARC] == "1E" ) } )
cPerAponta		+= Dtos( aTabCalend[ nPosUltOrdem , CALEND_POS_DATA ] )

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Corre Todas as Marcacoes 									   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
nVezMar := Len( aMarcacoes )

RFE->(DbsetOrder(RetOrder("RFE","RFE_FILIAL+RFE_EMPORG+RFE_FILORG+RFE_MATORG+RFE_DHORG+RFE_IDORG")))

For nMar := 1 To nVezMar  

   	If aMarcacoes[ nMar , AMARC_TIPOREG ] == "O"
		cChave:= xFilial("RFE",cFil)				+ ;
				 aMarcacoes[ nMar , AMARC_EMPORG] 	+ ;
				 aMarcacoes[ nMar , AMARC_FILORG]  	+ ;
				 aMarcacoes[ nMar , AMARC_MATORG]  	+ ;
				 aMarcacoes[ nMar , AMARC_DHORG] 	+ ;
				 aMarcacoes[ nMar , AMARC_IDORG]
		If  RFE->( DbSeek(cChave) ) 
			While RFE->( !EOF() ) .and. ;
			      RFE->( RFE_FILIAL+RFE_EMPORG+RFE_FILORG+RFE_MATORG+RFE_DHORG+RFE_IDORG == cChave )
					
				IF	( RFE->RFE_NUMREP == aMarcacoes[ nMar , AMARC_NUMREP 	] ) .and. ;
					( RFE->RFE_RELOGI == aMarcacoes[ nMar , AMARC_RELOGIO  ] )
				
					IF RecLock( 'RFE' , .F. )
						RFE->RFE_DATAAP  := aMarcacoes[ nMar , AMARC_DATAAPO ]
						RFE->RFE_PERAPO  := cPerAponta
						RFE->( MsUnLock() )
					EndIF	
				Endif
				RFE->(Dbskip())
			End While		
		EndIf

   	EndIf
	
Next nMar

Return (NIL)

/*
зддддддддддбддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁPutCposRep  Ё Autor ЁMauricio MR           Ё Data Ё16/10/2009Ё
цддддддддддеддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRefaz Status da Marcacao em funcao de estar ou nao ordenada  Ё
Ё          Ёe atualiza o periodo de apontamento                          Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁPutCposRep( @aMarcacoes,cSpaceOrd,cSpacePer,cPerAponta)		 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁaMarcacoes -> Array com as Marcacoes do Periodo    		     Ё
Ё          ЁcSpaceOrd  -> Inicializador do campo Ordem		   		     Ё
Ё          ЁcSpacePer  -> Inicializador do campo Periodo                 Ё
Ё          ЁcPerAponta -> Periodo de Apontamento 						 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                                                  	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁApontamento                                                  Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
*/

Static Function PutCposRep( aMarcacoes,cSpaceOrd,cSpacePer,cPerAponta)
Local nMarc	:= Len(aMarcacoes)
Local nx	:= 0 

For nx:= 1 to nMarc

	IF ( aMarcacoes[nx, AMARC_ORDEM] == "__NaoOrdenada__" ) //Se Marcacao nao Ordenada
	     aMarcacoes[nx, AMARC_ORDEM		] 		:= cSpaceOrd 		//Preenche a Ordem com Brancos
		 aMarcacoes[nx, AMARC_APONTA	]		:= "N" 				//Desflega Apontamento
		 aMarcacoes[nx, AMARC_PERAPONTA	]		:= cSpacePer 		//Limpa Periodo de Apontamento  
	 	 aMarcacoes[nx, AMARC_DATAAPO	]	    := Ctod("") 		//Limpa Data de Apontamento										
	Else
		aMarcacoes[nx, AMARC_PERAPONTA	] 		:= cPerAponta			//Carrega Periodo de Apontamento
	Endif
         
Next nX
Return (Nil)


/*/
зддддддддддбддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁfTipoExtra  Ё Autor ЁMarinaldo de Jesus    Ё Data Ё31/03/2001Ё
цддддддддддеддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁValida os Tipos de Horas Extras                              Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁfTipoExtra( cTipo , @cDescr )              			 		 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁcTipo     -> Tipo das Horas Extras                     		 Ё
Ё          ЁcDescr 	  -> Descriacao das Horas Extras               		 Ё
Ё          ЁlShowHelp -> Mostrar o Help                            		 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlRet                                                 	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁApontamento                                                  Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fTipoExtra( cTipo , cDescr , lShowHelp )

Local aTipos 		:= Array( 16 , 2 )
Local lRet	 		:= .T.
Local nPos	 		:= 0

DEFAULT cTipo		:= ""
DEFAULT cDescr		:= ""
DEFAULT lShowHelp	:= .T.

aTipos[ 01 , 01 ] :=  "1" ; aTipos[ 01 , 02 ] := STR0070 //'Normal'
aTipos[ 02 , 01 ] :=  "2" ; aTipos[ 02 , 02 ] := STR0071 //'D.S.R.'
aTipos[ 03 , 01 ] :=  "3" ; aTipos[ 03 , 02 ] := STR0072 //'Compensado'
aTipos[ 04 , 01 ] :=  "4" ; aTipos[ 04 , 02 ] := STR0073 //'Feriado'
aTipos[ 05 , 01 ] :=  "5" ; aTipos[ 05 , 02 ] := STR0074 //'Normal Noturna'
aTipos[ 06 , 01 ] :=  "6" ; aTipos[ 06 , 02 ] := STR0075 //'D.S.R. Noturna'
aTipos[ 07 , 01 ] :=  "7" ; aTipos[ 07 , 02 ] := STR0076 //'Compensada Noturna'
aTipos[ 08 , 01 ] :=  "8" ; aTipos[ 08 , 02 ] := STR0077 //'Feriado Noturna'
aTipos[ 09 , 01 ] :=  "A" ; aTipos[ 09 , 02 ] := STR0078 //'Intervalo'
aTipos[ 10 , 01 ] :=  "B" ; aTipos[ 10 , 02 ] := STR0079 //'Intervalo Noturna'
aTipos[ 11 , 01 ] :=  "C" ; aTipos[ 11 , 02 ] := STR0195 //'Intervalo DSR'
aTipos[ 12 , 01 ] :=  "D" ; aTipos[ 12 , 02 ] := STR0196 //'Intervalo Noturna DSR'
aTipos[ 13 , 01 ] :=  "E" ; aTipos[ 13 , 02 ] := STR0197 //'Intervalo Compensado'
aTipos[ 14 , 01 ] :=  "F" ; aTipos[ 14 , 02 ] := STR0198 //'Intervalo Noturna Compensado'
aTipos[ 15 , 01 ] :=  "G" ; aTipos[ 15 , 02 ] := STR0199 //'Intervalo Feriado'
aTipos[ 16 , 01 ] :=  "H" ; aTipos[ 16 , 02 ] := STR0200 //'Intervalo Noturna Feriado'

IF ( lRet := ( ( nPos := aScan( aTipos , { |x| x[1] == cTipo } ) ) > 0 ) )
	cDescr := aTipos[ nPos , 2 ]
ElseIF lShowHelp
	Help(" ",1,"CTIPOHE")
EndIF

Return( lRet )

/*/
зддддддддддбддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGetTabArred	Ё Autor ЁMarinaldo de Jesus    Ё Data Ё12/04/2001Ё
цддддддддддеддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁCarrega as Tabelas de Arredondamentos do SPD                 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGetTabArred( cFil , cTno , cTip )							 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁcFil -> Filial Para a Pesquisa no SP5              		     Ё
Ё          ЁcTno -> Turno  Para a Pesquisa no SP5              		     Ё
Ё          ЁcTip -> Tipo do Arredondamento a Ser Carregado     		     Ё
Ё          Ё        "A" -> Atrasos                             		     Ё
Ё          Ё        "D" -> DSR                                 		     Ё
Ё          Ё        "F" -> Faltas                              		     Ё
Ё          Ё        "H" -> Horas Extras                        		     Ё
Ё          Ё        "N" -> Horas Noturnas                      		     Ё
Ё          Ё        "S" -> Saidas Antecipadas                  		     Ё
Ё          Ё        "9" -> Nona Hora                           		     Ё
Ё          ЁlFullTable -> .T. -> Carrega toda a tabela de Arredondamento Ё
Ё          Ё               para a Filial informada  	       		     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁaCloneTabArr <=> Array Contendo as Tabelas de ArredondamentosЁ
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁApontamento                                                  Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetTabArred( cFil , cTno , cTip, lFullTable )

Local bAscan		:= { || .T. }
Local cKey			:= ""
Local cKeyPesq		:= ""
Local cLenTno		:= ""
Local cTipo			:= ""
Local cAlias		:= "SPD"
Local cAliasQuery	:= cAlias
Local cChave		:= ""
Local lTnoOrFil		:= .T.
Local lAtu			:= .T.    
Local lQueryOpened	:= .F.
Local nArreds		:= 0
Local nTabs			:= 0
Local nPos			:= 0
Local nOrder		:= RetOrdem( "SPD" , "PD_FILIAL+PD_TIPO+PD_TURNO" )
Local nSvOrder		:= SPD->( IndexOrd() ) 

#IFDEF TOP
	Local cPrefixo		:= ( PrefixoCpo( cAlias ) + "_" )
	Local cQuery		:= ""
	Local cSvQuery		:= ""
	Local aSvAlias 		:= GetArea()
	Local nX			:= 0

	Static aSpdFields
	Static cQrySpdFields
	Static nSpdFields
#ENDIF

DEFAULT cTip		:= "ADFHNS9"
DEFAULT cFil		:= SRA->RA_FILIAL
DEFAULT cTno		:= SRA->RA_TNOTRAB
DEFAULT lFullTable	:= .F.  

#IFDEF TOP

	IF !( lExInAs400 )

		cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )

		DEFAULT aSpdFields := ( cAlias )->( dbStruct() )
		DEFAULT nSpdFields := Len( aSpdFields )
	
		IF ( cQrySpdFields == NIL )
			cQrySpdFields := ""
			For nX := 1 To nSpdFields
				cQrySpdFields += aSpdFields[ nX , 01 ] + ", "
			Next nX
		EndIF
		
	EndIF

#ENDIF
                               
cLenTno		:= Space( GetSx3Cache( "PD_TURNO  " , "X3_TAMANHO" ) ) 
cTip		:= StrTran( cTip , " " , "" )
cTipo		:= cTip
cFil		:= xFilial( cAlias , cFil )

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Monta Bloco para Pesquisa dos Tipos de Arredondamento.       Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
baScan		:= { |x| If(  !lFullTable,;
										 ( ( x[1] == cFil ) .or. Empty( x[1] ) )   	;
									  	  .and.								 	   		;
									     ( ( x[2] == cTno ) .or. Empty( x[2] ) )   	;
									     .and.								 	   		;
									     ( x[3] == cTipo ) 						   		,;
								     	 ( ( x[1] == cFil ) .or. Empty( x[1] ) )   	;
						) ;		     	 
		   		}



DEFAULT	__aTabArr	:= {}
DEFAULT	__aTabFilArr:= {}


/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Se foi Selecionado apenas um Determinado Tipo                Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF !lFullTable 
	IF ( nTabs := Len( cTipo ) ) == 1
		IF !Empty( __aTabArr )
			lAtu := ( ( nPos := aScan( __aTabArr , bAscan ) ) == 0 .or. ( nPos > 0 .and. Empty( __aTabArr[nPos , 2] ) ) )
		EndIF
	Else
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Caso contrario Considera Todos os Tipos Validos              Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		cTip := "ADFHNS9"
	EndIF
Else           
    /*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Forca Carregar Todas as Tabelas de Arredondamento da Filial  Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF !Empty( __aTabArr )
			lAtu 	:= ( ( nPos := aScan( __aTabArr , bAscan ) ) == 0  )  
	Endif		
	nTabs	:= 1 
	cTip 	:= "ADFHNS9" 
	cTno	:=  cLenTno  
EndIF

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Se a Tabela de Arredondamento Estiver Vazia ou se for forcadaЁ
Ё uma Atualizacao											   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( Empty( __aTabArr ) .or. ( lAtu ) )
	
	IF !Empty( nTabs )

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Seta a Ordem para Pesquisa                                   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF !( nSvOrder == nOrder )
			SPD->( dbSetOrder( nOrder ) )
		EndIF

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica os Tipos de Arredondamento                          Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		For nArreds := 1 To nTabs
		    
		

			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁVerifica se o Tipo em Questao ja foi Carregado e se possui conЁ
			Ёteudo														   Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/  
			IF !lFullTable 
				cTipo := SubStr( cTip , nArreds , 1 )
				lAtu:= ( ( ( nPos := aScan( __aTabArr , bAscan ) ) == 0 )  .or. ( nPos > 0 .and. Empty( __aTabArr[nPos , 2] ) ) )
			Else	                                 
				cTipo := SPACE(1)
				lAtu:= ( ( nPos := aScan( __aTabArr , bAscan ) ) == 0 )
			Endif
			
			If 	lAtu
				/*/
				здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				ЁSe For TOP						                               Ё
				юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				#IFDEF TOP
					IF !( lExInAs400 )
						/*/
						здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						ЁMonta Query para pesquisa do Turno Especifico                 Ё
						юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						cQuery		:= "SELECT "
						cQuery		+= cQrySpdFields
						cQuery		:= SubStr( cQuery , 1 , Len( cQuery ) - 2 )
						cQuery		+= " FROM "
						cQuery		+= InitSqlName( cAlias )
						cQuery		+= " WHERE "
						cQuery		+= cPrefixo+"FILIAL='"+cFil+"'"
						cQuery		+= " AND " 
						If !lFullTable
							cQuery		+= cPrefixo+"TIPO='"+cTipo+"'"
							cQuery		+= " AND "
							cQuery		+= cPrefixo+"TURNO='"+cTno+"'"
							cQuery		+= " AND "
						Endif	
						cQuery		+= "D_E_L_E_T_=' ' "
						cQuery		+= "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )
						cSvQuery	:= cQuery
						cQuery		:= ChangeQuery( cQuery )
						/*/
						здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						ЁVerifica se conseguiu Montar a Query                          Ё
						юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
							For nX := 1 To nSpdFields
								IF !( aSpdFields[ nX , 02 ] == "C" )
									TcSetField(cAliasQuery,aSpdFields[nX,01],aSpdFields[nX,02],aSpdFields[nX,03],aSpdFields[nX,04])
								EndIF
							Next nX
							
							/*/
							здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
							ЁSe nao achou o Turno Especifico	                           Ё
							юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
							lTnoOrFil := ( cAliasQuery )->( !Eof() )  
							
							IF !( lTnoOrFil )
								( cAliasQuery )->( dbCloseArea() )	
								IF !lFullTable
									/*/
									здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
									ЁMonta Query para pesquisa do Turno Generico ( Em Branco )     Ё
									юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
									cQuery := StrTran( cSvQuery , ( "TURNO='"+cTno+"'" ) , ( "TURNO='"+cLenTno+"'" ) )
									cQuery := ChangeQuery( cQuery )
									/*/
									здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
									ЁVerifica se conseguiu Montar a Query para o Turno Generico    Ё
									юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
									IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
										For nX := 1 To nSpdFields
											IF !( aSpdFields[ nX , 02 ] == "C" )
												TcSetField(cAliasQuery,aSpdFields[nX,01],aSpdFields[nX,02],aSpdFields[nX,03],aSpdFields[nX,04])
											EndIF
										Next nX
										/*/
										здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
										ЁSe nao Existia o Tipo para o Turno Generico (Em Branco)       Ё
										юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
										IF ( nPos == 0 )
											/*/
											здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
											ЁPesquisa o Turno Generico ( Em Branco )                       Ё
											юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
											IF ( cAliasQuery )->( Eof() )
												/*/
												здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
												ЁSe nao Encontrou o Turno Generico, carrega Tabela Vazia       Ё
												юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
												aAdd( __aTabArr , { cFil , cLenTno , cTipo , {} } )
												( cAliasQuery )->( dbCloseArea() )
												Loop
											EndIF
										EndIF
									Else
										/*/
										здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
										ЁCaso contrario Pesquisa Direto no Arquivo                     Ё
										юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
										cAliasQuery := cAlias
									EndIF
								Else
									/*/
									здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
									ЁSe nao Existia o Tipo para o Turno Generico (Em Branco)       Ё
									юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
									IF ( nPos == 0 )
										/*/
										здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
										ЁSe nao Encontrou a Filial, carrega Tabela Vazia       		   Ё
										юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
										aAdd( __aTabArr , { cFil , cLenTno , cTipo , {} } )
										Loop                                                                       
									Endif	
								Endif	
							Endif	
						Else
							/*/
							здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
							ЁCaso contrario Pesquisa Direto no Arquivo                     Ё
							юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
							cAliasQuery := cAlias
						EndIF
					EndIF
				#ENDIF

				IF !( lQueryOpened )
					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					ЁProcura pelo Turno Especifico	 		                       Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/ 
					IF !lFullTable
						cKeyPesq 	:=  cFil + cTipo + cTno 
					Else                                       
						cKeyPesq 	:=  cFil 
					Endif
					
					lTnoOrFil := ( cAliasQuery )->( dbSeek( cKeyPesq ) ) 

					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					ЁSe nao Existe o Turno Especifico procura pelo Generico        Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/ 
					IF !( lTnoOrFil )
						IF !lFullTable
							/*/
							здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
							ЁSe nao Existia o Tipo para o Turno Generico (Em Branco)       Ё
							юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
							IF ( nPos == 0 )
								/*/
								здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
								ЁPesquisa o Turno Generico ( Em Branco )                       Ё
								юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
								IF ( cAliasQuery )->( !dbSeek( cFil + cTipo + cLenTno ) )
									/*/
									здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
									ЁSe nao Encontrou o Turno Generico, carrega Tabela Vazia       Ё
									юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
									aAdd( __aTabArr , ( cAliasQuery )->( { cFil , PD_TURNO , PD_TIPO , {} } ) )
									Loop
								EndIF
							Endif	
						Else
							If ( nPos == 0 )
								/*/
								здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
								ЁSe nao Encontrou a Filial, carrega Tabela Vazia       		   Ё
								юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
								aAdd( __aTabArr , { cFil , cLenTno , cTipo , {} } )
								Loop
							Endif	
						EndIF
					Endif	
                EndIF
				
				/*/
				здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Se Encontrou o Turno e Este ainda nao Esta Carregado         Ё
				юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF ( ( lTnoOrFil ) .or. ( nPos == 0 ) )
				
					If !lFullTable
						/*/
						здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Carrega as Informacoes para o Turno						   Ё
						юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						aAdd( __aTabArr , { cFil , IF( lTnoOrFil , cTno , cLenTno ) , cTipo , {} } )
						nPos := Len( __aTabArr )
	
						/*/
						здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Carrega os Itens para o Turno      						   Ё
						юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						cKey := ( cFil + cTipo + IF( lTnoOrFil , cTno , cLenTno ) )
						While ( cAliasQuery )->( !Eof() .and. PD_FILIAL+PD_TIPO+PD_TURNO == cKey )
						    ( cAliasQuery )->( aAdd( __aTabArr[ nPos , 4 ] , { PD_DE , PD_ATE , PD_HORAS } ) )
							( cAliasQuery )->( dbSkip() )
						End While
                    Else 
						/*/
						здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Carrega todos Itens para Filial      						   Ё
						юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/  
						cKey:= ""
						While ( cAliasQuery )->( !Eof() .and. ( PD_FILIAL == cFil ) )
							If ( cKey <> ( cAliasQuery )->( cFil + PD_TIPO + PD_TURNO )  )
							     cKey := ( cAliasQuery )->( cFil + PD_TIPO + PD_TURNO )  
								/*/
								здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
								Ё Carrega as Informacoes para a Filial + Tipo + Turno		   Ё
								юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
								aAdd( __aTabArr , ( cAliasQuery )->( { cFil , PD_TURNO , PD_TIPO , {} } ) )
								nPos := Len( __aTabArr )								
							Endif	                    
					    	( cAliasQuery )->( aAdd( __aTabArr[ nPos , 4 ] , { PD_DE , PD_ATE , PD_HORAS } ) )
							( cAliasQuery )->( dbSkip() )
						End While
                    Endif
				EndIF

				#IFDEF TOP
					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					ЁSe Montou a Query, Fecha-a                                    Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
						( cAliasQuery )->( dbCloseArea() )
					EndIF
				#ENDIF
				
			EndIF
	
		Next nArreds

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Restaura a Ordem de Entrada         					   	   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF !( nSvOrder == nOrder )
			SPD->( dbSetOrder( nSvOrder ) )
		EndIF

	Else

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Neste Caso nao Foi passado Nenhum Tipo de Arredondamento 	   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		aAdd( __aTabArr , { "" , "" , "" , {} } )

	EndIF
	
EndIF

#IFDEF TOP
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁGarante o Fechamento da Query no retorno da funcao           Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( Select( cAliasQuery ) > 0 )
		( cAliasQuery )->( dbCloseArea() )
	EndIF
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁRestaura dados de Entrada                                    Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	RestArea( aSvAlias )
#EndIF
	
Return( aClone( __aTabArr ) )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁRstGetTabArred	ЁAutorЁMarinaldo de Jesus Ё Data Ё11/03/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁReinicializa as Staticas utilizadas em GetTabArred()       	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RstGetTabArred() 
__aTabArr 		:= 	NIL 
__aTabFilArr	:=  NIL
Return( NIL )

/*/
зддддддддддбддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁRetTabArred	Ё Autor ЁMarinaldo de Jesus    Ё Data Ё10/04/2002Ё
цддддддддддеддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRetorna Tabela de Arredondamento Especifica baseada no  ArrayЁ
Ё          ЁCarregado Atraves de GetTabArred()							 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁRetTabArred( aArreds , cFil , cTno , cTip )					 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁaArreds -> Array com todos as Tabelas de Arredondamentos	 Ё
Ё          ЁcFil 	-> Filial para Procura								 Ё
Ё          ЁcTno	-> Turno  Para a Pesquisa no SP5              		 Ё
Ё          ЁcTipo	-> Tipo do Arredondamento a Ser Carregado     		 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁaArred  -> Tabela com Arredondamento Especifico				 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁApontamento                                                  Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RetTabArred( aArreds , cFil , cTno , cTipo )

Local aArred := {}
Local bAscan := { || .T. }
Local nPosAr := 0

baScan	:= { |x| ( ( x[1] == cFil ) .or. Empty( x[1] ) ) ;
			  	 .and.								 	 ;
			      ( x[2] == cTno )						 ;
			     .and.								 	 ;
			     ( x[3] == cTipo )						 ;
			}

IF ( ( nPosAr := aScan( aArreds , bAscan ) ) == 0 )
	baScan	:= { |x| ( ( x[1] == cFil ) .or. Empty( x[1] ) ) ;
				  	 .and.								 	 ;
				     Empty( x[2] )							 ;
				     .and.								 	 ;
			    	 ( x[3] == cTipo )						 ;
				}
	nPosAr := aScan( aArreds , bAscan )
EndIF

IF ( nPosAr > 0 )
	aArred := aClone( aArreds[ nPosAr , 4 ] )
EndIF

Return( aClone( aArred ) )

/*/
зддддддддддбддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁfArredHoras	Ё Autor ЁMarinaldo de Jesus    Ё Data Ё12/04/2001Ё
цддддддддддеддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁEfetua o Arredondamento de Horas de Acordo com o Array       Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁnHrs   -> Horas Arredondadas                                 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁApontamento                                                  Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fArredHoras(	nHrs		,;	//01 -> Horas a Serem Arredondadas
						aArrs		,;	//02 -> Array com os Arredondamentos
						cTip		,;	//03 ->	Tipo de Horas a Arredondar:"A"trasos ; "D"SR ; "F"altas ; "H"oras Extras ; "N"Horas Noturnas ; "S"aidas Antecipadas
						cFil		,;	//04 -> Filial Para a Pesquisa no SP5
						cTno		,;	//05 -> Turno  Para a Pesquisa no SP5
						lArrdIntegr	 ;	//06 -> Se Arredonda as Horas Integralmente	
					 )
                                                          
Local nArrVal		:= 0
Local nArre			:= 0
Local nLenArre		:= 0

DEFAULT nHrs		:= 0
DEFAULT aArrs		:= {}
DEFAULT cTip		:= ""
DEFAULT cFil		:= SRA->RA_FILIAL
DEFAULT cTno		:= SRA->RA_TNOTRAB
DEFAULT lArrdIntegr	:= .F.

IF ( !Empty( cTip ) .and. Empty( aArrs ) )
	aArrs := ( GetTabArred( cTip , cFil , cTno  )[ 1 , 3 ] )
EndIF

nLenArre := Len( aArrs )
For nArre := 1 To nLenArre
	nArrVal := IF( !( lArrdIntegr ) , SubHoras( nHrs , __NoRound( nHrs , 0 ) ) , nHrs )
	IF (;
			( __NoRound( nArrVal , 2 ) >= __NoRound( aArrs[ nArre , 1 ] , 2 ) );
			.and.;
  	   		( __NoRound( nArrVal , 2 ) <= __NoRound( aArrs[ nArre , 2 ] , 2 ) );
  	   	)	
		IF !( lArrdIntegr )
			nHrs := SomaHoras( __NoRound( nHrs , 0 ) , aArrs[ nArre , 3 ] )
		Else
			nHrs := aArrs[ nArre , 3 ]
		EndIF
		Exit
	EndIF
Next nArre

Return( nHrs )

/*/
зддддддддддбддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGetTabExtra	Ё Autor ЁMarinaldo de Jesus    Ё Data Ё16/04/2001Ё
цддддддддддеддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁCarrega Array com os Tipos de Horas Extras                   Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlRet      -> True se Conseguir Carregar os Tipos de H.E.     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁApontamento                                                  Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetTabExtra(	aTabExtra		,;	//01 -> Array a ser Carregado com os Tipos de H.E.
						cFil			,;	//02 -> Filial para Pesquisa no SP4
						cTno			,;	//03 -> Turno para Pesquisa no SP4
						lTodas			,;	//04 -> Atualizar as Tabelas de Horas Extras
						lShowHelp		,;	//05 -> Mostrar o Help
						lEscalonar		,;	//06 -> Se trata o escalonamento
						nErrorNumber	,;	//07 -> Numero de retorno de erro. 1 - Tabela de HE nao encontrada 2 - Tabela de HE nao configurada corretamente
						cHelp			 ;	//08 -> Mensagem Complementar ao Help ( Retorno por Referencia )
					 )

Local aEscala		:= {}
Local aRetPe		:= {}
Local baScan		:= { || .T. }
Local cAlias		:= "SP4"
Local cAliasQuery	:= cAlias
Local lRet			:= .F.
Local lModFil		:= .F. 
Local lQueryOpened	:= .F.
Local nPos			:= 0
Local nOrder		:= RetOrdem( "SP4" , "P4_FILIAL+P4_TURNO+P4_TIPO" )
Local nSvOrder		:= SP4->( IndexOrd() ) 

#IFDEF TOP
	Local aSvAlias		:= GetArea()
	Local cPrefixo		:= ( PrefixoCpo( cAlias ) + "_" )
	Local cQuery		:= ""
	Local cSvQuery		:= ""
	Local cSvTno		:= ""	
	Local nX			:= 0

	Static aSp4Fields
	Static cQrySp4Fields
	Static nSp4Fields
#ENDIF

DEFAULT cFil			:= SRA->RA_FILIAL
DEFAULT cTno			:= SRA->RA_TNOTRAB
DEFAULT nErrorNumber	:= 0   
DEFAULT lTodas			:= .F.
DEFAULT lShowHelp		:= .F.
DEFAULT lPnmTabHe		:= ExistBlock( "PNMTABHE" )
DEFAULT __aTabEx		:= {}

#IFDEF TOP

	IF !( lExInAs400 )
	
		cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )

		DEFAULT aSp4Fields := ( cAlias )->( dbStruct() )
		DEFAULT nSp4Fields := Len( aSp4Fields )

		IF ( cQrySp4Fields == NIL )
			cQrySp4Fields := ""
			For nX := 1 To nSp4Fields
				cQrySp4Fields += aSp4Fields[ nX , 01 ] + ", "
			Next nX
		EndIF
		
	EndIF		

#ENDIF

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Se o parametro de escalonamento foi passado				  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF !( lEscalonar == NIL )
   __lEscalonamento	:= lEscalonar
Else
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁSe eh a primeira vez ou ocorreu quebra de filial E NAO    foiЁ
	Ёpara escalonar Obtem o parametro de escalonamento			  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( lModFil := ( ( cFilStatic == NIL )  .or. ( cFilStatic != cFil    ) ) )
		__lEscalonamento	:=	NIL
		cFilStatic			:= 	cFil
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁConsiderar Todas as Horas Extras do Dia Para o Escalonamento Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
    	DEFAULTFIL __lEscalonamento := ( SuperGetMv("MV_ACMHEXT",,"N",cFil) == "S" )
	EndIF
EndIF

aTabExtra	:= {}
baScan		:= { |x| ( x[1] == cFil .or. Empty( x[1] ) )	;
					  .and.									;
					 ( x[2] == cTno .or. Empty( x[2] ) )    ;
			   }

cFil := xFilial( cAlias , cFil )

IF ( Empty( __aTabEx ) .or. ( !lTodas .and. ( nPos := aScan( __aTabEx , baScan ) ) == 0 .or. ( nPos > 0 .and. Empty( __aTabEx[ nPos , 2 ] ) ) ) )


	IF !( nOrder == nSvOrder )
		( cAlias )->( dbSetOrder( nOrder ) )
	EndIF

	#IFDEF TOP
		IF !( lExInAs400 )
			cQuery := "SELECT "
			cQuery += cQrySp4Fields
			cQuery := SubStr( cQuery , 1 , Len( cQuery ) - 2 )
			cQuery += " FROM "
			cQuery += InitSqlName( cAlias )
			cQuery += " WHERE "
			cQuery += cPrefixo+"FILIAL='"+cFil+"'"
			cQuery += " AND "
			IF !( lTodas )
				cQuery += cPrefixo+"TURNO='"+cTno+"'"
				cQuery += " AND "
				cSvTno := cTno
			EndIF
			cQuery += "D_E_L_E_T_=' ' "
			cQuery += "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )
			cSvQuery	:= cQuery
			cQuery		:= ChangeQuery( cQuery )
			IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
				For nX := 1 To nSp4Fields
					IF !( aSp4Fields[ nX , 02 ] == "C" )
						TcSetField(cAliasQuery,aSp4Fields[nX,01],aSp4Fields[nX,02],aSp4Fields[nX,03],aSp4Fields[nX,04])
					EndIF
				Next nX
				IF !( lRet := ( cAliasQuery )->( !Eof() ) )
					IF !( lTodas )
						( cAliasQuery )->( dbCloseArea() )
						cTno	:= Space( GetSx3Cache( "P4_TURNO  " , "X3_TAMANHO" ) )
						cQuery	:= StrTran( cSvQuery , ( "TURNO='"+cSvTno+"'" ) , ( "TURNO='"+cTno+"'" ) )
						cQuery	:= ChangeQuery( cQuery )
						IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
							For nX := 1 To nSp4Fields
								IF !( aSp4Fields[ nX , 02 ] == "C" )
									TcSetField(cAliasQuery,aSp4Fields[nX,01],aSp4Fields[nX,02],aSp4Fields[nX,03],aSp4Fields[nX,04])
								EndIF
							Next nX 
							IF ( nPos == 0 )
								IF !( lRet := ( cAliasQuery )->( !Eof() ) )
									( cAliasQuery )->( dbCloseArea() )
								EndIF
							EndIF
						EndIF
					EndIF
				EndIF
	        EndIF
		EndIF	        
	#ENDIF
	
	IF !( lQueryOpened )
	
		cAliasQuery := cAlias
		IF ( lTodas )
			lRet := ( cAliasQuery )->( dbSeek( cFil , .F. ) )
		Else
			IF !( lRet := ( cAliasQuery )->( dbSeek( cFil + cTno ) ) )
				IF ( nPos == 0 )
					lRet := ( cAliasQuery )->( dbSeek( cFil + ( cTno := Space( GetSx3Cache( "P4_TURNO  " , "X3_TAMANHO" ) ) ) ) )
				EndIF
			EndIF
		EndIF
	
	EndIF

	IF ( ( lRet ) .and. ( Select( cAliasQuery ) > 0 ) )
		aAdd( __aTabEx , { cFil , IF( lTodas , "TODAS" , cTno ) , {} } )
		While ( cAliasQuery )->( !Eof() .and. cFil == P4_FILIAL .and. IF( lTodas , lTodas , cTno == P4_TURNO ) )
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁAdiciona a Informacao da Tabela de Hora Extras em Array  auxiЁ
			Ёliar para verificar consistencia da mesma para uso do  escaloЁ
			Ёnamento de horas											  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			( cAliasQuery )->( aAdd( aEscala , { P4_TIPO , P4_DE , P4_ATE ,P4_CODAUT , P4_CODNAUT }  ) )
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁCarrega a Tabela de Horas Extras							  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			( cAliasQuery )->( aAdd( __aTabEx[ Len( __aTabEx ) , 3 ] , { P4_TIPO , P4_DE , P4_ATE ,P4_CODAUT , P4_CODNAUT, P4_PERCENT } ) )
			( cAliasQuery )->( dbSkip() )
		End While

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁSe foi solicitada a interrupcao do processamento ao   ocorrerЁ
		Ёalguma inconsistencia, procedemos com a verificacao da  inconЁ
		Ёsistencia para efeito de escalonamento					      Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( lShowHelp .and. __lEscalonamento )
			IF !( lRet := fVerEscala( aEscala ) )
        		cHelp			:= STR0155	//-- "Tabela de Horas Extras Nao Configurada para Escalonamento"
        		nErrorNumber	:= 2.00		//-- Retorno de erro para a funcao chamadora
	   		EndIF
		EndIF

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁSe Estiver Ok Monta a Tabela de Horas Extras				  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( lRet )
			IF !( lTodas ) 
				baScan := { |x| ( x[1] == cFil .or. Empty( x[1] ) )	;
						  		.and.								;
						 		( x[2] == cTno )					;
				   		  }
				IF ( ( nPos := aScan( __aTabEx , baScan ) ) == 0 )
					baScan := { |x| ( x[1] == cFil .or. Empty( x[1] ) )	;
							  		.and.								;
							 		Empty( x[2] )						;
					   		  }
					nPos := aScan( __aTabEx , baScan )
					
				EndIF		
			EndIF
		EndIF
	EndIF

	#IFDEF TOP
		IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
			( cAliasQuery )->( dbCloseArea() )
		EndIF	
	#EndIF

	IF !( nOrder == nSvOrder )
		( cAlias )->( dbSetOrder( nSvOrder ) )
	EndIF

EndIF

IF ( lTodas .and. ( lRet := !Empty( __aTabEx ) ) )
	aEval( __aTabEx , { |x,y| IF( __aTabEx[y,1] == cFil , aAdd( aTabExtra , aClone( __aTabEx[y,3] ) ) , NIL ) } )
ElseIF ( lRet := ( nPos > 0 ) )
	aTabExtra := aClone( __aTabEx[ nPos , 3 ] )
EndIF

IF ( ( lShowHelp ) .and. !( lRet ) )
    IF !Empty( cHelp )
		HELP(" ",1,"TABHENCAD", , OemToAnsi( cHelp ) , 5 , 0 ) 
	Else
		HELP(" ",1,"TABHENCAD" )
	EndIF
EndIF

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁFornece o numero de erro ao executar a funcao  ( considerandoЁ
Ёque nao ocorreu algum ainda) se nao foi encontrada a   tabelaЁ
Ёde He para a chave de pesquisa (filial e/ou turno).		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF Empty(nErrorNumber)
   nErrorNumber := IF( !( lRet ) , 1 , 0 )
EndIF

#IFDEF TOP
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁGarante o Fechamento da Query no retorno da funcao           Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( Select( cAliasQuery ) > 0 )
		( cAliasQuery )->( dbCloseArea() )
	EndIF	
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁRestaura dados de Entrada                                    Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	RestArea( aSvAlias )
#EndIF

If lRet .And. lPnmTabHe 
	If( ValType( aRetPe := ExecBlock( "PNMTABHE", .F., .F., {lTodas, aTabExtra} ) ) == "A" )
		aTabExtra := aClone(aRetPe)
	EndIf
EndIf

Return( lRet )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁRstGetTabExtra	ЁAutorЁMarinaldo de Jesus Ё Data Ё11/03/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁReinicializa as Staticas utilizadas em GetTabExtra()		Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RstGetTabExtra()

__aTabEx			:= NIL
__lEscalonamento	:= NIL	
cFilStatic			:= NIL

Return( NIL )

/*/
зддддддддддбддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁfTpoExtra   Ё Autor ЁMarinaldo de Jesus   Ё Data Ё28/09/2000Ё
цддддддддддеддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRetorna o Tipo de Horas Extras de Acordo com o Dia          Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁTipo de Hora Extra                                    	    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      		Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Uso      ЁApontamento                                                 Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fTpoExtra(	dData		,;	//Data para pesquisa do Tipo de Hora Extra
					aTabClone	,;	//Copia do Array com o Calendario de Marcacoes
					nPosCalend	 ;	//Indice em aTabCalend
				  )

Local aSvTabsCal
Local cTpExtra
Local nPos

DEFAULT dData		:= Ctod("//")
DEFAULT aTabClone	:= {}
DEFAULT nPosCalend	:= 0

Begin Sequence

	IF !Empty( aTabClone ) .and. IF( Empty( nPosCalend ) , ( nPos := aScan( aTabClone, { |x| x[ CALEND_POS_DATA ] == dData .and. x[ CALEND_POS_TIPO_MARC ] == "1E" } ) ) > 0 ,( nPos:= nPosCalend, .T. ) )
		nPosCalend := nPos
	Else
		aTabClone	:= {}
        /*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Salva o Conteudo do Calendario por Turno        			  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		aSvTabsCal	:= GetTabCal()
        /*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Cria o Calendario para a Data                   			  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( SRA->( CriaCalend(	dData		,;	//01 -> Data Inicial do Periodo
								dData		,;	//02 -> Data Final do Periodo
								RA_TNOTRAB	,;	//03 -> Turno Para a Montagem do Calendario
								RA_SEQTURN	,;	//04 -> Sequencia Inicial para a Montagem Calendario
								aTabPadrao	,;	//05 -> Array Tabela de Horario Padrao
								@aTabClone	,;	//06 -> Array com o Calendario de Marcacoes
								RA_FILIAL	,;	//07 -> Filial para a Montagem da Tabela de Horario
								RA_MAT		,;	//08 -> Matricula para a Montagem da Tabela de Horario
								RA_CC		,;	//09 -> Centro de Custo para a Montagem da Tabela
								NIL    		,;	//10 -> Array com as Trocas de Turno
								NIL     	,;	//11 -> Array com Todas as Excecoes do Periodo
								NIL         ,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
								.F.			,;	//13 -> Se executa a funcao se sincronismo do calendario
								NIL      	 ;	//14 -> Se Forca a Criacao de Novo Calendario
							 );
					);
			)
			IF ( ( nPos := aScan( aTabClone, { |x| x[ CALEND_POS_DATA ] == dData .and. x[ CALEND_POS_TIPO_MARC ] == "1E" } ) ) > 0 )
				nPosCalend := nPos
			EndIF
		EndIF
	EndIF
	
	IF ( nPosCalend > 0 )
		IF ( aTabClone[ nPosCalend , CALEND_POS_APON_FERIAS ] )
			cTpExtra := aTabClone[nPosCalend,CALEND_POS_TP_HE_NT_FER]+"-"+aTabClone[nPosCalend,CALEND_POS_TP_HE_NR_FER]
		Else
			IF ( aTabClone[ nPosCalend , CALEND_POS_FERIADO ] )				//Dia Corresponde a Feriado
				IF ( aTabClone[ nPosCalend , CALEND_POS_EXCECAO ] == "E" )	//Dia Corresponde a Excecao em Feriado
					cTpExtra := aTabClone[nPosCalend,CALEND_POS_TIPO_HE_NOT]+"-"+aTabClone[nPosCalend,CALEND_POS_TIPO_HE_NOR]
				Else
					IF !( aTabClone[ nPosCalend , CALEND_POS_TRAB_FERIADO ] )	//Se nao Trabalha em Feriado
						cTpExtra	:= IF(Empty(aTabClone[ nPosCalend , CALEND_POS_TP_HE_FER_NT ]),"8",aTabClone[ nPosCalend , CALEND_POS_TP_HE_FER_NT ])
						cTpExtra	+= "-"
						cTpExtra	+= IF(Empty(aTabClone[ nPosCalend , CALEND_POS_TP_HE_FER_NR ]),"4",aTabClone[ nPosCalend , CALEND_POS_TP_HE_FER_NR ])
					Else                        //Trabalha em Feriado
						cTpExtra := aTabClone[ nPosCalend , CALEND_POS_TIPO_HE_NOT ] + "-" + aTabClone[ nPosCalend , CALEND_POS_TIPO_HE_NOR ]
					EndIF
				EndIF
			Else
				cTpExtra := aTabClone[ nPosCalend , CALEND_POS_TIPO_HE_NOT ]+"-"+aTabClone[ nPosCalend , CALEND_POS_TIPO_HE_NOR ]
			EndIF
		EndIF
	EndIF

End Sequence
	
cTpExtra := IF( Empty( cTpExtra ) , "5-1" , cTpExtra ) //DEFAULT

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Restaura o Conteudo do Calendario por Turno        		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( aSvTabsCal <> NIL )
	SetTabCal( aSvTabsCal )
EndIF

Return( cTpExtra )

/*/
зддддддддддбддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁfVerEscala	Ё Autor ЁMauricio MR           Ё Data Ё12/11/2002Ё
цддддддддддеддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁConsiste a Tabela de HE para uso com Escalonamento de Horas  Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁfVerEscala( aTabHE )									     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁaTabHE   -> Array de um Turno/Filial a Ser Consistido.		 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlRet     -> True se OK ou .F. se houver inconsistencia       Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁFuncao GetTabExtra()                                         Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function fVerEscala(aTabHE)  

Local aCompara	:= {'1-5','2-6','3-7','4-8','A-B','C-D','E-F','G-H'}  
Local aDiurno	:= {}
Local aNoturno	:= {}
Local cTipo		:= ''
Local cTipoPar	:= ''
Local lRet		:= .T.
Local nLenaTab  := Len(aTabHE)     
Local cTipoAnt	:= ''
Local nDiurno	:= 0
Local nNoturno	:= 0
Local nPos		:= 0
Local nFaixas	:= 0

//-- Percorre todos os tipos de HE
For nFaixas := 1 To nLenaTab
       
    //-- Para cada Tipo lido procura o seu Tipo "Noturno" correspondente     
    cTipo:=aTabHE[nFaixas, 1] 
    
    //-- Despreza Faixas de Tipos ja lidos e Despreza noturnos
    If  (cTipoAnt == cTipo) .OR. (cTipo >'4' .AND. !(cTipo $'ACEG'))
       Loop
    Endif
  
    //-- Se nao encontrou o correspondente Noturno
    If Empty( nPos:= Ascan( aCompara, {|cPar| cTipo == Substr(cPar,1,1) } ) )
       //-- Obtem o proximo
       Loop
    Endif      

    //-- Extrai o noturno correspondente
    cTipoPar:=Substr(aCompara[nPos],-1,1)
    
    //-- Iguala variavel auxiliar que mantera o ultimo tipo lido para evitar processamento desnecessario
    cTipoAnt:=cTipo

    //-- Monta array com as faixas do tipo diurno     
    aDiurno:={}
    nDiurno:=0  
    aEval(aTabHE,{|aTipo| If( aTipo[1] == cTipo, (nDiurno++, aAdd( aDiurno, aTipo )) , Nil ) })
     
    //-- Monta array com as faixas do tipo noturno correspondente
    aNoturno:= {}  
    nNoturno:= 0
    aEval(aTabHE,{|aTipo| If( aTipo[1] == cTipoPar,(nNoturno++, aAdd( aNoturno, aTipo )) , Nil ) })
    
    //-- Verificar se qtde de faixas de valores diurnas e noturnas diferem entre si
    If nDiurno <> nNoturno
       lRet:=.F.
       Exit
    Endif   
                                 
    //-- Percorre Cada uma das faixas do Noturno correspondente
    nPos:=nDiurno
    Do While nPos >0                                          
       //-- Verifica Se existem diferenca entre os Limites Inicial e final em cada faixas correspondente
       If aDiurno[nPos,2] <> aNoturno[nPos,2] .OR. aDiurno[nPos,3] <> aNoturno[nPos,3]
          lRet:=.F.
          Exit
       Endif   
       nPos--
    End While
    
    //-- Se houve diferenca de faixas abandona rotina
    IF ! lRet
       Exit
    Endif
Next nFaixas

Return( lRet )

/*/
зддддддддддбдддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁfFeriado() Ё Autor Ё Marinaldo de Jesus   Ё Data Ё01/06/2001Ё
цддддддддддедддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o Ё Verifica se a Data passada ┌ ou nao um Feriado.            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё fFeriado( cFil, dDate , cDesc )						    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       Ё SIGAPON                                                    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   Ё lRet <=> True se Data Feriado, False se n└o                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ cFil  = Variavel com a Filial do Funcionario.              Ё
Ё          Ё dDate = Data a Ser Verificada no SP3                       Ё
Ё          Ё cDesc = Descricao do Feriado                               Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fFeriado( cFil , dDate , cDesc, dDataIni, dDataFim )

Local aArea		:= {}
Local aSaveArea	:= GetArea()
Local cMesDia	:= ""
Local cAno		:= ""
Local dData		:= ""
Local dDatePos	:= ""
Local lFeriado	:= .F.
Local nOrderDt	:= RetOrdem( "SP3" , "P3_FILIAL+Dtos(P3_DATA)" )
Local nOrderMd	:= RetOrdem( "SP3" , "P3_FILIAL+P3_MESDIA+P3_FIXO" )

DEFAULT dDate				:= dDataBase
DEFAULT dDatePos 			:= dDataBase
DEFAULT cDesc				:= ""
DEFAULT __aFeriadoStatic	:= {}
DEFAULT dDataIni			:= dDate
DEFAULT dDataFim			:= dDate

cDesc := ""
cFil  := xFilial( "SP3" , cFil )
	
IF ( nPosFer := aScan( __aFeriadoStatic , { |x| x[1] == cFil .and. x[2] == dDate } ) ) == 0
	#IFDEF TOP	
		cCondSP3 := "% P3_FILIAL = '"+cFil+"' AND "
		cCondSP3 += " ( ( P3_DATA >= '"+dToS(dDataIni)+"' AND "
		cCondSP3 += " P3_DATA <= '"+dToS(dDataFim)+"' ) OR "
		cCondSP3 += " ( P3_MESDIA >= '"+MesDia(dDataIni)+"' AND "
		cCondSP3 += " P3_MESDIA <= '"+MesDia(dDataFim)+"' AND P3_FIXO = 'S' ) ) %"
						
		cQrySP3 := GetNextAlias()

		BeginSql alias cQrySP3
			SELECT P3_FILIAL, P3_DATA, P3_MESDIA, P3_DESC, P3_FIXO, R_E_C_N_O_ RECNO 
			FROM %table:SP3% SP3
			WHERE
			%exp:cCondSP3% AND SP3.%NotDel%
		EndSql
		
		While (cQrySp3)->(!Eof())
			//-- Se nao for feriado fixo, adiciona pela data cadastrada
			If Empty( (cQrySp3)->(P3_MESDIA) )
				aAdd( __aFeriadoStatic , { (cQrySp3)->(P3_FILIAL) , Stod( (cQrySp3)->(P3_DATA) ) , (cQrySp3)->(P3_DESC) , (cQrySp3)->RECNO, .T. } )			
			//-- Caso contrario, realiza verificacao da data e adiciona no array
			Else
				cAno  := Str( Year(dDataIni), 4 )
				If Year( dDataFim ) > Year( dDataIni )
					dData := Stod( ( cAno + (cQrySp3)->(P3_MESDIA) ) )
					If dData < LastYDate( dDataIni )
						dData := YearSum( dData , 1 )
					EndIf
				Else
					dData := Stod( ( cAno + (cQrySp3)->(P3_MESDIA) ) )
				EndIf
				aAdd( __aFeriadoStatic , { (cQrySp3)->(P3_FILIAL) , dData , (cQrySp3)->(P3_DESC) , (cQrySp3)->RECNO, .T. } )						
			EndIf
			
			(cQrySp3)->( dbSkip() )
			Loop
		End While
		
		(cQrySP3)->(dbCloseArea())	
		
		//-- Verifica se o primeiro dia do periodo esta no array, seta como feriado e posiciona na SP3
		IF ( nPosFer := aScan( __aFeriadoStatic , { |x| x[1] == cFil .and. x[2] == dDate } ) ) > 0
			lFeriado := .T.
			dbSelectArea("SP3")
			SP3->( MsGoto( __aFeriadoStatic[ nPosFer , 04 ] ) )
			cDesc := __aFeriadoStatic[ nPosFer , 03 ]
		Else
			RestArea(aSaveArea)		
		EndIf

		//-- Alimenta os outros dias do periodo no array sendo dias normais
		dDatePos := dDate
		While dDatePos <= dDataFim
			IF ( nPosFer := aScan( __aFeriadoStatic , { |x| x[1] == cFil .and. x[2] == dDatePos } ) ) == 0
				aAdd( __aFeriadoStatic , { cFil , dDatePos , cDesc , 0 , .F. } )
			EndIf
			dDatePos++
			Loop
		End While
        
        //-- Ordena por filial e data
		aSort( __aFeriadoStatic, , , { | x, y | x[1]+dToS(x[2]) < y[1]+dTos(y[2]) } )		

	#ELSE
		aArea := SP3->( GetArea() )
		SP3->( dbSetOrder( nOrderDt ) )
		IF ( lFeriado := SP3->( MsSeek(cFil+DtoS(dDate),.F.) ) )
			SP3->( dbSetOrder( aArea[ 02 ] ) )
		Else
			SP3->( dbSetOrder( nOrderMd ) )
			cMesDia := MesDia( dDate )
			cAno	:= SubStr( AllTrim( Dtos( dDate ) ) , 1 , 4  )
			IF ( lFeriado := SP3->( MsSeek( ( cFil + cMesDia + "S" ) , .F. ) ) )
				cDesc := SP3->P3_DESC
				dDate := Stod( ( cAno + cMesDia ) )
			Else
				SP3->( MsGoto( aArea[ 03 ]  )  )
			EndIF
			SP3->( dbSetOrder( aArea[ 02 ] ) )
		EndIF
		aAdd( __aFeriadoStatic , { cFil , dDate , cDesc , IF( lFeriado , SP3->( Recno() ) , 0 ) , lFeriado } )
		RestArea(aArea)
	#ENDIF
Else
	IF ( lFeriado := __aFeriadoStatic[ nPosFer , 05 ] )
		cDesc := __aFeriadoStatic[ nPosFer , 03 ]
	EndIF
	SP3->( MsGoto( __aFeriadoStatic[ nPosFer , 04 ] ) )
EndIF

Return( lFeriado )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁRstfFeriado		ЁAutorЁMarinaldo de Jesus Ё Data Ё11/03/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁReinicializa as Staticas utilizadas em fFeriado()        	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RstfFeriado()
Return( ( __aFeriadoStatic := NIL ) )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁfDescTno  Ё Autor Ё Marinaldo de Jesus    Ё Data Ё07/06/2001Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o Ё Retorna uma descri┤└o do Turno de Trabalho Solicitado      Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁfDescTno(cFil,cTno)                                         Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁcFil - Filial para Pesquisa                                 Ё
Ё          ЁcTno - Turno para Pesquisa                                  Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fDescTno( cFil , cTno, nTam )

Local cString := Space(50)

DEFAULT nTam	:= 50
cString := Left( fDesc( "SR6" , cTno , "R6_DESC" , nTam , cFil , NIL , .F. ) , nTam )

Return( cString )

/*/
зддддддддддбддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGetDescMarc Ё Autor ЁMarinaldo de Jesus    Ё Data Ё12/06/2001Ё
цддддддддддеддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRetorna a Descricao dos Tipos de Marcacoes                   Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGetDescMarc( cMarca )			              			 	 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁcMarca  -> Tipo de Marcacao                          		 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁcDesc                                                	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                     Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetDescMarc( cMarca )

Local aMarca := Array( 11 , 2 )
Local cDescr := ""
Local nPos	 := 0

DEFAULT cMarca	:= ""

cMarca := StrTran( Upper( Alltrim( cMarca  ) ) , " " , "" )

aMarca[ 01 , 01 ] :=  "1E" ; aMarca[ 01 , 02 ] := STR0080 //'1a. Entrada'
aMarca[ 02 , 01 ] :=  "1S" ; aMarca[ 02 , 02 ] := STR0081 //'1a. Saida  '
aMarca[ 03 , 01 ] :=  "2E" ; aMarca[ 03 , 02 ] := STR0082 //'2a. Entrada'
aMarca[ 04 , 01 ] :=  "2S" ; aMarca[ 04 , 02 ] := STR0083 //'2a. Saida  '
aMarca[ 05 , 01 ] :=  "3E" ; aMarca[ 05 , 02 ] := STR0084 //'3a. Entrada'
aMarca[ 06 , 01 ] :=  "3S" ; aMarca[ 06 , 02 ] := STR0085 //'3a. Saida  '
aMarca[ 07 , 01 ] :=  "4E" ; aMarca[ 07 , 02 ] := STR0086 //'4a. Entrada'
aMarca[ 08 , 01 ] :=  "4S" ; aMarca[ 08 , 02 ] := STR0087 //'4a. Saida  '
aMarca[ 09 , 01 ] :=  "I1" ; aMarca[ 09 , 02 ] := STR0088 //'1o. Intervalo '
aMarca[ 10 , 01 ] :=  "I2" ; aMarca[ 10 , 02 ] := STR0089 //'2o. Intervalo '
aMarca[ 11 , 01 ] :=  "I3" ; aMarca[ 11 , 02 ] := STR0090 //'3o. Intervalo '

IF ( ( nPos := aScan( aMarca , { |x| x[1] == cMarca } ) ) > 0 )
	cDescr := aMarca[ nPos , 2 ]
EndIF

Return( cDescr )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁChk_IdPon Ё Autor ЁMarinaldo de Jesus     Ё Data Ё10/07/2001Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o Ё Consiste os Identificadores de Ponto                       Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁChk_IdPon( Codigo )                                         Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ codigo = codigos da folha                                  Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       Ё SP9                                                        Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function Chk_IdPon()

Local aArea		:= GetArea()
Local aAreaSP9	:= {}
Local cSpaceIdP := Space( GetSx3Cache( "P9_IDPON  " , "X3_TAMANHO" ) ) 
Local cId		:= GetMemVar( "P9_IDPON" )
Local lRet		:= .F.
Local nOrder	:= RetOrdem( "SP9" , "P9_FILIAL+P9_IDPON+P9_CODIGO" )

aAreaSP9 := SP9->( GetArea() )
IF !( aAreaSP9[2] == nOrder )
	SP9->( dbSetOrder( nOrder ) )
EndIF	

IF lRet := SP9->( dbSeek( xFilial("SP9") + cId ) .and. IF( Altera , Recno() # aAreaSP9[3] , .T. ) .and. cId # cSpaceIdP )
	Help(" ",1,"XREPCODFOL")
EndIF

RestArea( aAreaSP9 )
RestArea( aArea	   )

Return( !lRet )

/*/
зддддддддддбддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGetLastApo  Ё Autor ЁMarinaldo de Jesus    Ё Data Ё27/07/2001Ё
цддддддддддеддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRetornar array com os Resultados dos Apontamentos            Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGetLastApo( [ dPerIni ],[ dPerFim ],[ cAlias ],[ aCpos ] )	 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁdPerIni 	-> Periodo Inicial de Apontamento            	 Ё
Ё          ЁdPerFim 	-> Periodo Final   de Apontamento            	 Ё
Ё          ЁcAlias  	-> Alias Para Pesquisa ("SPC" ou "SPH")      	 Ё
Ё          ЁaCpos   	-> Campos Para a Montagem da Query           	 Ё
Ё          ЁlInformado	-> Se considera os Dados Informados    	 		 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁaResult                                              	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                     Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetLastApo( dPerIni , dPerFim , cAlias , aCpos , lInformado )

Local aAreaSPC		:= {}
Local aResult		:= {}
Local aSvAlias		:= GetArea()
Local bSort			:= { || NIL }
Local cFil	    	:= SRA->RA_FILIAL
Local cMat			:= SRA->RA_MAT
Local cFilMat		:= ( cFil + cMat )
Local cAliasQuery	:= ""
Local cPrefixo		:= ""
Local cCpoPD		:= "PD"
Local cCpoQtd		:= "QUANTC"
Local cOrdem		:= ""
Local lSPC			:= .F.
Local lSort			:= .F.
Local lQueryOpened	:= .F.
Local nOrdem		:= 1

//-- Portaria 1.510
Local cTurno  	
Local cSemana	
Local cTipoHE	
Local nPercent	

#IFDEF TOP
	
	Local aStru			:= {}
	Local cIniData		:= ""
	Local cFimData		:= ""
	Local cQuery		:= ""
	Local cQryStru		:= ""
	Local nCpos			:= 0
	Local nX			:= 0
    
	Static aSPCStruct
	Static aSPHStruct
	Static cQrySPCStruct
	Static cQrySPHStruct

	DEFAULT aCpos	:= {}

#ENDIF

DEFAULT dPerIni 	:= Ctod("//")
DEFAULT dPerFim 	:= Ctod("//")
DEFAULT cAlias		:= "SPC"
DEFAULT lInformado	:= .F.  
 
  
cAlias		:= Upper( AllTrim( cAlias ) )
cPrefixo 	:= ( PrefixoCpo( cAlias ) + "_" )
lSPC		:= ( cAlias == "SPC" )
cAliasQuery	:= cAlias
aAreaSPC	:= ( cAlias )->( GetArea() )

//-- Portaria 1.510
DEFAULT __lCpoTurno		:= IF( ( (cAlias)->(FIELDPOS( cPrefixo+"TURNO" 	)) != 0 )  ,.T. , .F. 	)   
DEFAULT __lCpoSemana	:= IF( ( (cAlias)->(FIELDPOS( cPrefixo+"SEMANA" 	)) != 0 )  ,.T. , .F. 	)   
DEFAULT __lCpoTipoHE	:= IF( ( (cAlias)->(FIELDPOS( cPrefixo+"TIPOHE" 	)) != 0 )  ,.T. , .F. 	)   
DEFAULT __lCpoPercent	:= IF( ( (cAlias)->(FIELDPOS( cPrefixo+"PERCENT" 	)) != 0 )  ,.T. , .F. 	)  

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁDefine a Ordem para Pesquisa								   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
cOrdem	:= ( cPrefixo+'FILIAL+' )
cOrdem	+= ( cPrefixo+'MAT+' )
cOrdem	+= ( 'Dtos('+cPrefixo+'DATA'+')+' )
cOrdem	+= ( cPrefixo+'PD+' )
cOrdem	+= ( cPrefixo+'TPMARCA+' )
cOrdem	+= ( cPrefixo+'CC' )
/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁVerifica a Existencia de Indice Fil+Mat+Data... e utiliza-o.  Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
nOrdem	:= RetOrdem( cAlias , cOrdem )

IF ( nOrdem > 1 )
	( cAlias )->( dbSetOrder( nOrdem ) )
Else
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁNa Ausencia do Indice forca a ordenacao					   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	lSort	:= .T.  
	bSort	:= { |x,y|	(;
							x[ARESULT_DTOS_DATA]	+ ;
							x[ARESULT_EVENTO] 		+ ;
							x[ARESULT_TPMARCA] 		+ ;
							x[ARESULT_CC] 			  ;
						);
							 < 					  	  ;
						(;
							y[ARESULT_DTOS_DATA]	+ ;
							y[ARESULT_EVENTO] 		+ ;
							y[ARESULT_TPMARCA] 		+ ;
							x[ARESULT_CC] 		 	  ;
						);
				};

EndIF

IF Empty( dPerIni ) .or. Empty( dPerFim )
	PerAponta( @dPerIni , @dPerFim , NIL , NIL , cFil )
EndIF

#IFDEF TOP

	IF !( lExInAs400 )
	
		DEFAULT aSPCStruct := SPC->( dbStruct() )
		DEFAULT aSPHStruct := SPH->( dbStruct() )
	
		cIniData := Dtos( dPerIni )
		cFimData := Dtos( dPerFim )
		
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Seta apenas os Campos do SPC/SPH que serao Utilizados       Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		aAdd( aCpos , cPrefixo + "FILIAL"  )
		aAdd( aCpos , cPrefixo + "MAT" 	   )
		aAdd( aCpos , cPrefixo + "PD"	   )
		aAdd( aCpos , cPrefixo + "DATA"	   )
		aAdd( aCpos , cPrefixo + "QUANTC"  )
		aAdd( aCpos , cPrefixo + "CC"	   )
		aAdd( aCpos , cPrefixo + "TPMARCA" ) 
		
		IF __lCpoTurno .and. __lCpoSemana .and. __lCpoTipoHE .and. __lCpoPercent
			aAdd( aCpos , cPrefixo + "TURNO" 	)
			aAdd( aCpos , cPrefixo + "SEMANA" 	)
			aAdd( aCpos , cPrefixo + "TIPOHE" 	)
			aAdd( aCpos , cPrefixo + "PERCENT" 	)
		Endif
	
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Quando forcar a carga dos dados Informados				   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( lInformado )
			aAdd( aCpos , cPrefixo + "PDI"	   )
			aAdd( aCpos , cPrefixo + "QUANTI"  )
		EndIF
		
		nCpos := IF( lSPC , Len( aSPCStruct ) , Len( aSPHStruct ) )
		For nX := 1 To nCpos
			IF aScan( aCpos , { |x| x == AllTrim( IF( lSPC , aSPCStruct[ nX , 1 ] , aSPHStruct[ nX , 1 ] ) ) } ) > 0
				aAdd( aStru , aClone( IF( lSPC , aSPCStruct[ nX ] , aSPHStruct[ nX ] ) ) )
				IF ( ( lSPC ) .and. !( cQrySPCStruct == NIL ) ) 
					IF !( aSPCStruct[ nX , 1 ] $ cQrySPCStruct )
						cQrySPCStruct := NIL
					EndIF
				ElseIF !( cQrySPHStruct == NIL )
					IF !( aSPHStruct[ nX , 1 ] $ cQrySPHStruct )
						cQrySPHStruct := NIL
					EndIF
				EndIF
			EndIF
		Next nX
	
		aCpos	:= NIL
		nCpos	:= Len( aStru )
	
		IF ( lSPC )
			IF ( cQrySPCStruct == NIL )
				cQrySPCStruct := ""
				For nX := 1 To nCpos
					cQrySPCStruct += aStru[ nX , 1 ] + ", "
				Next nX
			EndIF
			cQryStru := cQrySPCStruct
		Else
			IF ( cQrySPHStruct == NIL )
				cQrySPHStruct := ""
				For nX := 1 To nCpos
					cQrySPHStruct += aStru[ nX , 1 ] + ", "
				Next nX
			EndIF
			cQryStru := cQrySPHStruct
		EndIF
		
		cQuery	:= "SELECT "
		cQuery	+= cQryStru
		cQuery	:= SubStr( cQuery , 1 , Len( cQuery ) - 2 )
		cQuery	+= " FROM "
		cQuery	+= InitSqlName( cAlias )
		cQuery	+= " WHERE "
		cQuery	+= cPrefixo + "FILIAL='"+cFil+"'"
		cQuery	+= " AND "
		cQuery	+= cPrefixo + "MAT='"+cMat+"'"
		cQuery	+= " AND "
		cQuery	+= cPrefixo + "DATA>='"+cIniData+"'"
		cQuery	+= " AND "
		cQuery	+= cPrefixo + "DATA<='"+cFimData+"'"
		cQuery	+= " AND "
		cQuery	+= "D_E_L_E_T_=' ' "
		cQuery	+= "ORDER BY " + SqlOrder( ( cAlias )->( IndexKey() ) )
		cQuery	:= ChangeQuery(cQuery)
		cAliasQuery += "QRY"
		IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
			For nX := 1 To nCpos
				IF ( aStru[nX,2] <> "C" )
					TcSetField(cAliasQuery,aStru[nX,1],aStru[nX,2],aStru[nX,3],aStru[nX,4])
				EndIF
			Next nX
		EndIF

	EndIF
	
#ENDIF

IF !( lQueryOpened )
	cAliasQuery := cAlias
	( cAliasQuery )->( dbSeek( cFilMat , .F. ) )
EndIF	

While ( cAliasQuery )->( !Eof() .and. ( ( &(cPrefixo+"FILIAL") + &(cPrefixo+"MAT") ) == cFilMat ) )
		
	#IFNDEF TOP
		IF ( cAliasQuery )->( &(cPrefixo+"DATA") < dPerIni .or. &(cPrefixo+"DATA") > dPerFim )
			( cAliasQuery )->( dbSkip() )
			Loop
		EndIF
	#ELSE
		IF !( lQueryOpened )
			IF ( cAliasQuery )->( &(cPrefixo+"DATA") < dPerIni .or. &(cPrefixo+"DATA") > dPerFim )
				( cAliasQuery )->( dbSkip() )
				Loop
			EndIF
		EndIF
	#ENDIF

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Quando forcar a carga dos dados Informados				   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( lInformado )
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Altera o Nome do Campo correspondente ao Evento a ser consideЁ
		Ё rado														   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF !Empty( ( cAliasQuery )->( &(cPrefixo+"PDI") ) )
			cCpoPD := "PDI"
		Else
			cCpoPD := "PD"
		EndIF
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Altera o Nome do Campo correspondente a Quantidade a ser  conЁ
		Ё siderada													   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF !Empty( ( cAliasQuery )->( &(cPrefixo+"QUANTI") ) )
			cCpoQtd := "QUANTI"
		Else
			cCpoQtd := "QUANTC"
		EndIF	
	EndIF
	
	IF __lCpoTurno .and. __lCpoSemana .and. __lCpoTipoHE .and. __lCpoPercent
		cTurno	:= 	( cAliasQuery )->( &(cPrefixo+"TURNO"	) )
		cSemana	:= 	( cAliasQuery )->( &(cPrefixo+"SEMANA"	) )
		cTipoHE	:= 	( cAliasQuery )->( &(cPrefixo+"TIPOHE"	) )
		nPercent:= 	( cAliasQuery )->( &(cPrefixo+"PERCENT") )
	Endif
	
	
			
	( cAliasQuery )->( fGeraRes(	@aResult				,; //01 -> Array com os Resultados do Dia
			   						&(cPrefixo+"DATA")		,; //02 -> Data da Geracao
									&(cPrefixo+cCpoQtd)		,; //03 -> Numero de Horas Resultantes
									&(cPrefixo+cCpoPD)		,; //04 -> Codigo do Evento
									&(cPrefixo+"CC")		,; //05 -> Centro de Custo a ser Gravado
									&(cPrefixo+"TPMARCA")	,; //06 -> Tipo de Marcacao
									.F.						,; //07 -> True para Acumular as Horas
									/*cPeriodo	*/			,; //08 -> Periodo de Apuracao
									/*nTole		*/			,; //09 -> Tolerancia
									/*cArred	*/			,; //10 -> Tipo de Arredondamento a Ser Utilizado
									/*lSubstitui*/			,; //11 -> Substitui a(s) Hora(s) Existente(s)
									/*cFuncao	*/			,; //12 -> Funcao  
				  					/*cDepto	*/			,; //13 -> Depto para gravacao
									/*cPosto	*/			,; //14 -> Posto para gravacao
									/*cProcesso	*/			,; //15 -> Periodo para Gravacao
									/*cRoteiro	*/			,; //16 -> Processo para Gravacao
									/*cPerApo	*/			,; //17 -> Periodo para Gravacao
									/*cNumPagto	*/ 			,; //18 -> NumPagto para Gravacao
									cTurno 					,; //19 -> Turno de Trabalho
									cSemana					,; //20 -> Semana/Sequencia do Turno
									cTipoHE					,; //21 -> Tipo de Hora Extra
									nPercent				;  //22 -> Percentual de Valorizacao			
							  );
				  	 )

	( cAliasQuery )->( dbSkip() )

End While

IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
	( cAliasQuery )->( dbCloseArea() )
	dbSelectArea( cAlias )				//Restaura Arquivo Original
EndIF	

( cAlias )->( dbSetOrder( aAreaSPC[ 02 ] ) )

RestArea( aSvAlias )

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Ordena aResult para Acumulados pois nao Existe o Indice 02   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( lSort )
	aSort( @aResult , NIL , NIL , bSort ) 
EndIF
		
Return( aResult )

/*/
зддддддддддбдддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁfEventos   Ё Autor Ё Marinaldo de Jesus   Ё Data Ё23/08/2001Ё
цддддддддддедддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁListBox com a Selecao dos Eventos do Ponto                  Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁfEventos( cCampo , l1Elem )			    					Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   Ё.T. por ser Utilizado em Validacao                          Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ cCampo 	- Campo Chave                                   Ё
Ё          Ё l1Elem 	- Se deve Mostrar Apenas 1 Elemento             Ё
Ё          Ё cPreSelect	- Eventos que ja foram Selecionados             Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fEventos( cCampo , l1Elem , cPreSelect )

Local aPreSelect	:= {}
Local aEventos		:= {}
Local cTitulo		:= ""
Local cFilSP9		:= xFilial( "SP9" )
Local cFilSRV		:= xFilial( "SRV" )
Local cMvPar		:= &( Alltrim( ReadVar() ) )
Local cMvParDef		:= ""
Local cMvRetor		:= ""
Local cMvParam		:= ""
Local cReplicate	:= ""
Local nFor			:= 0
Local nLenFor		:= Len( AllTrim( cMvPar ) )
Local nTamCpo		:= 0

DEFAULT l1Elem 			:= .F.
DEFAULT cCampo 			:= "P9_CODIGO"
DEFAULT cPreSelect		:= ""

cCampo		:= Upper( AllTrim( cCampo ) )
nTamCpo		:= GetSx3Cache( cCampo , "X3_TAMANHO" )
cReplicate  := Replicate( "*" , nTamCpo )

CursorWait()

	IF !( l1Elem )
		nLenFor := Len( AllTrim( cMvPar ) )
		For nFor := 1 To nLenFor
			cMvParam += SubStr( cMvPar , nFor , nTamCpo )
			cMvParam += cReplicate
		Next nFor
	EndIF
	cMvPar := cMvParam
	
	IF ( Empty( __aEvefEve__ ) )
		SP9->( dbSetOrder( RetOrdem( "SP9" , "P9_FILIAL+" + cCampo ) ) )
		__aEvefEve__	:= BldafEventos( cFilSP9 , cCampo , cFilSRV )
	EndIF	
	
	nLenFor := Len( cPreSelect )
	For nFor := 1 To Len( cPreSelect ) Step nTamCpo
		aAdd( aPreSelect , SubStr( cPreSelect , nFor , nTamCpo ) )
	Next nFor
	
	nLenFor := Len( __aEvefEve__ )
	For nFor := 1 To nLenFor
		IF ( aScan( aPreSelect , SubStr( __aEvefEve__[ nFor ] , 1 , nTamCpo ) ) == 0 )
			cMvParDef += SubStr( __aEvefEve__[ nFor ] , 1 , nTamCpo )
			aAdd( aEventos , __aEvefEve__[ nFor ] )
		EndIF
	Next nFor

CursorArrow()
	
IF f_Opcoes( @cMvPar , cTitulo , aEventos , cMvParDef , 12 , 49 , l1Elem , nTamCpo , 10 )

	CursorWait()

		nLenFor := Len( cMvPar )
		For nFor := 1 To nLenFor Step nTamCpo
			IF ( SubStr( cMvpar , nFor , nTamCpo ) # cReplicate )
				cMvRetor += SubStr( cMvPar , nFor , nTamCpo )
			EndIF
		Next nFor

		&( Alltrim( ReadVar() ) ) := AllTrim( cMvRetor )

	CursorArrow()

EndIF
	
Return( .T. )

/*/
зддддддддддбддддддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁBldafEventos  Ё Autor ЁMarinaldo de Jesus     Ё Data Ё12/09/2003Ё
цддддддддддеддддддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁCarregar os Eventos do SP9 conforme Filial                    	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁcFilSP9 - Filial do SP9											Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁaEventos - Array com a String de Codigo + Descricao do Evento   Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function BldafEventos( cFilSP9 , cCampo , cFilSRV )

Local aArea		:= GetArea()
Local aQuery	:= {}
Local aEventos	:= {}
Local bAscan	:= { |x| ( x == cCpoDes ) } 
Local bSkip		:= { || .F. }
Local cCntCpo	:= ""
Local cCpoDes	:= ""
Local nOrdSrv	:= 0

Begin Sequence

	IF ( SP9->( FieldPos( cCampo ) ) == 0 )
		Break
	EndIF

	IF ( cCampo == "P9_CODFOL" )
		nOrdSrv := RetOrdem( "SRV" , "RV_FILIAL+RV_COD" )
		bSkip	:= { || (;
							cCpoDes := (;
											( cCntCpo := &( cCampo ) )	+ ;
											" - "						+ ;
											PosSRV( cCntCpo , cFilSRV , "RV_DESC" , nOrdSrv , .F. );
									    );
						),;
						IF( aScan( aEventos , bAscan ) == 0 .and. !Empty( cCntCpo ),;
							aAdd( aEventos , cCpoDes ),;
							NIL;
						  ),;
						 (;
						 	cCntCpo	:= "" ,;
						 	.F.;
						 );
				  }
	Else
		bSkip	:= { || (;
							cCpoDes := (;
											( cCntCpo := &( cCampo ) )	+ ;
											" - "						+ ;
											P9_DESC						  ;
										);
						 ),;
						 IF( aScan( aEventos , bAscan ) == 0 .and. !Empty( cCntCpo ),;
						 	 aAdd( aEventos , cCpoDes ),;
						 	 NIL;
						 	),;
						 (;
						 	cCntCpo	:= "" ,;
						 	.F.;
						 );	
					}
	EndIF

	#IFDEF TOP
		aQuery		:= Array( 03 )
		aQuery[01]	:= "P9_FILIAL='"+cFilSP9+"'"
		aQuery[02]	:= " AND "
		aQuery[03]	:= "D_E_L_E_T_=' ' "
	#ENDIF

	SP9->( GdBuildCols(	NIL				,;	//01 -> Array com os Campos do Cabecalho da GetDados
						NIL				,;	//02 -> Numero de Campos em Uso
						NIL				,;	//03 -> [@]Array com os Campos Virtuais
						NIL				,;	//04 -> [@]Array com os Campos Visuais
						NIL				,;	//05 -> Opcional, Alias do Arquivo Carga dos Itens do aCols
						{				 ;
							"P9_FILIAL"	,;
							cCampo		,;
							"P9_DESC"	 ;
						}				,;	//06 -> Opcional, Campos que nao Deverao constar no aHeader
						NIL				,;	//07 -> [@]Array unidimensional contendo os Recnos
						"SP9"			,;	//08 -> Alias do Arquivo Pai
						cFilSP9			,;	//09 -> Chave para o Posicionamento no Alias Filho
						NIL				,;	//10 -> Bloco para condicao de Loop While
						bSkip			,;	//11 -> Bloco para Skip no Loop While
						.F.				,;	//12 -> Se Havera o Elemento de Delecao no aCols 
						.F.				,;	//13 -> Se Sera considerado o Inicializador Padrao
						.F.				,;	//14 -> Opcional, Carregar Todos os Campos
						.F.				,;	//15 -> Opcional, Nao Carregar os Campos Virtuais
						aQuery			,;	//16 -> Opcional, Utilizacao de Query para Selecao de Dados
						.F.				,;	//17 -> Opcional, Se deve Executar bKey  ( Apenas Quando TOP )
						.T.				,;	//18 -> Opcional, Se deve Executar bSkip ( Apenas Quando TOP )
						.F.				,;	//19 -> Carregar Coluna Fantasma e/ou BitMap ( Logico ou Array )
						.T.				,;	//20 -> Inverte a Condicao de aNotFields carregando apenas os campos ai definidos
						.F.				,;	//21 -> Verifica se Deve Checar se o campo eh usado
						.F.				,;	//22 -> Verifica se Deve Checar o nivel do usuario
						.F.				 ;	//23 -> Verifica se Deve Carregar o Elemento Vazio no aCols
					   );
		  )

End Sequence

RestArea( aArea )

Return( aClone( aEventos ) )

/*/
зддддддддддбддддддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁRstfEventos   Ё Autor ЁMarinaldo de Jesus     Ё Data Ё11/09/2003Ё
цддддддддддеддддддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁReinicializa as Statics em RstfEventos()                       	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL																Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RstfEventos()
Return( ( __aEvefEve__ := {} ) )

/*/
зддддддддддбддддддддддддбддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGetMarcacoesЁAutor Ё Marinaldo de Jesus   Ё Data Ё25/08/2001Ё
цддддддддддеддддддддддддаддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRetornar Array aMarcacoes com as Marcacoes do Periodo       Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGetMarcacoes(@aMarcacoes,[@]aTabCalend...)					Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁPonto Eletronico                                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlGetMarcOk                         							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ < Vide Parametros Formais >								Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetMarcacoes(	aMarcacoes			,;	//01 -> Marcacoes dos Funcionarios
						aTabCalend			,;	//02 -> Calendario de Marcacoes
						aTabPadrao			,;	//03 -> Tabela Padrao
						aTurnos				,;	//04 -> Turnos de Trabalho
						dPerIni 			,;	//05 -> Periodo Inicial
						dPerFim				,;	//06 -> Periodo Final
						cFil				,;	//07 -> Filial
						cMat				,;	//08 -> Matricula
						cTno				,;	//09 -> Turno
						cSeq				,;	//10 -> Sequencia de Turno
						cCc					,;	//11 -> Centro de Custo
						cAlias				,;	//12 -> Alias para Carga das Marcacoes
						lRecno				,;	//13 -> Se carrega Recno em aMarcacoes
						lOrdem				,;	//14 -> Se considera Apenas Ordenadas
						lDiasFolga			,;  //15 -> Verifica as Folgas Automaticas
						lGrvFolgPa  		,;  //16 -> Se Grava Evento de Folga Mes Anterior
						lGetMarcAuto		,;	//17 -> Se Carrega as Marcacoes Automaticas
						aRecsMarcAut	    ,;	//18 -> Registros de Marcacoes Automaticas que deverao ser Desprezadas
						bCondMarcAut		,;	//19 -> Bloco para avaliar as Marcacoes Automaticas que deverao ser Desprezadas
						lChkPerAponta		,;	//20 -> Se Considera o Periodo de Apontamento das Marcacoes
						lSncMaMe			,;	//21 -> Se Efetua o Sincronismo dos Horarios na Criacao do Calendario
						lLoadDel			 ;  //22 -> Se carrega as marcacoes desconsideradas (Uso com lPort1510)
					  )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Variaveis de Inicializacao Obrigatoria					  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Local aSvAlias			:= GetArea()
Local lGetMarcOk 		:= .T.
Local lQueryOpened		:= .F.

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Variaveis que serao inicializadas no Corpo da Funcao		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/      

Local cFilMat
Local cFilSPJ	:=xFilial("SPJ")
Local cAliasQuery  
Local cPrefixo
Local cCod036N
Local cPriOrdem
Local cUltOrdem	
Local cAtuOrdem
Local cPerAponta
Local cAntOrdem
Local cPrxOrdem
Local cDtHrAntOrd
Local cDtHrPrxOrd
Local cDtHrLimIni
Local cDtHrLimFim
Local cDtHrAtu
Local cSetOrdem
Local lNotOrdena    
Local nLenMarc
Local nSerMarc
Local nSerIni
Local nSerFim
Local nSvIndexOrd
Local nPosUltOrdem
Local nLenTabCal
Local nPosPrxOrd
Local nPosAntOrd
Local nSetOrder

#IFDEF TOP

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Variaveis de Inicializacao Obrigatoria					  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	Local aGetMarcFields	:= {}

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Variaveis que serao inicializadas no Corpo da Funcao		  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	Local cQryMarcFields
	Local cIniData
	Local cFimData
	Local cQuery
	Local nGetMarcFields
	Local nX

	Static aGetSP8Fields
	Static cQrySP8Fields
	Static cQrySPGFields
	Static nGetSP8Fields
	Static aGetSPGFields
	Static nGetSPGFields

#ENDIF

DEFAULT cFil				:= SRA->RA_FILIAL
DEFAULT cMat				:= SRA->RA_MAT
DEFAULT cTno				:= SRA->RA_TNOTRAB
DEFAULT cSeq				:= SRA->RA_SEQTURN
DEFAULT dPerIni				:= Ctod("//")
DEFAULT dPerFim				:= Ctod("//")
DEFAULT aTabPadrao			:= {}
DEFAULT aTabCalend			:= {}
DEFAULT aTurnos				:= {}
DEFAULT cAlias				:= "SP8"
DEFAULT lRecno				:= .T.
DEFAULT lOrdem				:= .F.
DEFAULT lDiasFolga			:= .F.
DEFAULT lGrvFolgPa			:= .F.
DEFAULT lGetMarcAuto		:= .T.
DEFAULT bCondMarcAut		:= { || .T. }
DEFAULT lChkPerAponta		:= .T.
DEFAULT lSncMaMe			:= .T.
DEFAULT lLoadDel			:= .F.

aRecsMarcAut				:= {}

Begin Sequence

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁCarrega o Calendario do Periodo Caso Esteja Vazio            Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF Empty( aTabCalend )
		IF ( Empty( dPerIni ) .or. Empty( dPerFim ) )
			IF !( lGetMarcOk := PerAponta( @dPerIni , @dPerFim , NIL , NIL , cFil ) )
				Break
			EndIF	
		EndIF	
		IF !( lGetMarcOk := CriaCalend(	dPerIni 	,;	//01 -> Data Inicial do Periodo
			  			   			   	dPerFim		,;	//02 -> Data Final do Periodo
								   		cTno		,;	//03 -> Turno Para a Montagem do Calendario
								   		cSeq		,;	//04 -> Sequencia Inicial para a Montagem Calendario
								   		@aTabPadrao	,;	//05 -> Array Tabela de Horario Padrao
								   		@aTabCalend	,;	//06 -> Array com o Calendario de Marcacoes
								   		cFil     	,;	//07 -> Filial para a Montagem da Tabela de Horario
								   		cMat   		,;	//08 -> Matricula para a Montagem da Tabela de Horario
								   		cCc   		,;	//09 -> Centro de Custo para a Montagem da Tabela
								   		@aTurnos	,;	//10 -> Array com as Trocas de Turno
										NIL			,;	//11 -> Array com Todas as Excecoes do Periodo
										NIL			,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
										lSncMaMe	,;	//13 -> Se executa a funcao se sincronismo do calendario
										NIL			 ;	//14 -> Se Forca a Criacao de Novo Calendario
							  		  );
			)
			Break
		EndIF
	ElseIF ( Empty( dPerIni ) .or. Empty( dPerFim ) )
		cPriOrdem		:= aTabCalend[ 01 , CALEND_POS_ORDEM	]
		dPerIni			:= aTabCalend[ 01 , CALEND_POS_DATA		]
		nLenTabCal		:= Len( aTabCalend )
		cUltOrdem		:= aTabCalend[ nLenTabCal , CALEND_POS_ORDEM ]
		nPosUltOrdem    := aScan( aTabCalend , { |x| ( x[ CALEND_POS_ORDEM ] == cUltOrdem  ) .and. ( x[CALEND_POS_TIPO_MARC] == "1E" ) } )
		IF ( nPosUltOrdem > 0 )
			dPerFim := aTabCalend[ nPosUltOrdem , CALEND_POS_DATA ]
		ElseIF !( lGetMarcOk := PerAponta( @dPerIni , @dPerFim , NIL , NIL , cFil ) )
			Break
		EndIF
	EndIF	
	
	cAlias			:= Upper( AllTrim( cAlias ) )
	cAliasQuery 	:= cAlias
	cPrefixo		:= ( PrefixoCpo( cAliasQuery ) + "_" )
	aMarcacoes  	:= {}
	nLenTabCal		:= Len( aTabCalend )
	cPriOrdem		:= aTabCalend[ 01			, CALEND_POS_ORDEM	]
	cUltOrdem		:= aTabCalend[ nLenTabCal	, CALEND_POS_ORDEM	]
	IF ( lChkPerAponta )
		cPerAponta		:= Dtos( aTabCalend[ 01 , CALEND_POS_DATA ] )
		nPosUltOrdem    := aScan( aTabCalend , { |x| ( x[ CALEND_POS_ORDEM ] == cUltOrdem  ) .and. ( x[CALEND_POS_TIPO_MARC] == "1E" ) } )
		cPerAponta		+= Dtos( aTabCalend[ nPosUltOrdem , CALEND_POS_DATA ] )
	EndIF
	cDtHrLimIni		:= DataHora2Str(;
										aTabCalend[ 01 , CALEND_POS_LIM_MARCACAO , 01 ],;
										aTabCalend[ 01 , CALEND_POS_LIM_MARCACAO , 02 ];
									)
	cDtHrLimFim		:= DataHora2Str(;
										aTabCalend[ nLenTabCal , CALEND_POS_LIM_MARCACAO , 01 ],;
										aTabCalend[ nLenTabCal , CALEND_POS_LIM_MARCACAO , 02 ];
									)
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁVerifica os Seriais Apenas Quando Marcacoes nao ordenadas	  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
    IF !( lOrdem )
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁDefine Numero Serial para o Inicio do Periodo        		  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		nSerIni	:= RetSerIni(	aClone( aTabCalend )	,;	//01 -> Copia do Calendario de Marcacoes
								@aTabPadrao				,;	//02 -> Tabela de Horario Padrao
								dPerIni					,;	//03 -> Inicio do Periodo de Apontamento
								dPerFim					,; 	//04 -> Final do Periodo de Apontamento
								cTno					,;	//05 -> Turno de Trabalho
								cSeq					,;	//06 -> Sequencia de Turno
								cFil     				,;	//07 -> Filial do Funcionario
								cMat   					,;	//08 -> Matricula do Funcionario
								cCc   					,;	//09 -> Centro de Custo do Funcionario
								lOrdem		 			 ;	//10 -> Marcacoes Sendo carregadas pela Ordem
					   		)
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁDefine Numero Serial para o Final do Periodo        		  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		nSerFim	:= RetSerFim(	aClone( aTabCalend )	,;	//01 -> Copia do Calendario de Marcacoes
								@aTabPadrao				,;	//02 -> Tabela de Horario Padrao
								dPerIni					,;	//03 -> Inicio do Periodo de Apontamento
								dPerFim					,; 	//04 -> Final do Periodo de Apontamento
								cTno					,;	//05 -> Turno de Trabalho
								cSeq					,;	//06 -> Sequencia de Turno
								cFil     				,;	//07 -> Filial do Funcionario
								cMat   					,;	//08 -> Matricula do Funcionario
								cCc   		 			,;	//09 -> Centro de Custo do Funcionario
								lOrdem		 			 ;	//10 -> Marcacoes Sendo carregadas pela Ordem
					         )
	EndIF
	
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Seleciona o Arquivo de Marca┤■es e Seta a Ordem correspondenЁ
	Ё te:														  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	nSvIndexOrd := ( cAlias )->( IndexOrd() )
	cSetOrdem	:= ""
	IF ( lOrdem )
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁOrdem <=> _FILIAL+_MAT+_ORDEM+_DTOS(_DATA)+STR(_HORA,5,2)	  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		cSetOrdem += cPrefixo+"FILIAL+"
		cSetOrdem += cPrefixo+"MAT+"
		cSetOrdem += cPrefixo+"ORDEM+"
		cSetOrdem += "DTOS("+cPrefixo+"DATA)+"
		cSetOrdem += "STR("+cPrefixo+"HORA,5,2)" 
	Else
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁData  <=> _FILIAL+_MAT+_DTOS(_DATA)+STR(_HORA,5,2)    	  	  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		cSetOrdem += cPrefixo+"FILIAL+"
		cSetOrdem += cPrefixo+"MAT+"
		cSetOrdem += "DTOS("+cPrefixo+"DATA)+"
		cSetOrdem += "STR("+cPrefixo+"HORA,5,2)" 
	EndIF
	nSetOrder	:= RetOrdem( cAlias , cSetOrdem )
	IF !( nSvIndexOrd == nSetOrder )
		( cAlias )->( dbSetOrder( nSetOrder ) )
	EndIF

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Cria array com as marca┤■es do Periodo para o funcion═rio.  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	#IFDEF TOP

		IF !( lExInAs400 )

			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Monta Query para Carga das Marcacoes                         Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF ( cAlias == "SP8" )
				IF ( aGetSP8Fields == NIL )
					aGetSP8Fields	:= (cAlias)->( dbStruct() )
					nGetSP8Fields	:= Len( aGetSP8Fields )
					cQrySP8Fields	:= ""
					For nX := 1 To nGetSP8Fields
		        		cQrySP8Fields += aGetSP8Fields[ nX , 01 ] + ", "
					Next nX
				EndIF
				aGetMarcFields	:= aClone( aGetSP8Fields )
				cQryMarcFields	:= cQrySP8Fields
				nGetMarcFields	:= nGetSP8Fields
			ElseIF ( cAlias == "SPG" )
				IF ( aGetSPGFields == NIL )
					aGetSPGFields	:= (cAlias)->( dbStruct() )
					nGetSPGFields	:= Len( aGetSPGFields )
					cQrySPGFields	:= ""
					For nX := 1 To nGetSPGFields
		        		cQrySPGFields += aGetSPGFields[ nX , 01 ] + ", "
					Next nX
				EndIF	
				aGetMarcFields	:= aClone( aGetSPGFields )
				cQryMarcFields	:= cQrySPGFields
				nGetMarcFields	:= nGetSPGFields
			EndIF
			cIniData	:= Dtos( aTabCalend[ 01			, CALEND_POS_DATA ] - 7 )
			cFimData	:= Dtos( aTabCalend[ nLenTabCal , CALEND_POS_DATA ] + 7 )
			cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )
			cQuery := "SELECT "
			cQuery += cQryMarcFields
			cQuery += "R_E_C_N_O_ RECNO "
			cQuery += " FROM "
			cQuery += InitSqlName(cAlias)
			cQuery += " WHERE "
			cQuery += cPrefixo + "FILIAL='"+cFil+"'"
			cQuery += " AND "
			cQuery += cPrefixo + "MAT='"+cMat+"'"
			cQuery += " AND "
			cQuery += cPrefixo + "DATA>='"+cIniData+"'"
			cQuery += " AND "
			cQuery += cPrefixo + "DATA<='"+cFimData+"'"
			IF ( lChkPerAponta )
				cQuery += " AND "
				cQuery += " ( "
				cQuery +=		cPrefixo + "PAPONTA='"+cPerAponta+"'"
				cQuery += 		" OR "
				cQuery +=		cPrefixo + "PAPONTA='"+Space(Len(cPerAponta))+"'"
				cQuery += " ) "
			EndIF
			cQuery += " AND "
			cQuery += "D_E_L_E_T_=' ' "
			cQuery += "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )
			cQuery := ChangeQuery(cQuery)
			IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
				For nX := 1 To nGetMarcFields
					IF ( aGetMarcFields[ nX , 02 ] <> "C" )
						TcSetField(cAliasQuery,aGetMarcFields[nX,01],aGetMarcFields[nX,02],aGetMarcFields[nX,03],aGetMarcFields[nX,04])
					EndIF
				Next nX
				TcSetField(cAliasQuery,"RECNO","N",10,0)
			Else
				cAliasQuery := cAlias
			EndIF	

		EndIF
			
	#ENDIF

	cFilMat := ( cFil + cMat )

	IF !( lQueryOpened )
		cAliasQuery := cAlias
		( cAliasQuery )->( dbSeek( cFilMat , .F. ) )
	EndIF		


        
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Obtem as Marcacoes validas para o Periodo                    Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	While ( cAliasQuery )->( !Eof() .and. ( &( cPrefixo+"FILIAL+"+cPrefixo+"MAT" ) == cFilMat ) )
        
		//Verifica se deve carregar as marcacoes desconsideradas
		If lPort1510 .and. !lLoadDel
			If ( cAliasQuery )->( &(cPrefixo+"TPMCREP") ) == "D"
				( cAliasQuery )->( dbSkip() )
				Loop
			EndIf
		EndIf
		
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verificando a Ordem das Marcacoes                            Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( lOrdem )
			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Ignora Marcacoes nao Ordenadas                               Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF Empty( cAtuOrdem := ( cAliasQuery )->( &( cPrefixo+"ORDEM" ) ) )
				( cAliasQuery )->( dbSkip() )
				Loop
			EndIF	
			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Obtem String de Data Hora da Marcacao Referente a Ordem AtualЁ
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			cDtHrAtu 	:= ( cAliasQuery )->( DataHora2Str( &( cPrefixo+"DATA" ) , &( cPrefixo+"HORA" ) ) )
			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Ignora Marcacoes Fora dos Limites Considerando a Ordem 	   Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/     
			//-- Verifica a ordem se nao for checar o periodo de apontamento ou
			//-- se for para checar, mas o periodo de apontamento estah vazio (ou seja verifico a ordem pois a 
			//-- checagem do periodo nao consiguirah verificar se a marcacao se encontra entre os limites do periodo)
			IF !( lChkPerAponta ) .OR. ( lChkPerAponta .and. Empty( (cAliasQuery)->( &(cPrefixo+"PAPONTA") ) ) )
				IF (;
						(;
							( cAtuOrdem >= cPriOrdem   ) .and. ( cDtHrAtu < cDtHrLimIni );	//Marcacao de Periodo Posterior
						 ) .or. ;
						 (;
							( cAtuOrdem <= cUltOrdem   ) .and. ( cDtHrAtu > cDtHrLimFim );	//Marcacao de Periodo Anterior
						 );
					)		
					( cAliasQuery )->( dbSkip() )
					Loop
				EndIF
			
				/*/
				здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				ЁSe for a Primeira Ordem, compara Horarios em Relacao ao LimiteЁ
				ЁFinal da Proxima Ordem									   	   Ё
				юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF ( cAtuOrdem == cPriOrdem )
					IF Empty( nPosPrxOrd )
						cPrxOrdem	:= StrZero( ( Val( cAtuOrdem ) + 1 ) , __nTamP8Ordem )
						nPosPrxOrd	:= aScan(;
												aTabCalend , { |x|;
																	( x[ CALEND_POS_ORDEM ] == cPrxOrdem ) .and.;
																	!Empty( x[ CALEND_POS_LIM_MARCACAO , 01 ] ) .and.;
																	( x[ CALEND_POS_TIPO_MARC ] <> "1E" );
														 	  };
									 		)
	                   	IF ( nPosPrxOrd > 0 )
							cDtHrPrxOrd := DataHora2Str(;
															aTabCalend[ nPosPrxOrd , CALEND_POS_LIM_MARCACAO , 01 ],;
															aTabCalend[ nPosPrxOrd , CALEND_POS_LIM_MARCACAO , 02 ];
														)
	    				EndIF
					EndIF
					IF ( nPosPrxOrd > 0 )
						IF ( cDtHrAtu > cDtHrPrxOrd )
							( cAliasQuery )->( dbSkip() )
							Loop
						EndIF
					EndIF	
				EndIF
				/*/
				здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				ЁSe for a Ultima Ordem, compara Horarios em Relacao ao   LimiteЁ
				ЁInicial da Ordem Anterior       							   Ё
				юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF ( cAtuOrdem == cUltOrdem )
					IF Empty( nPosAntOrd )
						cAntOrdem	:= StrZero( ( Val( cAtuOrdem ) - 1 ) , __nTamP8Ordem )
						nPosAntOrd	:= aScan(;
												aTabCalend , { |x|;
																	( x[ CALEND_POS_ORDEM ] == cAntOrdem ).and.; 
																	( x[ CALEND_POS_TIPO_MARC ] == "1E" );
														 	  };
									 		)
						IF ( nPosAntOrd > 0 )
							cDtHrAntOrd := DataHora2Str(;
															aTabCalend[ nPosAntOrd , CALEND_POS_LIM_MARCACAO , 01 ],;
															aTabCalend[ nPosAntOrd , CALEND_POS_LIM_MARCACAO , 02 ];
														)
						EndIF
					EndIF
					IF ( nPosAntOrd > 0 )
						IF ( cDtHrAtu <= cDtHrAntOrd )
							( cAliasQuery )->( dbSkip() )
							Loop
						EndIF
					EndIF	
				EndIF
			Endif	
		Else
			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Ignora Marcacoes Fora dos Limites Considerando o Serial      Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF (;
					( cAliasQuery )->(;
										(;
											nSerMarc := __fDHtoNS( &( cPrefixo+"DATA" ),&( cPrefixo+"HORA" ) );
										);
									  ) < nSerIni;
					.or.;
					( nSerMarc > nSerFim );
				 )
					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Ignora Marcacoes Fora dos Limites Considerando o Serial      Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					( cAliasQuery )->( dbSkip() )
					Loop
			EndIF
		EndIF

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Ignora Marcacoes Fora do Periodo de Apontamento              Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( lChkPerAponta )
			IF ( !Empty( (cAliasQuery)->( &(cPrefixo+"PAPONTA") ) ) .and. ( (cAliasQuery)->( &(cPrefixo+"PAPONTA") ) <> cPerAponta ) )
				( cAliasQuery )->( dbSkip() )
				Loop
			EndIF	
		EndIF

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica se Deve Carregar as Marcacoes Automaticas           Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( !( lGetMarcAuto ) .and. ( cAliasQuery )->( &( cPrefixo+"FLAG" ) == "A" .and. Eval( bCondMarcAut ) ) )
			#IFNDEF TOP
				aAdd( aRecsMarcAut , ( cAliasQuery )->( Recno() ) )
			#ELSE
				IF !( lQueryOpened )
					aAdd( aRecsMarcAut , ( cAliasQuery )->( Recno() ) )
				Else
					aAdd( aRecsMarcAut , ( cAliasQuery )->( RECNO ) )
				EndIF
			#ENDIF
			( cAliasQuery )->( dbSkip() )
			Loop
		EndIF

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Carrega as Marcacoes do Funcionario                          Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		aAdd( aMarcacoes , Array( ELEMENTOS_AMARC ) )
		nLenMarc := Len( aMarcacoes )
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_DATA   ] := &(cPrefixo+"DATA")	)					//01 - Data
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_HORA   ] := &(cPrefixo+"HORA")	)					//02 - Hora
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_ORDEM  ] := &(cPrefixo+"ORDEM")	)				//03 - Ordem
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_FLAG   ] := &(cPrefixo+"FLAG")	)					//04 - Flag
		IF ( lRecno )
			#IFNDEF TOP
				( cAliasQuery )->(aMarcacoes[ nLenMarc , AMARC_RECNO ] := Recno()  		)				//05 - Recno 
			#ELSE
				IF !( lQueryOpened )
					( cAliasQuery )->(aMarcacoes[ nLenMarc , AMARC_RECNO ] := Recno() 	)					//05 - Recno 
				Else                                                                                	
					( cAliasQuery )->(aMarcacoes[ nLenMarc , AMARC_RECNO ] := RECNO		)				//05 - Recno 
				EndIF
			#ENDIF
		Else
			aMarcacoes[ nLenMarc , AMARC_RECNO ] := 0														//05 - Recno
		EndIF
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_TURNO		] := &(cPrefixo+"TURNO")	)			//06 - Turno
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_FUNCAO		] := &(cPrefixo+"FUNCAO")	)			//07 - Funcao 
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_GIRO		] := &(cPrefixo+"GIRO") 	)			//08 - Giro
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_CC			] := &(cPrefixo+"CC")		)			//09 - Centro de Custo
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_APONTA		] := &(cPrefixo+"APONTA")	)			//10 - Flag de Apontamento
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_RELOGIO		] := &(cPrefixo+"RELOGIO")	)			//11 - Relogio
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_TIPOMARC	] := &(cPrefixo+"TPMARCA")	)			//12 - Tipo da Marcacao
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica se a Marcacao sera ordenada                         Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		lNotOrdena := (;
							( aMarcacoes[ nLenMarc , AMARC_FLAG ] $ "M,I" ) .and.;
							!Empty( aMarcacoes[ nLenMarc , AMARC_ORDEM  ] );
					   )		
		aMarcacoes[ nLenMarc , AMARC_L_ORIGEM ] := lNotOrdena												//13 - Logico Origem 
		aMarcacoes[ nLenMarc , AMARC_DTHR2STR ] := DataHora2Str(;                                           
																	aMarcacoes[ nLenMarc , AMARC_DATA ] ,;
																	aMarcacoes[ nLenMarc , AMARC_HORA ]  ;
																)                                           //14 - String de Data/Hora para aSort
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_PERAPONTA	] := &(cPrefixo+"PAPONTA")	)	   		//15 - Periodo de Apontamento
		If lPort1510
			( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_SEQ			] := &(cPrefixo+"SEMANA") 	)
			( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_DATAAPO		] := &(cPrefixo+"DATAAPO") 	)		//25 - Data de Apontamento
			( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_NUMREP		] := &(cPrefixo+"NUMREP") 	)		//26 - Numero do REP
			( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_TPMCREP		] := &(cPrefixo+"TPMCREP")	)		//27 - Tipo de Marcacao no REP
			( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_TIPOREG		] := &(cPrefixo+"TIPOREG")	)		//28 - Tipo de Registro
			( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_MOTIVRG		] := &(cPrefixo+"MOTIVRG")	)		//29 - Motivo da desconsideracao/inclusao
			( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_EMPORG		] := &(cPrefixo+"EMPORG")	)		//31 - Empresa Origem da marcacao
			( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_FILORG		] := &(cPrefixo+"FILORG")	)		//32 - Filial Origem da marcacao
			( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_MATORG		] := &(cPrefixo+"MATORG")	)		//33 - Matricula Origem da marcacao
			( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_DHORG		] := &(cPrefixo+"DHORG")	)		//34 - Data/Hora Origem da marcacao
			( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_IDORG		] := &(cPrefixo+"IDORG")	)       //35 - Identificacao da Origem da marcacao
		EndIf
		( cAliasQuery )->( dbSkip() )
	End While

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Fecha a Query e Seta a Area do Arquivo Original              Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
    IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
    	( cAliasQuery )->( dbCloseArea() )
    	dbSelectArea( cAlias )
    EndIF	

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Restaura a Ordem de Entrada                                  Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF !( nSvIndexOrd == IF( lOrdem , 1 , 2 ) )
		( cAlias )->( dbSetOrder( nSvIndexOrd ) )
	EndIF	

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Verifica as Folgas Automaticas apenas Quando Marcacoes ja  tiЁ
	Ё verem Sido Ordenadas										   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( ( lDiasFolga ) .and. ( lOrdem ) )
		cCod036N := PosSP9("036N",cFil,"P9_CODIGO",2)
		fDiasFolga(aClone(aMarcacoes),@aTabCalend,dPerIni,dPerFim,cCod036N,( cAlias == "SPG" ) , lGrvFolgPa )
	EndIF
	
End Sequence

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Restaura a Area de Entrada                                   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
RestArea( aSvAlias )
	
Return( lGetMarcOk )  


/*/
зддддддддддбддддддддддддбддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGetMarcOPC  ЁAutor Ё Mauricio MR		  Ё Data Ё12/08/2005Ё
цддддддддддеддддддддддддаддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRetornar Array aMarcacoes com as Marcacoes do Periodo       Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGetMarcOpc(@aMarcacoes,...)									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁPonto Eletronico                                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlGetMarcOk                         							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ < Vide Parametros Formais >								Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetMarcOpc(	aMarcacoes			,;	//01 -> Marcacoes dos Funcionarios
						dPerIni 			,;	//02 -> Periodo Inicial
						dPerFim				,;	//03 -> Periodo Final
						cFil				,;	//04 -> Filial
						cMat				,;	//05 -> Matricula
						cTno				,;	//06 -> Turno
						cSeq				,;	//07 -> Sequencia de Turno
						cCc					,;	//08 -> Centro de Custo
						cAlias				,;	//09 -> Alias para Carga das Marcacoes
						lRecno				,;	//10 -> Se carrega Recno em aMarcacoes
						lGetMarcAuto		,;	//11 -> Se Carrega as Marcacoes Automaticas
						aRecsMarcAut	    ,;	//12 -> Registros de Marcacoes Automaticas que deverao ser Desprezadas
						bCondMarcAut		;	//13 -> Bloco para avaliar as Marcacoes Automaticas que deverao ser Desprezadas
					  )
   
/*
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Variaveis de Inicializacao Obrigatoria					  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Local aSvAlias			:= GetArea()
Local lGetMarcOk 		:= .T.
Local lQueryOpened		:= .F.

/*
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Variaveis que serao inicializadas no Corpo da Funcao		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/      
Local cFilMat
Local cAliasQuery  
Local cPrefixo
Local cDtHrLimIni
Local cDtHrLimFim
Local cDtHrAtu
Local cSetOrdem
Local lNotOrdena    
Local nI
Local nLenMarc
Local nSerMarc
Local nSerIni
Local nSerFim
Local nSvIndexOrd
Local nSetOrder

#IFDEF TOP
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Variaveis de Inicializacao Obrigatoria					  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	Local aGetMarcFields	:= {}

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Variaveis que serao inicializadas no Corpo da Funcao		  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	Local cQryMarcFields
	Local cIniData
	Local cFimData
	Local cQuery
	Local nGetMarcFields
	Local nX

	Static aGetSP8Fields
	Static cQrySP8Fields
	Static cQrySPGFields
	Static nGetSP8Fields
	Static aGetSPGFields
	Static nGetSPGFields
#ENDIF

DEFAULT cFil				:= SRA->RA_FILIAL
DEFAULT cMat				:= SRA->RA_MAT
DEFAULT cTno				:= SRA->RA_TNOTRAB
DEFAULT cSeq				:= SRA->RA_SEQTURN
DEFAULT dPerIni				:= Ctod("//")
DEFAULT dPerFim				:= Ctod("//")
DEFAULT cAlias				:= "SP8"
DEFAULT lRecno				:= .T.
DEFAULT lGetMarcAuto		:= .T.
DEFAULT bCondMarcAut		:= { || .T. }

aRecsMarcAut				:= {}

nSerIni := __fDHtoNS( dPerIni-7,00.00 )
nSerFim := __fDHtoNS( dPerFim+7,23.59 )
	
Begin Sequence

	cAlias			:= Upper( AllTrim( cAlias ) )
	cAliasQuery 	:= cAlias
	cPrefixo		:= ( PrefixoCpo( cAliasQuery ) + "_" )
	aMarcacoes  	:= {}

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Seleciona o Arquivo de Marca┤■es e Seta a Ordem correspondenЁ
	Ё te:														  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	nSvIndexOrd := ( cAlias )->( IndexOrd() )
	cSetOrdem	:= ""
	
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁData  <=> _FILIAL+_MAT+_DTOS(_DATA)+STR(_HORA,5,2)    	  	  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	cSetOrdem += cPrefixo+"FILIAL+"
	cSetOrdem += cPrefixo+"MAT+"
	cSetOrdem += "DTOS("+cPrefixo+"DATA)+"
	cSetOrdem += "STR("+cPrefixo+"HORA,5,2)" 

	nSetOrder	:= RetOrdem( cAlias , cSetOrdem )
	IF !( nSvIndexOrd == nSetOrder )
		( cAlias )->( dbSetOrder( nSetOrder ) )
	EndIF

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Cria array com as marca┤■es do Periodo para o funcion═rio.  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	#IFDEF TOP

		IF !( lExInAs400 )

			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Monta Query para Carga das Marcacoes                         Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF ( cAlias == "SP8" )
				IF ( aGetSP8Fields == NIL )
					aGetSP8Fields	:= (cAlias)->( dbStruct() )
					nGetSP8Fields	:= Len( aGetSP8Fields )
					cQrySP8Fields	:= ""
					For nX := 1 To nGetSP8Fields
		        		cQrySP8Fields += aGetSP8Fields[ nX , 01 ] + ", "
					Next nX
				EndIF
				aGetMarcFields	:= aClone( aGetSP8Fields )
				cQryMarcFields	:= cQrySP8Fields
				nGetMarcFields	:= nGetSP8Fields
			ElseIF ( cAlias == "SPG" )
				IF ( aGetSPGFields == NIL )
					aGetSPGFields	:= (cAlias)->( dbStruct() )
					nGetSPGFields	:= Len( aGetSPGFields )
					cQrySPGFields	:= ""
					For nX := 1 To nGetSPGFields
		        		cQrySPGFields += aGetSPGFields[ nX , 01 ] + ", "
					Next nX
				EndIF	
				aGetMarcFields	:= aClone( aGetSPGFields )
				cQryMarcFields	:= cQrySPGFields
				nGetMarcFields	:= nGetSPGFields
			EndIF
			cIniData	:= Dtos( dPerIni-7 )
			cFimData	:= Dtos( dPerFim+7 )
			cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )
			cQuery := "SELECT "
			cQuery += cQryMarcFields
			cQuery += "R_E_C_N_O_ RECNO "
			cQuery += " FROM "
			cQuery += InitSqlName(cAlias)
			cQuery += " WHERE "
			cQuery += cPrefixo + "FILIAL='"+cFil+"'"
			cQuery += " AND "
			cQuery += cPrefixo + "MAT='"+cMat+"'"
			cQuery += " AND "
			cQuery += cPrefixo + "DATA>='"+cIniData+"'"
			cQuery += " AND "
			cQuery += cPrefixo + "DATA<='"+cFimData+"'"
			//?-Implementado o tratamento do PAPONTA
			cQuery += " AND ("
			cQuery += cPrefixo + "PAPONTA='"+Space(Len(SP8->P8_PAPONTA))+"'"
			cQuery += " OR "
			cQuery += cPrefixo + "PAPONTA='"+DTOS(dPerIni)+DTOS(dPerFim)+"')"
			
			cQuery += " AND "
			cQuery += "D_E_L_E_T_=' ' "
			cQuery += "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )
			cQuery := ChangeQuery(cQuery)
			IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
				For nX := 1 To nGetMarcFields
					IF ( aGetMarcFields[ nX , 02 ] <> "C" )
						TcSetField(cAliasQuery,aGetMarcFields[nX,01],aGetMarcFields[nX,02],aGetMarcFields[nX,03],aGetMarcFields[nX,04])
					EndIF
				Next nX
			Else
				cAliasQuery := cAlias
			EndIF	

		EndIF
			
	#ENDIF

	cFilMat := ( cFil + cMat )

	IF !( lQueryOpened )
		cAliasQuery := cAlias
		( cAliasQuery )->( dbSeek( cFilMat , .F. ) )
	EndIF		

	/*/       
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Obtem as Marcacoes validas para o Periodo                    Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	While ( cAliasQuery )->( !Eof() .and. ( &( cPrefixo+"FILIAL+"+cPrefixo+"MAT" ) == cFilMat ) )

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Ignora Marcacoes Fora dos Limites Considerando o Serial      Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF (;
				( cAliasQuery )->(;
									(;
										nSerMarc := __fDHtoNS( &( cPrefixo+"DATA" ),&( cPrefixo+"HORA" ) );
									);
								  ) < nSerIni;
				.or.;
				( nSerMarc > nSerFim );
			 )
			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Ignora Marcacoes Fora dos Limites Considerando o Serial      Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			( cAliasQuery )->( dbSkip() )
			Loop
		EndIF
	
		/*/   
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica se Deve Carregar as Marcacoes Automaticas           Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( !( lGetMarcAuto ) .and. ( cAliasQuery )->( &( cPrefixo+"FLAG" ) == "A" .and. Eval( bCondMarcAut ) ) )
			#IFNDEF TOP
				aAdd( aRecsMarcAut , ( cAliasQuery )->( Recno() ) )
			#ELSE
				IF !( lQueryOpened )
					aAdd( aRecsMarcAut , ( cAliasQuery )->( Recno() ) )
				Else
					aAdd( aRecsMarcAut , ( cAliasQuery )->( RECNO ) )
				EndIF
			#ENDIF
			( cAliasQuery )->( dbSkip() )
			Loop
		EndIF

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Carrega as Marcacoes do Funcionario                          Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		aAdd( aMarcacoes , Array( ELEMENTOS_AMARC ) )
		nLenMarc := Len( aMarcacoes )
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_DATA   ] := &(cPrefixo+"DATA")	)					//01 - Data
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_HORA   ] := &(cPrefixo+"HORA")	)					//02 - Hora
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_ORDEM  ] := &(cPrefixo+"ORDEM")	)					//03 - Ordem
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_FLAG   ] := &(cPrefixo+"FLAG")	)					//04 - Flag
		IF ( lRecno )
			#IFNDEF TOP
				( cAliasQuery )->(aMarcacoes[ nLenMarc , AMARC_RECNO ] := Recno()  		)					//05 - Recno 
			#ELSE
				IF !( lQueryOpened )
					( cAliasQuery )->(aMarcacoes[ nLenMarc , AMARC_RECNO ] := Recno() 	)					//05 - Recno 
				Else                                                                                	
					( cAliasQuery )->(aMarcacoes[ nLenMarc , AMARC_RECNO ] := RECNO		)					//05 - Recno 
				EndIF
			#ENDIF
		Else
			aMarcacoes[ nLenMarc , AMARC_RECNO ] := 0														//05 - Recno
		EndIF
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_TURNO		] := &(cPrefixo+"TURNO")	)			//06 - Turno
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_FUNCAO		] := &(cPrefixo+"FUNCAO")	)			//07 - Funcao 
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_GIRO		] := &(cPrefixo+"GIRO") 	)			//08 - Giro
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_CC			] := &(cPrefixo+"CC")		)			//09 - Centro de Custo
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_APONTA		] := &(cPrefixo+"APONTA")	)			//10 - Flag de Apontamento
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_RELOGIO		] := &(cPrefixo+"RELOGIO")	)			//11 - Relogio
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_TIPOMARC	] := &(cPrefixo+"TPMARCA")	)			//12 - Tipo da Marcacao
		
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica se a Marcacao sera ordenada                         Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		lNotOrdena := (;
							( aMarcacoes[ nLenMarc , AMARC_FLAG ] $ "M,I" ) .and.;
							!Empty( aMarcacoes[ nLenMarc , AMARC_ORDEM  ] );
					   )		
		aMarcacoes[ nLenMarc , AMARC_L_ORIGEM ] := lNotOrdena												//13 - Logico Origem 
		aMarcacoes[ nLenMarc , AMARC_DTHR2STR ] := DataHora2Str(;                                           
																	aMarcacoes[ nLenMarc , AMARC_DATA ] ,;
																	aMarcacoes[ nLenMarc , AMARC_HORA ]  ;
																)                                           //14 - String de Data/Hora para aSort
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_PERAPONTA	    ] := &(cPrefixo+"PAPONTA")	)		//15 - Periodo de Apontamento
		aMarcacoes[ nLenMarc , AMARC_TNOPC	] :=  SPACE(2) 											//16 - Semana/Sequencia da Tabela de Horario Padrao utilizado em turno opcional para identificar o horario
	   	( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_SEQ		] := If(lPort1510,&(cPrefixo+"SEMANA"), SPACE(2) )	) //31 - Semana/Sequencia da Tabela de Horario Padrao 
		aMarcacoes[ nLenMarc , AMARC_DIA	] := SPACE(2)											//17 - Dia da semana da Tabela de Horario Padrao (turno opcional) ja identificado
		( cAliasQuery )->( dbSkip() )
	End While

	/*/   
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Fecha a Query e Seta a Area do Arquivo Original              Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
    IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
    	( cAliasQuery )->( dbCloseArea() )
    	dbSelectArea( cAlias )
    EndIF	

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Restaura a Ordem de Entrada                                  Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF !( nSvIndexOrd ==  2  )
		( cAlias )->( dbSetOrder( nSvIndexOrd ) )
	EndIF	

End Sequence

/*/   
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Restaura a Area de Entrada                                   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
RestArea( aSvAlias )
	
Return( lGetMarcOk )  

/*/
зддддддддддбддддддддддддбддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGetTnoOpc   ЁAutor Ё Mauricio MR		  Ё Data Ё12/08/2005Ё
цддддддддддеддддддддддддаддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRetornar Array com Horario para substituicao do pre-esta-   Ё
Ё          Ёbelecido em funcao da marcacao realiazada.                  Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGetTnoOpc(cTurno,...)									    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁPonto Eletronico                                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlRet	                         							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ < Vide Parametros Formais >								Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetTnoOpc( cTurno,  dData, aDiaTurnoOK, aTabPadrao, aTabTno, cFilSPJ, aMarcacoes)
                
Local aHorOpc
Local aSerial
Local aTemp
Local aTnoSeqDia
Local cOrdem
Local cSeq         
Local nDia  
Local lRet	:= .F.  
Local nHorOpc		 
Local nPos1
Local nPos2
Local nPosTnoOpc		
Local nPosTnoEscolhido 
Local nHora
Local nSerIniTno
Local nSerFimTno 
Local uHora        
Local nSerIni
Local nSerFim
Local nSerMeiaJorn

Begin Sequence 
    nHora	:= aTabTno[01]                                                                   
    cSeq	:= aTabTno[19]
    nDia	:= aTabTno[20]
    
   	//-- Obtem Todos os Horarios para Filial + Turno + Dia
	If (nPosTnoOpc:=Ascan(__aAllTnoOpc,{|x| ( x[1] + x[2] ) == (cFilSPJ + cTurno ) }) ) >  0
    	aHorOpc:=aClone(__aAllTnoOpc[nPosTnoOpc, 3, nDia])
    	AADD(aHorOpc, aTabTno)
		aSort( @aHorOpc , NIL , NIL , { |x,y| ( x[1] < y[1] ) } )    	 
	Else    
	   Break
	Endif
	
	//-- Verifica se existe horario para o turno opcional
    If Empty(aHorOpc)                     
       Break
    Endif   
                                               
	//Obtem os limites maximos possiveis para o dia  
	aSerial		:= fLimitTnoOpc(dData, aHorOpc[ 1 ] )
	nSerIniTno 	:= aSerial[1]                     
	aSerial		:= fLimitTnoOpc(dData, aHorOpc[ Len(aHorOpc) ] )
	nSerFimTno 	:= aSerial[2]
	
	//-- Procura pela primeira marcacao ainda nao verificada
	
	If (nPos1:= Ascan(aMarcacoes, {|x| EMPTY( x[AMARC_TNOPC] )  } ) )  ==   0
	   Break
	Endif   
	nSerIni:=nSerFim:=0
    
    //-- Corre todas as marcacoes a partir da primeira marcacao nao classificada
	For nPos2:= nPos1 To Len(aMarcacoes)
 	
		If ( !Empty( aMarcacoes[nPos2, AMARC_TNOPC] ) )
	 		Loop
		Endif	
	
	    uHora	:= aMarcacoes[nPos2, AMARC_HORA]
	    uHora	:= If( ValType( uHora ) = "C", Val(uHora), uHora ) 
	    nSerMarc:= __fDHtoNS(aMarcacoes[nPos2, AMARC_DATA], uHora )
	    
	    //-- Verifica se Marcacao esta fora dos limites maximos do turno
	    If nSerMarc < nSerIniTno 
	       Loop                                                                     
	       
	    ElseIf 	nSerMarc > nSerFimTno
	    	Exit
	    Endif
	    
	    //-- Verifica se Marcacao esta entre os limites do turno ja verificado  (se ja foi identificado)
	    If !Empty(nSerIni)
	        If (nSerMarc < nSerIni) 
	            Loop
	        ElseIf nSerMarc > nSerFim  .and. aMarcacoes[nPos2, AMARC_ORDEM] <> aMarcacoes[nPos1, AMARC_ORDEM]
	            Exit
	        Else
	        	aMarcacoes[nPos2, AMARC_TURNO]	:= cTurno  	    
		        aMarcacoes[nPos2, AMARC_SEQ] 	:= aHorOpc[ nPosTnoEscolhido, 19 ]
		   		aMarcacoes[nPos2, AMARC_DIA] 	:= aHorOpc[ nPosTnoEscolhido, 20 ] 
		   		aMarcacoes[nPos2, AMARC_TNOPC] 	:= aHorOpc[ nPosTnoEscolhido, 19 ]
		        Loop
	        Endif    
	    Endif 
	    
   	    //-- Verifica a qual das entradas possiveis para o turno a marcacao mais se aproxima
    	aTemp := {} 
    	For nHorOpc  := 1 To Len(aHorOpc)   
	    	aAdd( aTemp , { nHorOpc , DataHora2Val( 	aMarcacoes[nPos2, AMARC_DATA]	,;
													 	uHora							,;
													 	dData							,;
													 	aHorOpc[ nHorOpc , 01 ]	    	,;
													 	"H"							 	;
												  );
							};											  
			 	)
		Next nHorOpc
		
		aSort( aTemp , NIL , NIL , { |x,y| x[2] < y[2] } )		
	                            
	 	//--Gera o Limite do Turno Selecionado para o Dia
		nPosTnoEscolhido 	:= aTemp[1,1]
		aSerial				:= fLimitTnoOpc(dData, aHorOpc[ nPosTnoEscolhido], .T. )
	    nSerIni				:= aSerial[1]
	    nSerFim				:= aSerial[2]  
	    nSerMeiaJorn		:= aSerial[3]  
	        
	   	//-- Verifica se a Marcacao esta fora dos limites do turno (Entre o HorMenos e a MeiaJornada)
	    If ( nSerMarc < nSerIni .or.  nSerMarc > nSerMeiaJorn )
	       Loop                                                                     
	    Endif   
	   		
	   	aMarcacoes[nPos2, AMARC_TURNO]	:= cTurno 	    
	    aMarcacoes[nPos2, AMARC_SEQ] 	:= aHorOpc[ nPosTnoEscolhido, 19 ]
	   	aMarcacoes[nPos2, AMARC_DIA] 	:= aHorOpc[ nPosTnoEscolhido, 20 ]
		aMarcacoes[nPos2, AMARC_TNOPC] 	:= aHorOpc[ nPosTnoEscolhido, 19 ]
	    aDiaTurnoOK[ Len(aDiaTurnoOK), 2 ]  	:= {cTurno, aHorOpc[ nPosTnoEscolhido, 19 ], aHorOpc[ nPosTnoEscolhido, 20 ] }
	    
	    aTabTno[01] 	:=aHorOpc[ nPosTnoEscolhido][01]		// 01 - 1a Entrada
		aTabTno[02] 	:=aHorOpc[ nPosTnoEscolhido][02]		// 02 - 1a Saida
		aTabTno[03] 	:=aHorOpc[ nPosTnoEscolhido][03]		// 03 - 2a Entrada
		aTabTno[04] 	:=aHorOpc[ nPosTnoEscolhido][04]		// 04 - 2a Saida
		aTabTno[05] 	:=aHorOpc[ nPosTnoEscolhido][05]		// 05 - 3a Entrada
		aTabTno[06] 	:=aHorOpc[ nPosTnoEscolhido][06]		// 06 - 3a Saida
		aTabTno[07] 	:=aHorOpc[ nPosTnoEscolhido][07]		// 07 - 4a Entrada
		aTabTno[08] 	:=aHorOpc[ nPosTnoEscolhido][08]		// 08 - 4a Saida
		aTabTno[09] 	:=aHorOpc[ nPosTnoEscolhido][09]		// 09 - Horas Trabalhadas 1a. Jornada
		aTabTno[10] 	:=aHorOpc[ nPosTnoEscolhido][10]		// 10 - Horas Trabalhadas 2a. Jornada
		aTabTno[11] 	:=aHorOpc[ nPosTnoEscolhido][11]		// 11 - Horas Trabalhadas 3a. Jornada
		aTabTno[12] 	:=aHorOpc[ nPosTnoEscolhido][12]		// 12 - Horas Trabalhadas 4a. Jornada
		aTabTno[13] 	:=aHorOpc[ nPosTnoEscolhido][13]		// 13 - Horas de Intervalo 1S
		aTabTno[14] 	:=aHorOpc[ nPosTnoEscolhido][14]		// 14 - Horas de Intervalo 2S
		aTabTno[15] 	:=aHorOpc[ nPosTnoEscolhido][15]		// 15 - Horas de Intervalo 3S
		aTabTno[16] 	:= ""									// 16 - Marcacao e do dia seguinte ?
		aTabTno[17] 	:=aHorOpc[ nPosTnoEscolhido][17]		// 17 - Numero de Marcacoes
		aTabTno[29] 	:=aHorOpc[ nPosTnoEscolhido][29]		// 29 - Aponta Nona Hora
		aTabTno[30] 	:=aHorOpc[ nPosTnoEscolhido][30]		// 30 - Limite de Horario Inicial
		aTabTno[31] 	:=aHorOpc[ nPosTnoEscolhido][31]		// 31 - Limite de Horario Final
		aTabTno[32] 	:=aHorOpc[ nPosTnoEscolhido][32]		// 32 - 1a. Jornada Continua
		aTabTno[33] 	:=aHorOpc[ nPosTnoEscolhido][33]		// 33 - 2a. Jornada Continua
		aTabTno[34]		:=aHorOpc[ nPosTnoEscolhido][34]		// 34 - 3a. Jornada Continua
		aTabTno[35]		:=aHorOpc[ nPosTnoEscolhido][35]		// 35 - 4a. Jornada Continua
		aTabTno[36]		:=aHorOpc[ nPosTnoEscolhido][36]		// 36 - Codigo da Refeicao
	  
	    lRet	:= .T.
	Next nPos2
End

Return (lRet)   

/*/
зддддддддддбддддддддддддбддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁfLimitTnoOpcЁAutor Ё Mauricio MR		  Ё Data Ё12/08/2005Ё
цддддддддддеддддддддддддаддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRetornar Array com os limites do dia para a identificacao   Ё
Ё          Ёde horario para Turnos Opcionais do funcionario.            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁfLimitTnoOpc(dDataTno, aTabTno)							    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁPonto Eletronico                                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁArray  com os limites {nSerialIni, nSerialFim}	 			Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ < Vide Parametros Formais >								Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fLimitTnoOpc(dDataTno, aTabTno, lMeiaJorn)

Local dData		:=	dDataTno
Local dDataI		
Local dDataF			
Local nY
Local nFornY    := 8 // 1E, 1S...4E,4S.
Local nSerialIni
Local nSerialFim    
Local nSeriaMeiaJorn
Local nHoraI			
Local nHoraF			
Local nDifHrs 		

Local aMeiaJorn		
Local aRetorno		
   
DEFAULT lMeiaJorn	:= .F.

    /*/
    
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Loop For/Next para a Carga das Marcacoes do Dia             Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/  
	
	For nY := 1 To nFornY

		/*/
		
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Abandona Quando as Marcacoes estiverem Vazias e Nao For  JorЁ
		Ё nada Continua												  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	
		IF (;
				( ( nY == 3 ) .and. ( ( aTabTno[ 03 ] + aTabTno[  04 ] ) == 0 ) .and. ( aTabTno[ 33 ] != "S" ) ) .or. ;
		   		( ( nY == 5 ) .and. ( ( aTabTno[ 05 ] + aTabTno[  06 ] ) == 0 ) .and. ( aTabTno[ 34 ] != "S" ) ) .or. ;
		   		( ( nY == 7 ) .and. ( ( aTabTno[ 07 ] + aTabTno[  08 ] ) == 0 ) .and. ( aTabTno[ 35 ] != "S" ) )      ;
		   	)	
			Exit
		EndIF

		/*/
	
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Incrementa dData e nDias Quando Marcacao for do Dia SeguinteЁ
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	
		IF ( aTabTno[ nY ] <  aTabTno[ IF( nY == 1 , nY , nY-1 ) ] )
			++dData
		EndIF

		/*/
		
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Incrementa dData e nDias Caso Jornada Continua			  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	
		IF (;
				 (;
							( ( nY == 2 ) .and. ( aTabTno[ 32 ] == "S" ) ) .or. ;
		   		  	    	( ( nY == 4 ) .and. ( aTabTno[ 33 ] == "S" ) ) .or. ;
		   			    	( ( nY == 6 ) .and. ( aTabTno[ 34 ] == "S" ) ) .or. ;
		   			    	( ( nY == 8 ) .and. ( aTabTno[ 35 ] == "S" ) )	   ;
		   		 );
		   	)
			++dData
		EndIF

		IF ( nY == 1 )
			nSerialIni		:= ( __fDhToNS( dData , aTabTno[ nY ] ) - __fDhToNS( NIL , aTabTno[ 30 ] ) )
			If lMeiaJorn
				dDataI		:= dData
				nHoraI		:= aTabTno[ nY ]
			Endif	
		EndIF
	Next nY
	nSerialFim		:= ( __fDhToNS( dData , aTabTno[ Min(nY-1, nFornY) ] ) + __fDhToNS( NIL ,aTabTno[ 31 ] ) )

	If lMeiaJorn
		dDataF			:= dData
		nHoraF			:= aTabTno[ Min(nY-1, nFornY) ]	
		
		nDifHrs 		:= DataHora2Val(dDataI,	nHoraI,	dDataF, nHoraF)
		nDifHrs 		:= __NoRound( nDifHrs/2 , 0 )
		nDifHrs 		:= __Min2Hrs( nDifHrs )
	
		aMeiaJorn		:= RetFimTab(dDataI, nHoraI, nDifHrs )										
		nSeriaMeiaJorn	:= __fDhToNS( aMeiaJorn[1] , aMeiaJorn[2] )
	    aRetorno		:= {nSerialIni, nSerialFim, nSeriaMeiaJorn }
    Else
	    aRetorno		:= {nSerialIni, nSerialFim, Nil } 
    Endif
    
Return( aRetorno )


/*/
зддддддддддбддддддддддддбддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁLoadTnoOpc  ЁAutor Ё Mauricio MR		  Ё Data Ё12/08/2005Ё
цддддддддддеддддддддддддаддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRetornar Array com os horarios dos turnos opcionais de um   Ё
Ё          Ёturno.												        Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁLoadTnoOpc(cFilSPJ, ...)								    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁPonto Eletronico                                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlRet											 			Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ < Vide Parametros Formais >								Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/       
 
Static Function LoadTnoOpc(cFilSPJ, cTurno,__aAllTnoOpc, aTabPadrao) 
Local aArea			:= GetArea()
Local aSeq			:= {}
Local aSr6Return	:= {}
Local cTnoOpc		:= ""
Local lRet			:= .F.
Local nPosAllTnoOpc
Local nPosSeq
Local nPosTabPad
Local nPosTr		:= 0

Begin Sequence
	//-- Verifica se Turno ainda nao foi carregado
	If (nPosAllTnoOpc	:= Ascan(__aAllTnoOpc, {|x| x[1] == cFilSPJ .And. x[2] == cTurno } ) ) ==  0

	    //-- Verifica se trata de um turno opcional
		IF ( nPosTr := aScan( aSr6Info , { |x| x[1] == cFilSPJ .and. x[2] == cTurno } ) ) == 0
			#IFDEF TOP
					
				cCondSR6 := "% R6_FILIAL = '"+cFilSPJ+"' AND "
				cCondSR6 += "R6_TURNO  = '"+cTurno+"' %"
								
				cQrySR6 := GetNextAlias()
				
				BeginSql alias cQrySR6
					SELECT R6_INIHNOT, R6_FIMHNOT, R6_MINHNOT, R6_APODFER, R6_TPEXFER, R6_TPEXFEN, R6_AUTOHEF, R6_ASFOLGA, R6_TNOOPC, R_E_C_N_O_ RECNO
					FROM %table:SR6% SR6
					WHERE
					%exp:cCondSR6% AND SR6.%NotDel%
				EndSql
				
				If (cQrySr6)->(!Eof())
					aAdd( aSr6Info, { cFilSPJ, cTurno, (cQrySr6)->(R6_INIHNOT), (cQrySr6)->(R6_FIMHNOT), (cQrySr6)->(R6_MINHNOT), (cQrySr6)->(R6_APODFER), (cQrySr6)->(R6_TPEXFER), (cQrySr6)->(R6_TPEXFEN), (cQrySr6)->(R6_AUTOHEF), (cQrySr6)->RECNO, (cQrySr6)->(R6_ASFOLGA), (cQrySr6)->(R6_TNOOPC) } )
					SR6->( MsGoto( (cQrySR6)->RECNO ) )						
					cR6TnoOpc	:= (cQrySr6)->(R6_TNOOPC) 
					(cQrySR6)->(dbCloseArea())		
				EndIf
				
			#ELSE		    
		    
				aSr6Return:= PosSR6( cTurno , cFilSPJ , aSr6Struct , 01 , .F. )
				aAdd( aSr6Info, { cFilSPJ, cTurno, aSr6Return[1], aSr6Return[2], aSr6Return[3], aSr6Return[4], aSr6Return[5], aSr6Return[6], aSr6Return[7], SR6->( Recno() ), aSr6Return[8], aSr6Return[9] } )				
				cR6TnoOpc	:= aSr6Return[9]
		    
		    #ENDIF
		Else
			SR6->( MsGoto( aSr6Info[nPosTr, 10] ) )
			cR6TnoOpc	:= aSr6Info[nPosTr, 12]				
	    EndIf

	    cTnoOpc:= cR6TnoOpc

	    If !Empty( cTnoOpc )
		    If (nPosTabPad	:= aScan(aTabPadrao, { |x| x[1] == cFilSPJ .And. x[2] == cTnoOpc })) == 0  
		   	   	/*/   
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Carrega a Tabela Para o turno ainda nao carregado           Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				fTabPadrao( @aTabPadrao , cFilSPJ , cTnoOpc, .T. ) 
			    If (nPosTabPad:= aScan(aTabPadrao, { |x| x[1] == cFilSPJ .And. x[2] == cTnoOpc })) == 0
			       Break
			    Endif
			Endif
		
			//-- Monta Tabela de Horarios Opcionais para o turno lido
			AADD(__aAllTnoOpc, {cFilSPJ, cTurno, Array(7,1) } )  
			nPosAllTnoOpc	:= Len(__aAllTnoOpc)
 		    Aeval(__aAllTnoOpc[ nPosAllTnoOpc,3 ], { |x| x:= {} } )
		   	aSeq		:= aClone( aTabPadrao[ nPosTabPad, 3 ] )
		   	For nPosSeq := 1 To Len(aSeq)  
		   	  	AADD(__aAllTnoOpc[nPosAllTnoOpc, 3, aSeq[nPosSeq, 20] ],  aClone( aSeq[nPosSeq] )  )	   		
		   	Next  
		    lRet:= .T.		   	
		Endif   	
	Else                        
	    lRet:= .T.		   	
	Endif       
End

RestArea(aArea)

Return( lRet )

/*/
зддддддддддбддддддддддддбддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁPutMarcacoesЁAutor Ё Marinaldo de Jesus   Ё Data Ё03/04/2002Ё
цддддддддддеддддддддддддаддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁGravar o Array aMarcacoes                                   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁPonto Eletronico                                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                                							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/

Function PutMarcacoes(	aMarcacoes	,;	//01 -> Array contendo as Marcacoes do Funcionario
						cFil		,;	//02 -> Filial do Funcionario
						cMat		,;	//03 -> Matricula do Funcionario
						cAlias		,;	//04 -> Arquivo para Gravacao ( "SP8" ou "SPG" )
						lNewRec		,;	//05 -> Se Forca a Inclusao de Novo Registro
						lSubsDtHr	,;	//06 -> Se Forca a Substituicao da Data/Hora
						nPosIni		,;	//07 -> Posicao Inicial para o aMarcacoes
						lSubsAll	,;	//08 -> Se Forca a Substituicao de Tudo
						lWorkFlow	;	//09 -> Se eh executado via workflow
					 )

Local cSvFilAnt := cFilAnt

Local aArea
Local cChave
Local cPrefixo
Local cSetOrdem
Local lGoto
Local lAddNew
Local lLock
Local nCount
Local nLenMarc
Local nOrder
Local cRetQry := ""

#IFDEF TOP
	Local aCposChar
	Local aTamHora
	Local cTableName
	Local cCpoRecno
	Local cQryUpdate	
	Local nCpoChar
	Local nCposChar
#ENDIF

DEFAULT aMarcacoes	:= {}
DEFAULT cFil		:= SRA->RA_FILIAL
DEFAULT cMat		:= SRA->RA_MAT
DEFAULT cAlias		:= "SP8"
DEFAULT lNewRec		:= .F.
DEFAULT lSubsDtHr	:= .F.
DEFAULT nPosIni		:= 1
DEFAULT lSubsAll	:= .F.
DEFAULT	lWorkFlow	:= .F.

cAlias	    := Upper( AllTrim( cAlias ) )
cPrefixo	:= ( PrefixoCpo( cAlias ) + "_" )
cFilAnt		:= IF( !Empty( cFil ) , cFil , cFilAnt )

#IFDEF TOP

	IF !( lExInAs400 )

		aTamHora	:= TamSx3( cPrefixo+"HORA" )
		cTableName	:= InitSqlName( cAlias )
		cCpoRecno	:= IF( lExInAs400 , "RRN("+cTableName+")", "R_E_C_N_O_" )
		cQryUpdate	:= ""

	EndIF

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁGaranto que Filial e Matricula nao Terao Strings Nulas de  forЁ
	Ёma a Evitar erro no UpDate quando Base em TOP                 Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	cFil	:= Padr( cFil	, GetSx3Cache( cPrefixo+"FILIAL"	, "X3_TAMANHO" ) )
	cMat	:= Padr( cMat	, GetSx3Cache( cPrefixo+"MAT"		, "X3_TAMANHO" ) )

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁObtenho o Tamanho dos Campos Char para garantir que no  UpdateЁ
	Ёnao Ocorra erro de NULLL quando Base em TOP                   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	aCposChar := {}
	aAdd( aCposChar , { AMARC_FLAG		, GetSx3Cache( cPrefixo+"FLAG"		, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_FUNCAO	, GetSx3Cache( cPrefixo+"FUNCAO"	, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_GIRO		, GetSx3Cache( cPrefixo+"GIRO"		, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_CC		, GetSx3Cache( cPrefixo+"CC" 		, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_RELOGIO	, GetSx3Cache( cPrefixo+"RELOGIO"	, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_ORDEM		, GetSx3Cache( cPrefixo+"ORDEM" 	, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_TURNO		, GetSx3Cache( cPrefixo+"TURNO" 	, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_APONTA	, GetSx3Cache( cPrefixo+"APONTA"	, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_TIPOMARC	, GetSx3Cache( cPrefixo+"TPMARCA"	, "X3_TAMANHO" ) } )
	If lPort1510
		aAdd( aCposChar , { AMARC_MOTIVRG	, GetSx3Cache( cPrefixo+"MOTIVRG"	, "X3_TAMANHO" ) } )
		aAdd( aCposChar , { AMARC_SEQ		, GetSx3Cache( cPrefixo+"SEMANA"	, "X3_TAMANHO" ) } )
		aAdd( aCposChar , { AMARC_EMPORG	, GetSx3Cache( cPrefixo+"EMPORG"	, "X3_TAMANHO" ) } )		
		aAdd( aCposChar , { AMARC_FILORG	, GetSx3Cache( cPrefixo+"FILORG"	, "X3_TAMANHO" ) } )		
		aAdd( aCposChar , { AMARC_MATORG	, GetSx3Cache( cPrefixo+"MATORG"	, "X3_TAMANHO" ) } )
		aAdd( aCposChar , { AMARC_DHORG		, GetSx3Cache( cPrefixo+"DHORG"		, "X3_TAMANHO" ) } )		
		aAdd( aCposChar , { AMARC_IDORG		, GetSx3Cache( cPrefixo+"IDORG"		, "X3_TAMANHO" ) } )		
	EndIf

	nCposChar := Len( aCposChar )

#ENDIF

aArea 		:= ( cAlias )->( GetArea() )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Seleciona o Arquivo de Marca┤■es e Seta a Ordem correspondenЁ
Ёte: _FILIAL+_MAT+_DTOS(_DATA)+STR(_HORA,5,2)    	  		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
cSetOrdem	:= cPrefixo+"FILIAL+"
cSetOrdem	+= cPrefixo+"MAT+"
cSetOrdem	+= "DTOS("+cPrefixo+"DATA)+"
cSetOrdem	+= "STR("+cPrefixo+"HORA,5,2)" 

nOrder		:= RetOrdem( cAlias , cSetOrdem )	

IF !( aArea[2] == nOrder )
	( cAlias )->( dbSetOrder( nOrder ) )
EndIF	

nLenMarc := Len( aMarcacoes )
For nCount := nPosIni To nLenMarc
	#IFDEF TOP
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁGaranto que os Campos Char nao Terao Strings Nulas de forma  aЁ
		Ёma a Evitar erro no UpDate quando Base em TOP                 Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		For nCpoChar := 1 To nCposChar
			aMarcacoes[ nCount , aCposChar[ nCpoChar , 1 ] ] := Padr( aMarcacoes[ nCount , aCposChar[ nCpoChar , 1 ] ] , aCposChar[ nCpoChar , 2 ] )
		Next nCpoChar
	#ENDIF
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁSe nao estiver forcando a Inclusao de um Novo Registro		   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF !( lNewRec )
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁPosiciona no Registro a ser Alteradao e seta a Inclusao   comoЁ
		ЁFalse (.F.)												   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( lGoto := ( ValType( aMarcacoes[ nCount , AMARC_RECNO ] ) == "N" .and. !Empty( aMarcacoes[ nCount , AMARC_RECNO ] ) ) )
			#IFNDEF TOP
				( cAlias )->( dbGoto( aMarcacoes[ nCount , AMARC_RECNO ] ) )
			#ELSE
				IF ( lExInAs400 )
					( cAlias )->( dbGoto( aMarcacoes[ nCount , AMARC_RECNO ] ) )
				EndIF
			#ENDIF
			lAddNew	:= .F.
		Else
			cChave	:= ( cFil + cMat + Dtos( aMarcacoes[ nCount , AMARC_DATA ] ) + Str( aMarcacoes[ nCount , AMARC_HORA ] , 5 , 2 ) )
			lAddNew := !( ( cAlias )->( dbSeek( cChave , .F. ) ) )
		EndIF
	Else
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁForca a Inclusao de um novo Registro						   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		lAddNew := .T.
	EndIF
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁTrava o Registro conforme lAddNew   						   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	#IFNDEF TOP
		lLock := ( cAlias )->( RecLock( cAlias , lAddNew , .F. ) )
	#ELSE
		IF (;
				( lAddNew );
				.or.;
				( lExInAs400 );
			)
			lLock := ( cAlias )->( RecLock( cAlias , lAddNew , .F. ) )
		Else
			lLock := .T.
		EndIF
	#ENDIF	

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁSe nao Consegui o Lock Tenta o Proximo						   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF !( lLock )
		Loop
	EndIF

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁGrava as Informacoes                						   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF (;
			( lAddNew );
			.or.;
			( lSubsAll  );
		)
		#IFNDEF TOP
			( cAlias )->( &( cPrefixo+"FILIAL"  ) )	:= cFil
			( cAlias )->( &( cPrefixo+"MAT"	 ) )	:= cMat
			( cAlias )->( &( cPrefixo+"DATA"    ) )	:= aMarcacoes[ nCount , AMARC_DATA    	]		//01 - Data da Marcacao
			( cAlias )->( &( cPrefixo+"HORA"    ) )	:= aMarcacoes[ nCount , AMARC_HORA    	]		//02 - Hora da Marcacao
			( cAlias )->( &( cPrefixo+"FLAG"    ) )	:= aMarcacoes[ nCount , AMARC_FLAG    	]		//04 - Flag (Origem) da Marcacao
			( cAlias )->( &( cPrefixo+"FUNCAO"  ) )	:= aMarcacoes[ nCount , AMARC_FUNCAO	]		//07 - Funcao do Relogio
			( cAlias )->( &( cPrefixo+"GIRO"    ) )	:= aMarcacoes[ nCount , AMARC_GIRO    	]		//08 - Giro do Relogio
			( cAlias )->( &( cPrefixo+"CC"      ) )	:= aMarcacoes[ nCount , AMARC_CC      	]		//09 - Centro de Custo da Marcacao
			( cAlias )->( &( cPrefixo+"RELOGIO" ) )	:= aMarcacoes[ nCount , AMARC_RELOGIO 	]		//11 - Relogio da Marcacao
		#ELSE
			IF (;
					( lAddNew );
					.or.;
					( lExInAs400 );
				)
				( cAlias )->( &( cPrefixo+"FILIAL"  ) )	:= cFil
				( cAlias )->( &( cPrefixo+"MAT"	 ) )	:= cMat
				( cAlias )->( &( cPrefixo+"DATA"    ) )	:= aMarcacoes[ nCount , AMARC_DATA    	]		//01 - Data da Marcacao
				( cAlias )->( &( cPrefixo+"HORA"    ) )	:= aMarcacoes[ nCount , AMARC_HORA    	]		//02 - Hora da Marcacao
				( cAlias )->( &( cPrefixo+"FLAG"    ) )	:= aMarcacoes[ nCount , AMARC_FLAG    	]		//04 - Flag (Origem) da Marcacao
				( cAlias )->( &( cPrefixo+"FUNCAO"  ) )	:= aMarcacoes[ nCount , AMARC_FUNCAO	]		//07 - Funcao do Relogio
				( cAlias )->( &( cPrefixo+"GIRO"    ) )	:= aMarcacoes[ nCount , AMARC_GIRO    	]		//08 - Giro do Relogio
				( cAlias )->( &( cPrefixo+"CC"      ) )	:= aMarcacoes[ nCount , AMARC_CC      	]		//09 - Centro de Custo da Marcacao
				( cAlias )->( &( cPrefixo+"RELOGIO" ) )	:= aMarcacoes[ nCount , AMARC_RELOGIO 	]		//11 - Relogio da Marcacao
			Else
				cQryUpdate := "UPDATE "
				IF ( lExInAs400 )
					cQryUpdate += _cDataBase+"/"+cTableName
				Else
					cQryUpdate += cTableName
				EndIF	
				cQryUpdate += " SET "
				cQryUpdate += cPrefixo +"FILIAL='"	+ cFil + "'"
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"MAT='"		+ cMat + "'"
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"DATA='"	+ Dtos( aMarcacoes[ nCount , AMARC_DATA ] ) + "'"
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"HORA="		+ Str(  aMarcacoes[ nCount , AMARC_HORA ] , aTamHora[1] , aTamHora[2] )
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"FLAG='"	+ aMarcacoes[ nCount , AMARC_FLAG    	] + "'"
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"FUNCAO='"	+ aMarcacoes[ nCount , AMARC_FUNCAO		] + "'"
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"GIRO='"	+ aMarcacoes[ nCount , AMARC_GIRO   	] + "'"
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"CC='"		+ aMarcacoes[ nCount , AMARC_CC      	] + "'"
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"RELOGIO='"	+ aMarcacoes[ nCount , AMARC_RELOGIO	] + "'"
			EndIF
		#ENDIF
	ElseIF ( lSubsDtHr )
		#IFNDEF TOP
			( cAlias )->( &( cPrefixo+"DATA"    ) )	:= aMarcacoes[ nCount , AMARC_DATA    	]	//01 - Data da Marcacao
			( cAlias )->( &( cPrefixo+"HORA"    ) )	:= aMarcacoes[ nCount , AMARC_HORA    	]	//02 - Hora da Marcacao
		#ELSE
			IF ( lExInAs400 )
				( cAlias )->( &( cPrefixo+"DATA"    ) )	:= aMarcacoes[ nCount , AMARC_DATA    	]	//01 - Data da Marcacao
				( cAlias )->( &( cPrefixo+"HORA"    ) )	:= aMarcacoes[ nCount , AMARC_HORA    	]	//02 - Hora da Marcacao
			Else
				cQryUpdate := "UPDATE "
				IF ( lExInAs400 )
					cQryUpdate += _cDataBase+"/"+cTableName
				Else
					cQryUpdate += cTableName
				EndIF	
				cQryUpdate += " SET "
				cQryUpdate += cPrefixo +"DATA='"	+ Dtos( aMarcacoes[ nCount , AMARC_DATA ] ) + "'"
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"HORA="		+ Str(  aMarcacoes[ nCount , AMARC_HORA ] , aTamHora[1] , aTamHora[2] )
			EndIF
		#ENDIF
	EndIF
	#IFNDEF TOP
		( cAlias )->( &( cPrefixo+"ORDEM"   ) )	:= aMarcacoes[ nCount , AMARC_ORDEM   	]		//03 - Ordem da Marcacao
		( cAlias )->( &( cPrefixo+"TURNO"   ) )	:= aMarcacoes[ nCount , AMARC_TURNO		]		//06 - Turno da Marcacao
		( cAlias )->( &( cPrefixo+"APONTA"  ) )	:= aMarcacoes[ nCount , AMARC_APONTA  	]		//10 - Flag de Marcacao Apontada
		( cAlias )->( &( cPrefixo+"TPMARCA" ) )	:= aMarcacoes[ nCount , AMARC_TIPOMARC	]		//12 - Tipo da Marcacao
		( cAlias )->( &( cPrefixo+"PAPONTA" ) )	:= aMarcacoes[ nCount , AMARC_PERAPONTA	]		//15 - String de Data com o Periodo de Apontamento
		( cAlias )->( &( cPrefixo+"FLAG"    ) )	:= aMarcacoes[ nCount , AMARC_FLAG    	]		//04 - Flag (Origem) da Marcacao
		If lPort1510
			( cAlias )->( &( cPrefixo+"NUMREP"  ) )	:= aMarcacoes[ nCount , AMARC_NUMREP	] 	//26 - Numero do REP
			( cAlias )->( &( cPrefixo+"TPMCREP" ) )	:= aMarcacoes[ nCount , AMARC_TPMCREP	] 	//27 - Tipo de Marcacao no REP
			( cAlias )->( &( cPrefixo+"TIPOREG" ) )	:= aMarcacoes[ nCount , AMARC_TIPOREG	]	//28 - Tipo de Registro
			( cAlias )->( &( cPrefixo+"MOTIVRG" ) )	:= aMarcacoes[ nCount , AMARC_MOTIVRG	]	//29 - Motivo da desconsideracao/inclusao
			( cAlias )->( &( cPrefixo+"SEMANA"  ) )	:= aMarcacoes[ nCount , AMARC_SEQ		] 	//16 - Semana/Sequencia do turno da Tabela Padrao
			( cAlias )->( &( cPrefixo+"EMPORG"  ) )	:= aMarcacoes[ nCount , AMARC_EMPORG	]	//31 - Empresa Origem da marcacao
			( cAlias )->( &( cPrefixo+"FILORG"  ) )	:= aMarcacoes[ nCount , AMARC_FILORG	]   //32 - Filial Origem da marcacao
			( cAlias )->( &( cPrefixo+"MATORG"  ) )	:= aMarcacoes[ nCount , AMARC_MATORG	]   //33 - Matricula Origem da marcacao
			( cAlias )->( &( cPrefixo+"DHORG"	 ) )	:= aMarcacoes[ nCount , AMARC_DHORG		]   //34 - Data/Hora Origem da marcacao
			( cAlias )->( &( cPrefixo+"IDORG"	 ) )	:= aMarcacoes[ nCount , AMARC_IDORG		]   //35 - Identificacao da Origem da marcacao
			( cAlias )->( &( cPrefixo+"DATAAPO" ) )	:= aMarcacoes[ nCount , AMARC_DATAAPO	]	//25 - Data de apontamento
			( cAlias )->( &( cPrefixo+"DATAALT" ) )	:= MsDate()									//Data de alteracao
			( cAlias )->( &( cPrefixo+"HORAALT" ) )	:= SUBSTR(Time(),1,2) + SUBSTR(Time(),4,2) + SUBSTR(Time(),7,2)	//Hora da alteracao
			( cAlias )->( &( cPrefixo+"USUARIO" ) )	:= __cUserId								//Usuario utilizador
		EndIf
	#ELSE
		IF (;
				( lAddNew );
				.or.;
				( lExInAs400 );
			)
			( cAlias )->( &( cPrefixo+"ORDEM"   ) )	:= aMarcacoes[ nCount , AMARC_ORDEM   	]	//03 - Ordem da Marcacao
			( cAlias )->( &( cPrefixo+"TURNO"   ) )	:= aMarcacoes[ nCount , AMARC_TURNO		]	//06 - Turno da Marcacao
			( cAlias )->( &( cPrefixo+"APONTA"  ) )	:= aMarcacoes[ nCount , AMARC_APONTA  	]	//10 - Flag de Marcacao Apontada
			( cAlias )->( &( cPrefixo+"TPMARCA" ) )	:= aMarcacoes[ nCount , AMARC_TIPOMARC	]	//12 - Tipo da Marcacao
			( cAlias )->( &( cPrefixo+"PAPONTA" ) )	:= aMarcacoes[ nCount , AMARC_PERAPONTA	]	//15 - String de Data com o Periodo de Apontamento
			( cAlias )->( &( cPrefixo+"FLAG"    ) )	:= aMarcacoes[ nCount , AMARC_FLAG    	]	//04 - Flag (Origem) da Marcacao
			If lPort1510
				( cAlias )->( &( cPrefixo+"NUMREP"  ) )	:= aMarcacoes[ nCount , AMARC_NUMREP	] 	//26 - Numero do REP
				( cAlias )->( &( cPrefixo+"TPMCREP" ) )	:= aMarcacoes[ nCount , AMARC_TPMCREP	] 	//27 - Tipo de Marcacao no REP
				( cAlias )->( &( cPrefixo+"TIPOREG" ) )	:= aMarcacoes[ nCount , AMARC_TIPOREG	]	//28 - Tipo de Registro
				( cAlias )->( &( cPrefixo+"MOTIVRG" ) )	:= aMarcacoes[ nCount , AMARC_MOTIVRG	]	//29 - Motivo da desconsideracao/inclusao
				( cAlias )->( &( cPrefixo+"SEMANA"  ) )	:= aMarcacoes[ nCount , AMARC_SEQ		]	//16 - Semana/Sequencia do turno da Tabela Padrao
				( cAlias )->( &( cPrefixo+"EMPORG"  ) )	:= aMarcacoes[ nCount , AMARC_EMPORG	]	//31 - Empresa Origem da marcacao
				( cAlias )->( &( cPrefixo+"FILORG"  ) )	:= aMarcacoes[ nCount , AMARC_FILORG	]   //32 - Filial Origem da marcacao
				( cAlias )->( &( cPrefixo+"MATORG"  ) )	:= aMarcacoes[ nCount , AMARC_MATORG	]   //33 - Matricula Origem da marcacao
				( cAlias )->( &( cPrefixo+"DHORG"	 ) )	:= aMarcacoes[ nCount , AMARC_DHORG		]   //34 - Data/Hora Origem da marcacao
				( cAlias )->( &( cPrefixo+"IDORG"	 ) )	:= aMarcacoes[ nCount , AMARC_IDORG		]   //35 - Identificacao da Origem da marcacao
				( cAlias )->( &( cPrefixo+"DATAAPO" ) )	:= aMarcacoes[ nCount , AMARC_DATAAPO	]	//25 - Data de apontamento
				( cAlias )->( &( cPrefixo+"DATAALT" ) )	:= MsDate()									//Data de alteracao
				( cAlias )->( &( cPrefixo+"HORAALT" ) )	:= SUBSTR(Time(),1,2) + SUBSTR(Time(),4,2) + SUBSTR(Time(),7,2)	//Hora da alteracao
				( cAlias )->( &( cPrefixo+"USUARIO" ) )	:= __cUserId								//Usuario utilizador
			EndIf
		Else
			IF Empty( cQryUpdate )
				cQryUpdate := "UPDATE "
				IF ( lExInAs400 )
					cQryUpdate += _cDataBase+"/"+cTableName
				Else
					cQryUpdate += cTableName
				EndIF
				cQryUpdate += " SET "
			Else
				cQryUpdate += ", "
			EndIF
			cQryUpdate += cPrefixo +"ORDEM='"	+ aMarcacoes[ nCount , AMARC_ORDEM   	] + "'"
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"TURNO='"	+ aMarcacoes[ nCount , AMARC_TURNO		] + "'"
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"APONTA='"	+ aMarcacoes[ nCount , AMARC_APONTA  	] + "'"
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"TPMARCA='"	+ aMarcacoes[ nCount , AMARC_TIPOMARC	] + "'"
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"PAPONTA='"	+ aMarcacoes[ nCount , AMARC_PERAPONTA	] + "'"
			If lPort1510
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"NUMREP='"	+ aMarcacoes[ nCount , AMARC_NUMREP		] + "'"
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"TPMCREP='"	+ aMarcacoes[ nCount , AMARC_TPMCREP	] + "'"
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"TIPOREG='"	+ aMarcacoes[ nCount , AMARC_TIPOREG	] + "'"
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"MOTIVRG='"	+ aMarcacoes[ nCount , AMARC_MOTIVRG	] + "'"
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"SEMANA='"	+ aMarcacoes[ nCount , AMARC_SEQ		] + "'"
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"EMPORG='"	+ aMarcacoes[ nCount , AMARC_EMPORG		] + "'"	  
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"FILORG='"	+ aMarcacoes[ nCount , AMARC_FILORG		] + "'"	  				
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"MATORG='"	+ aMarcacoes[ nCount , AMARC_MATORG		] + "'"
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"DHORG='"	+ aMarcacoes[ nCount , AMARC_DHORG		] + "'"	  
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"IDORG='"	+ aMarcacoes[ nCount , AMARC_IDORG		] + "'"	  								
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"DATAAPO='"	+ Dtos( aMarcacoes[ nCount , AMARC_DATAAPO ] ) + "'"
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"DATAALT='"	+ DtoS(MsDate()) + "'"
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"HORAALT='"	+ SUBSTR(Time(),1,2) + SUBSTR(Time(),4,2) + SUBSTR(Time(),7,2) + "'"
  				If !lWorkflow			
					cQryUpdate += ", "
					cQryUpdate += cPrefixo +"USUARIO='"	+ __cUserId + "'"
				EndIf					
			EndIf
		EndIF
	#ENDIF
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁDestrava o Registro                 						   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	#IFNDEF TOP
		( cAlias )->( MsUnlock() )
	#ELSE
		IF (;
				( lAddNew );
				.or.;
				( lExInAs400 );
			)
			( cAlias )->( MsUnlock() )
		Else
			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁSubstitui os valores                						   Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF !Empty( cQryUpdate )
				cQryUpdate += " WHERE " 
				cQryUpdate += cCpoRecno + "=" + Str( aMarcacoes[ nCount , AMARC_RECNO ] , 10 , 0 )
				cRetQry := TcSqlExec( cQryUpdate )
				
				If cRetQry <> 0 				 
					If !lWorkflow 
						MsgStop("TCSQLError() " + TCSQLError())
					Else
						ConOut( "TCSQLError() " + TCSQLError() )	
					EndIf
				Endif
							
				cQryUpdate := ""
			EndIF
		EndIF
	#ENDIF
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁGrava o Recno no aMarcacoes         						   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF (;
			( lAddNew );
			.or.;
			Empty( aMarcacoes[ nCount , AMARC_RECNO ] );
		)
		aMarcacoes[ nCount , AMARC_RECNO ] := ( cAlias )->( Recno() )						//05 - Recno
	EndIF
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁlAddNew eh Setada como .F.          						   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	lAddNew := .F.
Next nCount
( cAlias )->( dbSetOrder( aArea[ 02 ] ) )

cFilAnt := cSvFilAnt

Return( NIL )

/*/
зддддддддддбддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGetPerApontaЁ Autor Ё Marinaldo de Jesus  Ё Data Ё27/09/2001Ё
цддддддддддеддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁListBox com a Selecao dos Periodos de Apontamento           Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGetPerAponta( nNumPerAnt , cFil , cMat , lReturn , uMvPar )	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁSe Validacao .T. c.c. Array com os Periodos de Apontamento  Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁnNumPerAnt	- Numero de Periodos a Serem Listados			Ё
Ё          ЁcFil		- Filial do Funcionario							Ё
Ё          ЁcMat		- Matricula do Funcionario						Ё
Ё          ЁlReturn		- Retorno Logico Quando Validacao				Ё
Ё          ЁuMvPar	    - Opcional.Variavel Receptora do Valor da Opcao Ё  
Ё          Ё              Escolhida.                                    Ё  
Ё          ЁaPerSPO     - Periodos do SPO                       		Ё  
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetPerAponta( nNumPerAnt , cFil , cMat , lReturn , lSelectOne , uMvPar , aPerSPO )

Local aAreaSRA		:= {}
Local aPeriodos		:= {}
Local aShowPer		:= {}
Local bAscPer		:= { |x| x[1] == dPerIni .and. x[2] == dPerFim }
Local cMvParDef		:= ""
Local dAdmissa		:= Ctod("//")
Local dPerIni		:= Ctod("//")
Local dPerFim		:= Ctod("//")
Local lItera		:= .T.
Local lFunc			:= .T.
Local lMvPar		:= !( uMvPar == NIL )
Local lPerCompleto	:= .F.
Local nPer			:= 0
Local nPerSPO		:= 0
Local nItera		:= 0

DEFAULT nNumPerAnt	:= 12
DEFAULT lReturn		:= .T.
DEFAULT lSelectOne	:= .T.
DEFAULT aPerSPO		:= {}

uMvPar	:= IF( lReturn , IF( !lMvPar , &( Alltrim( ReadVar() ) ) , uMvPar ) , "" )

IF ( lReturn )
	CursorWait()
EndIF	

IF ( lFunc := ( cFil != NIL .and. cMat != NIL ) )
	aAreaSRA := SRA->( GetArea() )
	IF !( SRA->( RA_FILIAL+RA_MAT == cFil+cMat ) )
		SRA->( dbSetOrder( RetOrdem("SRA") ) )
		SRA->( dbSeek( cFil + cMat ) )
	EndIF
	dAdmissa := SRA->RA_ADMISSA
	SRA->( dbSetOrder( aAreaSRA[ 02 ] ) )
EndIF		

IF ( lMvPar )
	aAdd( aPeriodos, { Stod( SubStr( uMvPar , 1 , 8 ) ) , Stod( SubStr( uMvPar , 9 , 8 ) ) } )
EndIF

IF !GetPonMesDat( @dPerIni , @dPerFim , cFil )
	PerAponta( @dPerIni , @dPerFim , NIL , NIL , cFil ,  .F. , @lPerCompleto )
EndIF

IF ( aScan( aPeriodos , bAscPer ) == 0 )
	aAdd( aPeriodos, { dPerIni , dPerFim } )
EndIF

IF ( ( nPerSPO := Len( aPerSPO ) ) > 0 )
	aSort( aPerSPO , NIL , NIL , { |x,y| Dtos(x[1])+Dtos(x[2]) > Dtos(y[1])+Dtos(y[2]) } )
EndIF
	
While ( lItera )

	++nItera
    
	IF ( lItera := ( --nNumPerAnt > 0 ) )
		IF ( nPerSPO == 0 )
			IF !( lItera := !( IF( lFunc , --dPerIni < dAdmissa , ( --dPerIni , .F. ) ) ) )
				Exit
			EndIF
			IF ( !( lPerCompleto ) .and. ( nItera == 1 ) )
				PerAponta( dPerIni , dPerFim , dPerIni , NIL , cFil , .F. , @lPerCompleto )
			EndIF
			IF ( lPerCompleto )
				PonDecDate( @dPerIni , @dPerFim )
			Else
				PerAponta( @dPerIni , @dPerFim , dPerIni , NIL , cFil , .T. , NIL )
			EndIF
		Else
			IF !( lItera := ( ++nPer <= nPerSPO ) )
				Exit
			EndIF	
			dPerIni := aPerSPO[ nPer , 01 ]
			dPerFim := aPerSPO[ nPer , 02 ]
			IF !( lItera := !( IF( lFunc , dPerIni < dAdmissa , .F. ) ) )
				Exit
			EndIF
		EndIF
		IF ( aScan( aPeriodos , bAscPer ) == 0 )
			aAdd( aPeriodos, { dPerIni , dPerFim } )
		EndIF
	EndIF

End While

IF !Empty( aPeriodos )
	aSort( aPeriodos , NIL , NIL , { |x,y| Dtos(x[1])+Dtos(x[2]) < Dtos(y[1])+Dtos(y[2]) } )
	aEval( aPeriodos , { |x| aAdd( aShowPer , Dtoc(x[1])+ STR0067 + Dtoc(x[2]) ) , ( cMvParDef += Dtos(x[1])+Dtos(x[2]) ) } )
EndIF

IF ( lReturn )
	CursorArrow()
	IF f_Opcoes( @uMvPar , STR0100 , aShowPer , cMvParDef , 12 , 49 , lSelectOne , 16 , ( 16 * nNumPerAnt ) ) //Periodos de Apontamento
		IF ( !Empty( uMvPar := StrTran( uMvPar , "*" , "" ) ) .and. !( lMvPar ) )
			&( ReadVar() ) := uMvPar
		EndIF
	EndIF	
EndIF

Return( IF( lReturn , lReturn , aPeriodos ) )

/*/
зддддддддддбддддддддддддбддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁRetSerIni   ЁAutor Ё Marinaldo de Jesus   Ё Data Ё26/06/2003Ё
цддддддддддеддддддддддддаддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRetorna Numero Serial p/ o Inicio do Periodo de Apontamento Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>                   				Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁPonto Eletronico                                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁnSerIni                            							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RetSerIni(	aTabCalend	,;	//01 -> Copia do Calendario de Marcacoes
					aTabPadrao	,;	//02 -> Tabela de Horario Padrao
					dPerIni		,;	//03 -> Inicio do Periodo de Apontamento
					dPerFim		,; 	//04 -> Final do Periodo de Apontamento
					cTno		,;	//05 -> Turno de Trabalho
					cSeq		,;	//06 -> Sequencia de Turno
					cFil     	,;	//07 -> Filial do Funcionario
					cMat   		,;	//08 -> Matricula do Funcionario
					cCc   		,;	//09 -> Centro de Custo do Funcionario
					lMarcOrder	,;	//10 -> Marcacoes Sendo carregadas pela Ordem
					lCalendFunc  ;	//11 -> Se o Calendario Esta Sendo Montado por funcionario
				   )

Local nHoursDay	:= 0
Local nHoursTab := 0

Local aSvTabsCal
Local cPriOrdem
Local cUltOrdem
Local nSerIni
Local nDays
Local nPosUltOrdem
Local nLenCalend

DEFAULT aTabCalend		:= {}
DEFAULT aTabPadrao		:= {}
DEFAULT dPerIni			:= Ctod("//")
DEFAULT dPerFim			:= Ctod("//")
DEFAULT lCalendFunc		:= .T.
IF ( lCalendFunc )
	DEFAULT cFil		:= SRA->RA_FILIAL
	DEFAULT cMat		:= SRA->RA_MAT
	DEFAULT cTno		:= SRA->RA_TNOTRAB
	DEFAULT cSeq		:= SRA->RA_SEQTURN
	DEFAULT cCc			:= SRA->RA_CC
EndIF	
DEFAULT lMarcOrder	:= .F.

Begin Sequence

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁVerifica se o Calendario foi passado como parametro		  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF Empty( aTabCalend )
		IF ( Empty( dPerIni ) .or. Empty( dPerFim ) )
			IF !( PerAponta( @dPerIni , @dPerFim , NIL , NIL , cFil ) )
				Break
			EndIF
		EndIF
        /*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Salva o Conteudo do Calendario por Turno        			  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		aSvTabsCal := GetTabCal()
		IF !(;
				CriaCalend(	dPerIni 	,;	//01 -> Data Inicial do Calendario
						   	dPerFim		,;	//02 -> Data Final do Calendario
					   		cTno		,;	//03 -> Turno de Trabalho
					   		cSeq		,;	//04 -> Sequencia de Turno
					   		@aTabPadrao	,;	//05 -> Tabela de Horario Padrao
					   		@aTabCalend	,;	//06 -> Calendario de Marcacoes
					   		cFil     	,;	//07 -> Filial do Funcionario
					   		cMat   		,;	//08 -> Matricula do Funcionario
					   		cCc   		,;	//09 -> Centro de Custo do Funcionario
							NIL			,;	//10 -> Array com as Trocas de Turno
							NIL			,;	//11 -> Array com Todas as Excecoes do Periodo
							NIL			,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
							.F.			,;	//13 -> Se executa a funcao se sincronismo do calendario
							NIL			 ;	//14 -> Se Forca a Criacao de Novo Calendario
					  	  );
			)					  	  
			Break
		EndIF					  	  
	ElseIF ( Empty( dPerIni ) .or. Empty( dPerFim ) )
		dPerIni			:= aTabCalend[ 01 , CALEND_POS_DATA ]
		cUltOrdem		:= aTabCalend[ Len( aTabCalend ) , CALEND_POS_ORDEM ]
		nPosUltOrdem    := aScan( aTabCalend , { |x| ( x[ CALEND_POS_ORDEM ] == cUltOrdem  ) .and. ( x[CALEND_POS_TIPO_MARC] == "1E" ) } )
		IF ( nPosUltOrdem > 0 )
			dPerFim := aTabCalend[ nPosUltOrdem , CALEND_POS_DATA ]
		Else
			IF !( PerAponta( @dPerIni , @dPerFim , NIL , NIL , cFil ) )
				Break
			EndIF
		EndIF
	EndIF
	
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁDefine o Numero Serial correspondente ao primeiro dia do PeriЁ
	Ёodo de Apontamento											  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	nSerIni := __fDHtoNS(aTabCalend[ 01 , CALEND_POS_LIM_MARCACAO , 01 ], aTabCalend[ 01, CALEND_POS_LIM_MARCACAO , 02 ] )
	
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁQuando Primeiro Dia da Tabela Tiver o Horario Zerado DecremenЁ
	Ёta um Dia													  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	cPriOrdem := aTabCalend[ 01 , CALEND_POS_ORDEM ]
	aEval( aTabCalend ,{ |x|;
					 	 	 IF( x[CALEND_POS_ORDEM] == cPriOrdem ,;
					 	 	 		 nHoursDay := SomaHoras( nHoursDay , x[CALEND_POS_HRS_TRABA] ),;
					 	 	 		 nHoursTab := SomaHoras( nHoursTab , x[CALEND_POS_HRS_TRABA] );
					 	 	 	);
					  };
		  )
	IF ( Empty( nHoursDay ) .and. !Empty( nHoursTab := SomaHoras( nHoursDay , nHoursTab ) ) )
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁMonta Novo Periodo de Apontamento                   	  	  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		nDays	:= ( ( dPerFim - dPerIni ) + 1 )
		dPerFim	:= ( aTabCalend[ 01 , CALEND_POS_DATA ] - 1 )
		dPerIni := ( dPerFim - nDays )
        /*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Salva o Conteudo do Calendario por Turno        			  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF Empty( aSvTabsCal )
			aSvTabsCal := GetTabCal()
		EndIF
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁCria Calendario com o Ultimo dia do Periodo Anterior         Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF CriaCalend(	dPerFim		,;	//01 -> Data Inicial do Calendario
		   		   		dPerFim		,;	//02 -> Data Final do Calendario
						cTno		,;	//03 -> Turno de Trabalho
						cSeq		,;	//04 -> Sequencia de Turno
						@aTabPadrao	,;	//05 -> Tabela de Horario Padrao
						@aTabCalend	,;	//06 -> Calendario de Marcacoes
						cFil     	,;	//07 -> Filial do Funcionario
						cMat   		,;	//08 -> Matricula do Funcionario
						cCc   		,;	//09 -> Centro de Custo do Funcionario
						NIL			,;	//10 -> Array com as Trocas de Turno
						NIL			,;	//11 -> Array com Todas as Excecoes do Periodo
						NIL			,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
						.F.			,;	//13 -> Se executa a funcao se sincronismo do calendario
						NIL			 ;	//14 -> Se Forca a Criacao de Novo Calendario
					  )
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁProcura o Proximo Dia com Horario na Tabela         	  	  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			While ( nHoursDay := 0 , aEval( aTabCalend , { |x| nHoursDay := SomaHoras( nHoursDay , x[CALEND_POS_HRS_TRABA] ) } ) , nHoursDay == 0 )
				IF ( ( --dPerFim ) < dPerIni )
					Exit
				EndIF
				aTabCalend := {}
				IF !CriaCalend(	dPerFim		,;	//01 -> Data Inicial do Calendario
		   		    			dPerFim		,;	//02 -> Data Final do Calendario
					  			cTno		,;	//03 -> Turno de Trabalho
								cSeq		,;	//04 -> Sequencia de Turno
								@aTabPadrao	,;	//05 -> Tabela de Horario Padrao
								@aTabCalend	,;	//06 -> Calendario de Marcacoes
								cFil     	,;	//07 -> Filial do Funcionario
								cMat   		,;	//08 -> Matricula do Funcionario
								cCc   		,;	//09 -> Centro de Custo do Funcionario
								NIL			,;	//10 -> Array com as Trocas de Turno
								NIL			,;	//11 -> Array com Todas as Excecoes do Periodo
								NIL			,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
								.F.			,;	//13 -> Se executa a funcao se sincronismo do calendario
								NIL			 ;	//14 -> Se Forca a Criacao de Novo Calendario
					  		)
					Exit
				EndIF					  		
			End While
			IF Empty( nHoursDay )
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				ЁSe nao Achou Horas na Tabela Decrementa o Primeiro Serial	  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				--nSerIni
			Else
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				ЁCaso Contrario Considera como Primeira Marcacao a ultima  MarЁ
				Ёcacao do Dia Anterior(Respeitando o HorMais) somado de um  miЁ
				Ёnuto.  													  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				nLenCalend	:= Len( aTabCalend )
				nSerIni 	:= __fDHtoNS( aTabCalend[ nLenCalend , CALEND_POS_LIM_MARCACAO , 01 ] , SomaHoras( aTabCalend[ nLenCalend , CALEND_POS_LIM_MARCACAO , 02 ] , 0.01 ) )
			EndIF
		Else
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁSe nao Achou Horas na Tabela Decrementa o Primeiro Serial	  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			--nSerIni
		EndIF	
	ElseIF Empty( nHoursTab )
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁNeste Caso a Tabela nao Tem Horario e o Serial deve ser DecreЁ
		Ёmentado													  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		--nSerIni
	EndIF

End Sequence

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Restaura o Conteudo do Calendario por Turno        		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF !Empty( aSvTabsCal )
	SetTabCal( aSvTabsCal )
EndIF

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁVerifica se Deve Decrementar o Serial Obtido				  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Return( IF( lMarcOrder ,  --nSerIni , nSerIni ) )

/*/
зддддддддддбддддддддддддбддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁRetSerFim   ЁAutor Ё Marinaldo de Jesus   Ё Data Ё11/10/2001Ё
цддддддддддеддддддддддддаддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRetorna Numero Serial para o Fim do Periodo de Apontamento  Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>                   				Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁPonto Eletronico                                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁnSerFim                            							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RetSerFim(	aTabCalend	,;	//01 -> Copia do Calendario de Marcacoes
					aTabPadrao	,;	//02 -> Tabela de Horario Padrao
					dPerIni		,;	//03 -> Inicio do Periodo de Apontamento
					dPerFim		,; 	//04 -> Final do Periodo de Apontamento
					cTno		,;	//05 -> Turno de Trabalho
					cSeq		,;	//06 -> Sequencia de Turno
					cFil     	,;	//07 -> Filial do Funcionario
					cMat   		,;	//08 -> Matricula do Funcionario
					cCc   		,;	//09 -> Centro de Custo do Funcionario
					lMarcOrder	,;	//10 -> Marcacoes Sendo carregadas pela Ordem
					lCalendFunc  ;	//11 -> Se o Calendario Esta Sendo Montado por funcionario
				   )

Local nHoursDay	:= 0
Local nHoursTab := 0

Local aSvTabsCal
Local cUltOrdem
Local nSerFim
Local nDays
Local nPosUltOrdem

DEFAULT aTabCalend	:= {}
DEFAULT aTabPadrao	:= {}
DEFAULT dPerIni		:= Ctod("//")
DEFAULT dPerFim		:= Ctod("//")
DEFAULT cFil		:= SRA->RA_FILIAL
DEFAULT lCalendFunc	:= .T.
IF ( lCalendFunc )
	DEFAULT cMat		:= SRA->RA_MAT
	DEFAULT cTno		:= SRA->RA_TNOTRAB
	DEFAULT cSeq		:= SRA->RA_SEQTURN
	DEFAULT cCc			:= SRA->RA_CC
EndIF
DEFAULT lMarcOrder	:= .F.

Begin Sequence

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁVerifica se o Calendario foi passado como parametro		  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF Empty( aTabCalend )
		IF ( Empty( dPerIni ) .or. Empty( dPerFim ) )
			IF !( PerAponta( @dPerIni , @dPerFim , NIL , NIL , cFil ) )
				Break
			EndIF
		EndIF
        /*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Salva o Conteudo do Calendario por Turno        			  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		aSvTabsCal := GetTabCal()
		IF !(;
				CriaCalend(	dPerIni 	,;	//01 -> Data Inicial do Calendario
						   	dPerFim		,;	//02 -> Data Final do Calendario
				   			cTno		,;	//03 -> Turno de Trabalho
					   		cSeq		,;	//04 -> Sequencia de Turno
					   		@aTabPadrao	,;	//05 -> Tabela de Horario Padrao
					   		@aTabCalend	,;	//06 -> Calendario de Marcacoes
					   		cFil     	,;	//07 -> Filial do Funcionario
					   		cMat   		,;	//08 -> Matricula do Funcionario
				   			cCc   		,;	//09 -> Centro de Custo do Funcionario
							NIL			,;	//10 -> Array com as Trocas de Turno
							NIL			,;	//11 -> Array com Todas as Excecoes do Periodo
							NIL			,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
							.F.			,;	//13 -> Se executa a funcao se sincronismo do calendario
							NIL			 ;	//14 -> Se Forca a Criacao de Novo Calendario
					  	  );
			)
			Break					  	  
		EndIF
	ElseIF ( Empty( dPerIni ) .or. Empty( dPerFim ) )
		dPerIni			:= aTabCalend[ 01 , CALEND_POS_DATA ]
		cUltOrdem		:= aTabCalend[ Len( aTabCalend ) , CALEND_POS_ORDEM ]
		nPosUltOrdem    := aScan( aTabCalend , { |x| ( x[ CALEND_POS_ORDEM ] == cUltOrdem  ) .and. ( x[CALEND_POS_TIPO_MARC] == "1E" ) } )
		IF ( nPosUltOrdem > 0 )
			dPerFim := aTabCalend[ nPosUltOrdem , CALEND_POS_DATA ]
		Else
			IF !( PerAponta( @dPerIni , @dPerFim , NIL , NIL , cFil ) )
				Break
			EndIF
		EndIF
	EndIF
	
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁDefine o Numero Serial correspondente ao ultimo dia do  PerioЁ
	Ёdo de Apontamento											  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	nSerFim := __fDHtoNS(aTabCalend[Len(aTabCalend),CALEND_POS_LIM_MARCACAO,1] , aTabCalend[Len(aTabCalend),CALEND_POS_LIM_MARCACAO,2] )
	
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁQuando ultimo Dia da Tabela Tiver o Horario Zerado Soma  MaisЁ
	Ёum Dia														  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	cUltOrdem := aTabCalend[Len(aTabCalend),CALEND_POS_ORDEM]
	aEval( aTabCalend ,{ |x|;
					 	 	 IF( x[CALEND_POS_ORDEM] == cUltOrdem ,;
					 	 	 		 nHoursDay := SomaHoras( nHoursDay , x[CALEND_POS_HRS_TRABA] ),;
					 	 	 		 nHoursTab := SomaHoras( nHoursTab , x[CALEND_POS_HRS_TRABA] );
					 	 	 	);
					  };
		  )	
	
	
	IF ( Empty( nHoursDay ) .and. !Empty( nHoursTab := SomaHoras( nHoursDay , nHoursTab ) ) )
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁMonta Novo Periodo de Apontamento                   	  	  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		nDays	:= ( ( dPerFim - dPerIni ) + 1 )
		dPerIni := ( aTabCalend[ Len(aTabCalend) , CALEND_POS_DATA ]  + 1 )
		dPerFim := ( dPerIni + nDays )
        /*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Salva o Conteudo do Calendario por Turno        			  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF Empty( aSvTabsCal )
			aSvTabsCal := GetTabCal()
		EndIF	
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁCria Calendario com o Primeiro dia do Proximo Periodo de AponЁ
		Ёtamento													  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF CriaCalend(	dPerIni		,;	//01 -> Data Inicial do Calendario
		   		   		dPerIni		,;	//02 -> Data Final do Calendario
						cTno		,;	//03 -> Turno de Trabalho
						cSeq		,;	//04 -> Sequencia de Turno
						@aTabPadrao	,;	//05 -> Tabela de Horario Padrao
						@aTabCalend	,;	//06 -> Calendario de Marcacoes
						cFil     	,;	//07 -> Filial do Funcionario
						cMat   		,;	//08 -> Matricula do Funcionario
						cCc   		,;	//09 -> Centro de Custo do Funcionario
						NIL			,;	//10 -> Array com as Trocas de Turno
						NIL			,;	//11 -> Array com Todas as Excecoes do Periodo
						NIL			,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
						.F.			,;	//13 -> Se executa a funcao se sincronismo do calendario
						NIL			 ;	//14 -> Se Forca a Criacao de Novo Calendario
					  )
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁProcura o Proximo Dia com Horario na Tabela         	  	  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			While ( nHoursDay := 0 , aEval( aTabCalend , { |x| nHoursDay := SomaHoras( nHoursDay , x[CALEND_POS_HRS_TRABA] ) } ) , nHoursDay == 0 )
				IF ( ( ++dPerIni ) > dPerFim )
					Exit
				EndIF
				aTabCalend := {}
				IF !CriaCalend(	dPerIni		,;	//01 -> Data Inicial do Calendario
		   		    			dPerIni		,;	//02 -> Data Final do Calendario
					  			cTno		,;	//03 -> Turno de Trabalho
								cSeq		,;	//04 -> Sequencia de Turno
								@aTabPadrao	,;	//05 -> Tabela de Horario Padrao
								@aTabCalend	,;	//06 -> Calendario de Marcacoes
								cFil     	,;	//07 -> Filial do Funcionario
								cMat   		,;	//08 -> Matricula do Funcionario
								cCc   		,;	//09 -> Centro de Custo do Funcionario
								NIL			,;	//10 -> Array com as Trocas de Turno
								NIL			,;	//11 -> Array com Todas as Excecoes do Periodo
								NIL			,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
								.F.			,;	//13 -> Se executa a funcao se sincronismo do calendario
								NIL			 ;	//14 -> Se Forca a Criacao de Novo Calendario
					  		)
					Exit
				EndIF					  		
			End While
			IF Empty( nHoursDay )
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				ЁSe nao Achou Horas na Tabela Incremente o Ultimo Serial	  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				++nSerFim
			Else
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				ЁCaso Contrario Considera como Ultima Marcacao a Primeira  MarЁ
				Ёcacao do Proximo Dia (Respeitando o HorMenos) subtraido de umЁ
				Ёminuto.													  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				nSerFim := __fDHtoNS( aTabCalend[ 01 , CALEND_POS_LIM_MARCACAO , 01 ] , SubHoras( aTabCalend[ 01 , CALEND_POS_LIM_MARCACAO , 02 ] , 0.01 ) )
			EndIF
		Else
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁSe nao Achou Horas na Tabela Incremente o Ultimo Serial	  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			++nSerFim
		EndIF	
	ElseIF Empty( nHoursTab )
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁNeste Caso a Tabela nao Tem Horario e o Serial deve ser increЁ
		Ёmentado													  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		++nSerFim
	EndIF

End Sequence

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Restaura o Conteudo do Calendario por Turno        		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF !Empty( aSvTabsCal )
	SetTabCal( aSvTabsCal )
EndIF
	
/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁVerifica se Deve Incrementar o Serial Obtido				  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Return( IF( lMarcOrder , ++nSerFim , nSerFim ) )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁPutMarcAuto  ЁAutorЁ Marinaldo de Jesus   Ё Data Ё13/08/2001Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁGerar Marcacoes Automaticas no Array aMarcacoes             Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<vide parametros formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlAuto														Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<vide parametros formais>									Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PutMarcAuto(	aTabCalend	,;
						aMarcacoes	,;
						dPerIni		,;
						dPerFim		,;
						cFil		,;
						lChkTables	,;
						lSobrepoe	,;
						aMarcNoGer   ;
					)
                    	
Local aCloneMarc	:= aClone( aMarcacoes )
Local aMAuto		:= {}
Local cCusto		:= SRA->RA_CC 
Local lSpaIsMemVar	:= .F.
Local lSr6IsMemVar	:= .F.

Local aTDia
Local aMDia
Local aTab_Marc
Local aFields  
Local aMarcGer  
Local aMarcDia		:= {}
Local aSvAlias		:= {}

Local cOrdem
Local cMarcAut  
Local cNewMarcAut
Local cMarc 
Local cUltmarc
Local cTipMarcDia
Local cMarcsObriga
Local cMarcsEfe
Local cFilRegra
Local cFilTurno
Local cTpMarc
Local cPerAponta
Local cAutoSai
Local cUltOrdem
Local cMotivoAut
Local cMotivoInc
Local cIntPreDet	:= " "
Local cSpaceNumRep
Local cSpaceMotivo  
Local cSpaceTpMar
Local cCodMot
Local cRet

Local dDtMarc  
Local dDtApo

Local lAuto
Local lInterv
Local lAleat
Local lAutomSM
Local lTrabFer
Local lMarcsObriga
Local lAutoSai
Local lCompletaMar
Local lIntPreDet    := .F.

Local nY
Local nFornY
Local nTab
Local nLenTab
Local nMarc
Local nLenMarc
Local nOrdem
Local nForOrdem
Local nField
Local nMarcsGer
Local nMarcsEfe
Local nLenMAuto
Local nMarcAut
Local nPosUltOrd
Local nInterv
Local nHrTrab
Local nAleato
Local nPos
Local nMinuto
Local nSvRecno
Local nTab_Marc
Local nPosTr		:= 0

Local lSumIntAleat := SuperGetMv("MV_SUMINTA",NIL,2) == 1

DEFAULT aTabCalend	:= {}
DEFAULT aMarcacoes	:= {}   
DEFAULT aMarcNoGer	:= {}
DEFAULT dPerIni		:= Ctod("//")
DEFAULT dPerFim		:= Ctod("//")
DEFAULT cFil		:= cFilAnt 
DEFAULT lChkTables	:= .T.
DEFAULT lSobrepoe	:= .F.
DEFAULT lPnMcAut01	:= ExistBlock( "PNMCAUT01" )

IF ( Empty( dPerIni ) .or. Empty( dPerFim ) )
	PerAponta( @dPerIni , @dPerFim , NIL , NIL , cFil )
EndIF

DEFAULT	_aSpaHeader		:= GdMontaHeader( @_nSpaHeader , NIL , NIL , "SPA" , NIL , .T. , .T. , .F. , .F. , .F. , .F. , .F. , .F. )
DEFAULT	_aSr6Header		:= GdMontaHeader( @_nSr6Header , NIL , NIL , "SR6" , NIL , .T. , .T. , .F. , .F. , .F. , .F. , .F. , .F. )

DEFAULT	_cSpaLastReg	:= "_cSpaLastReg"
DEFAULT _cSr6LastTno	:= "_cSr6LastTno"

DEFAULT _cSpceFuncao	:= Space( GetSx3Cache( "P8_FUNCAO " , "X3_TAMANHO" ) )
DEFAULT _cSpceGiro		:= Space( GetSx3Cache( "P8_GIRO   " , "X3_TAMANHO" ) )
DEFAULT _cSpceRelogi	:= Space( GetSx3Cache( "P8_RELOGIO" , "X3_TAMANHO" ) )

DEFAULT lPnmMotMarc		:= ExistBlock( "PNMMOTMARC" )

cUltOrdem	:= aTabCalend[ Len( aTabcalend ) , CALEND_POS_ORDEM ]
nForOrdem	:= Val( cUltOrdem )
nLenTab		:= Len( aTabCalend )
nLenMarc	:= Len( aMarcacoes )
cFilRegra	:= xFilial( "SPA" , cFil )
cFilTurno	:= xFilial( "SR6" , cFil )
cPerAponta	:= Dtos( aTabCalend[ 01 , CALEND_POS_DATA ] )
nPosUltOrd	:= aScan( aTabCalend , { |x| x[ CALEND_POS_ORDEM ] == cUltOrdem .and. x[ CALEND_POS_TIPO_MARC ] == "1E" } )
cPerAponta	+= Dtos( aTabCalend[ nPosUltOrd , CALEND_POS_DATA ] )

IF !( lChkTables )
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Carrega Informacoes da Regra de Apontamento          	      Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	cMarcAut := StrTran( GetMemVar( "PA_MARCAUT" ) , "*" , "" )
	cMarcAut += IF( SubStr(cMarcAut,-1) != "-" .and. !Empty(cMarcAut) , "-" , "" )
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Carrega Informacoes da Regra de Apontamento          	      Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	lAleat	  		:= ( GetMemVar( "PA_ALEATOR" ) == "S" )
	lAutomSM    	:= ( GetMemVar( "PA_AUTOMSM" ) == "S" )
	lCompletaMar	:= ( GetMemVar( "PA_COMPMAR" ) == "S" )
	nMinuto			:= Abs( GetMemVar( "PA_MINALEA" ) )
	
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Verifica se Devera Gerar Marcacoes em Dias Nao Trabalhados  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	lAutoSai := !Empty( cAutoSai := AllTrim( StrTran( GetMemVar( "R6_AUTOSAI" ) , "*" , "" ) ) )
EndIF

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Garante que as marcacoes de um dia nao interfiram no proximoЁ
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
aMarcNoGer	:= {}

If lPort1510
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Inicializa desc. do motivo para geracao automatica.         Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	cMotivoAut 	 := fInitMotivo(xFilial("RFD"),"1","4")
	cMotivoInc 	 := fInitMotivo(xFilial("RFD"),"1","1")
	If lPnmMotMarc
		IF ( ValType( cRet := ExecBlock( "PNMMOTMARC", .F. , .F. , ) ) == "C" )
		   cMotivoInc := cRet
		EndIf   
	EndIf	
	cCodMot		 := fInitCodMot(xFilial("RFD"),"1","2")
	cSpaceNumRep := Space( GetSx3Cache( "P8_NUMREP" , "X3_TAMANHO" ) )
	cSpaceMotivo := Space( GetSx3Cache( "P8_MOTIVRG" , "X3_TAMANHO" ) )
	cSpaceTpMar	 := Space( GetSx3Cache( "P8_TPMCREP" , "X3_TAMANHO" ) )
EndIf

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Processa para Todas as Ordens da Tabela de Horario		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
For nOrdem := 1 To nForOrdem

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Inicializa as Variaveis									  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	cOrdem			:= StrZero( nOrdem , __nTamP8Ordem )
    cTipMarcDia		:= ""
    cMarcsObriga	:= ""
    lMarcsObriga	:= .F.
	
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Procura a Ordem em aTabCalend.                              Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( nTab := aScan( aTabCalend, { |x| x[CALEND_POS_ORDEM] == cOrdem .and. x[CALEND_POS_TIPO_MARC] == "1E"  } ) ) > 0
	
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica se Esta Dentro do Periodo de Apontamento           Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( aTabCalend[ nTab , CALEND_POS_DATA ] < dPerIni .or. aTabCalend[ nTab , CALEND_POS_DATA ] > dPerFim )
			Loop
		EndIF
        //- Guarda a Data de Apontamento para uso no registro de marcacoes nao geradas para o dia
		dDtApo 		:=  aTabCalend[ nTab , CALEND_POS_DATA ] 
		aMarcGer	:= {}

		IF ( nPosRg := aScan( aSpaInfo , { |x| x[1] == cFilRegra .and. x[2] == aTabCalend[ nTab , CALEND_POS_REGRA ] } ) ) == 0
			#IFDEF TOP
				aSvAlias := GetArea()
					
				cCondSPA := "% PA_FILIAL = '"+cFilRegra+"' AND "
				cCondSPA += "PA_CODIGO = '"+aTabCalend[ nTab , CALEND_POS_REGRA ]+"' %"
								
				cQrySPA := GetNextAlias()

				BeginSql alias cQrySPA
					SELECT R_E_C_N_O_ RECNO
					FROM %table:SPA% SPA
					WHERE
					%exp:cCondSPA% AND SPA.%NotDel%
				EndSql
				
				If (cQrySpa)->(!Eof())
					SPA->( MsGoto( (cQrySpa)->RECNO ) )						
					(cQrySPA)->(dbCloseArea())
				Else
					(cQrySPA)->(dbCloseArea())
					Loop
				EndIf
				
				RestArea( aSvAlias )
			#ELSE

				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Posiciona na Regra do Calendario							  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF !PosSPA( aTabCalend[ nTab , CALEND_POS_REGRA ] , cFilRegra , NIL , 1 , .F. )
					Loop
				EndIF

			#ENDIF
        
        Else
			SPA->( MsGoto( aSpaInfo[nPosRg, 5] ) )        	
        EndIf
	
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁSeta os Campos da Regra									  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF (;
				( lChkTables );
				.and.;
				(;
					( _cSpaLastReg <> ( cFilRegra + aTabCalend[ nTab , CALEND_POS_REGRA ] ) );
					.or.;
					!( lSpaIsMemVar );
				);
			)

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Armazena Filial e Regra Anterior                     	      Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			_cSpaLastReg := ( cFilRegra + aTabCalend[ nTab , CALEND_POS_REGRA ] )

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Obtem as informacoes em Cache do SPA                        Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			aFields	:= {}
			For nField := 1 To _nSpaHeader
				aAdd( aFields , _aSpaHeader[ nField , __AHEADER_FIELD__ ] )
			Next nField
			aFields := PosSPA( aTabCalend[ nTab , CALEND_POS_REGRA ] , cFilRegra , aFields , 1 , .F. )

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Carrega e Alimenta as Variaveis de Memoria para o SPA	      Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			For nField := 1 To _nSpaHeader
				SetMemVar( _aSpaHeader[ nField , __AHEADER_FIELD__ ] , aFields[ nField ] , .T. )
			Next nField

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Verifica se as Variaveis de Memoria foram Carregadas 	      Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			lSpaIsMemVar := IsMemVar( "PA_MARCAUT" )

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Carrega Informacoes da Regra de Apontamento          	      Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			cMarcAut := StrTran( GetMemVar( "PA_MARCAUT" ) , "*" , "" )
			cMarcAut += IF( SubStr(cMarcAut,-1) != "-" .and. !Empty(cMarcAut) ,"-" , "" )

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Carrega Informacoes da Regra de Apontamento          	      Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			lAleat	  		:= ( GetMemVar( "PA_ALEATOR" ) == "S" )
			lAutomSM    	:= ( GetMemVar( "PA_AUTOMSM" ) == "S" )
			lCompletaMar	:= ( GetMemVar( "PA_COMPMAR" ) == "S" )
			nMinuto			:= Abs( GetMemVar( "PA_MINALEA" ) )
			
			If lPort1510
				cIntPreDet	:= AllTrim( StrTran( GetMemVar( "PA_ASSIN" ) , "I" , "" ) )
				If !Empty(cIntPreDet)
					cIntPreDet := cIntPreDet + "S|" + Alltrim(Str(Val(cIntPreDet) + 1)) + "E"    //-nS|nE
				EndIf
			EndIf
			
			DEFAULT lCompletaMar	:= .F.

		EndIF

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Se nao Tiver Marcacoes a Gerar Vai Para o Proximo Dia	      Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF Empty( nMarcAut := Len( cMarcAut ) )
			Loop
		EndIF

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica se Funcionario Trabalha em Dias Feriado     	      Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		lTrabFer	:= (;
							aTabCalend[	nTab , CALEND_POS_FERIADO		];
							.and.;
							aTabCalend[	nTab , CALEND_POS_TRAB_FERIADO	];
						)	

		IF ( nPosTr := aScan( aSr6Info , { |x| x[1] == cFilTurno .and. x[2] == aTabCalend[ nTab , CALEND_POS_TURNO ] } ) ) == 0
			#IFDEF TOP			
				aSvAlias := GetArea()
				
				cCondSR6 := "% R6_FILIAL = '"+cFilTurno+"' AND "
				cCondSR6 += "R6_TURNO  = '"+aTabCalend[ nTab , CALEND_POS_TURNO ]+"' %"
								
				cQrySR6 := GetNextAlias()
				
				BeginSql alias cQrySR6
					SELECT R_E_C_N_O_ RECNO
					FROM %table:SR6% SR6
					WHERE
					%exp:cCondSR6% AND SR6.%NotDel%
				EndSql
				
				If (cQrySr6)->(!Eof())
					SR6->( MsGoto( (cQrySR6)->RECNO ) )						
					(cQrySR6)->(dbCloseArea())
				Else
					(cQrySR6)->(dbCloseArea())
					Loop
				EndIf		     	
                
				RestArea( aSvAlias )
			#ELSE			
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Posiciona no Turno do Calendario							  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF !PosSR6( aTabCalend[ nTab , CALEND_POS_TURNO ] , cFilTurno , NIL , 1 , .F. )
					Loop
				EndIF

			#ENDIF			

        Else
	        SR6->( MsGoto( aSr6Info[nPosTr, 10] ) )
        EndIf

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁSeta os Campos do Turno									  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF (;
				( lChkTables );
				.and.;
				(;
					( _cSr6LastTno <> ( cFilTurno + aTabCalend[ nTab , CALEND_POS_TURNO ] ) );
					.or.;
					!( lSr6IsMemVar );
				);	
			)	

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Armazena Filial e Turno Anterior                     	      Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			_cSr6LastTno := ( cFilTurno + aTabCalend[ nTab , CALEND_POS_TURNO ] )

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Obtem as informacoes em Cache do SR6                        Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			aFields	:= {}
			For nField := 1 To _nSr6Header
				aAdd( aFields , _aSr6Header[ nField , __AHEADER_FIELD__ ] )
			Next nSpaHeader
			aFields := PosSR6( aTabCalend[ nTab , CALEND_POS_TURNO ] , cFilTurno , aFields , 1 , .F. )

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Carrega e Alimenta as Variaveis de Memoria para o SR6	      Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			For nField := 1 To _nSr6Header
				SetMemVar( _aSr6Header[ nField , __AHEADER_FIELD__ ] , aFields[ nField ] , .T. )
			Next nField

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Verifica se as Variaveis de Memoria foram Carregadas 	      Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			lSr6IsMemVar := IsMemVar( "R6_AUTOSAI" )

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Verifica se Devera Gerar Marcacoes em Dias Nao Trabalhados  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			lAutoSai := !Empty( cAutoSai := AllTrim( StrTran( GetMemVar( "R6_AUTOSAI" ) , "*" , "" ) ) )

		EndIF

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica os Tipos de Marcacoes para o Dia                   Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		For nMarc := nTab To nLenTab
			IF ( aTabCalend[ nMarc , CALEND_POS_ORDEM ] == cOrdem )
				cUltmarc	:=  ( aTabCalend[ nMarc , CALEND_POS_TIPO_MARC ] + "-" ) 
				cTipMarcDia += cUltmarc
			Else
				Exit
			EndIF	
		Next nMarc  
		
    	/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁLimita as Marcacoes automaticas a maior marcacao da Tabela   Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/ 
		cNewMarcAut	:= "" 
		IF !empty(cUltmarc)        	
	       	For nMarc := 1 To Len(cMarcAut) Step 3
			
	       		cMarc:= SubStr( cMarcAut , nMarc , 3 )
	       		If cMarc <= cUltmarc
		       		cNewMarcAut+= cMarc
		       	Endif
	
	       	Next nX
        Else 
	        cNewMarcAut:= cMarcAut
        Endif          
        
    	/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica novamente a existencia de marcacoes a gerar	      Ё
		Ё Se nao Tiver Marcacoes a Gerar Vai Para o Proximo Dia	      Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF Empty( nMarcAut := Len( cNewMarcAut ) )
			Loop
		EndIF    
	
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica Quais Marcacoes sao Obrigatorias                   Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
       	cMarcsObriga	:= cTipMarcDia
       	nMarcsGer	 	:= 0
       	For nMarc := 1 To nMarcAut Step 3
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Apura o Numero de Marcacoes a Gerar						  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			nMarcsGer++
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁSe Todas as Marcacoes Obrigatorias Foram Efetuadas sai do ForЁ
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
       		IF Empty( cMarcsObriga := StrTran( cMarcsObriga , SubStr( cNewMarcAut , nMarc , 3 ) , "" ) )
       			Exit
       		EndIF
       	Next nX

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Reinicializa as Variaveis Tabela e Marcacoes                Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		aTDia := {}
		aMDia := {}


		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё N└o gera Marca┤oes Autom═ticas em Feriados e Dias Nao Traba Ё
		Ё lhados                                                      Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF (;
					aTabCalend[ nTab , CALEND_POS_FERIADO ];
					.and.;
					!( lTrabFer );
					.and.;
					!( lAutosai );
			)		
			Loop
		EndIF

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё N└o gera Marca┤oes Autom═ticas Para Funcionarios Afastados  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( aTabCalend[ nTab , CALEND_POS_AFAST ] )
			IF (;
					(;
						( aTabCalend[nTab,CALEND_POS_DATA] >= aTabCalend[ nTab , CALEND_POS_INI_AFAST ] );
						.and.;
						( aTabCalend[nTab,CALEND_POS_DATA] <= aTabCalend[ nTab , CALEND_POS_FIM_AFAST ] );
					);	
					.or.;
					(;
						( aTabCalend[nTab,CALEND_POS_DATA] >= aTabCalend[ nTab , CALEND_POS_INI_AFAST ] );
						.and.;
						Empty( aTabCalend[ nTab , CALEND_POS_FIM_AFAST ] );
					);
				)	
				Loop
			EndIF
		EndIF

		While (;
					( nTab <= nLenTab );
					.and.;
					( cOrdem == aTabCalend[ nTab , CALEND_POS_ORDEM ] );
			  )
			aAdd( aTDia,;
							{;
								aTabCalend[ nTab , CALEND_POS_DATA		]	,;	//01 - Data
						   		aTabcalend[ nTab , CALEND_POS_HORA		]	,;	//02 - Hora
						   		aTabCalend[ nTab , CALEND_POS_TIPO_MARC	]	,;	//03 - Tipo Marcacao
						   		aTabCalend[ nTab , CALEND_POS_TIPO_DIA	]	,;	//04 - Tipo do Dia
						   		aTabCalend[ nTab , CALEND_POS_HRS_INTER	]	,;	//05 - Horas de Intervalo
						   		aTabCalend[ nTab , CALEND_POS_TURNO		]	,;	//06 - Turno de Trabalho
						   		aTabCalend[ nTab , CALEND_POS_CC		]	,;	//07 - Centro de Cuto
						   		aTabCalend[ nTab , CALEND_POS_FERIADO	]	,;	//08 - Dia Corresponde a Feriado
						   		aTabCalend[ nTab , CALEND_POS_HRS_TRABA	]	,;	//09 - Horas Trabalhadas
						   		aTabCalend[ nTab , CALEND_POS_SEQ_TURNO	]	 ;	//10 - Sequencia do Turno
							};
				 )
			nTab++
		End While
		nTab := 0
		aEval( aTDia , { |x| nTab := SomaHoras( nTab , x[9] ) } )
	
	Else

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Nao Encontrou a Ordem no Calendario                         Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		Loop

	EndIF

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Procura a Ordem em aMarcacoes.                              Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( ( nMarc := aScan( aMarcacoes, { |x| x[3] == cOrdem } ) ) > 0 )
		While (;
					( nMarc <= nLenMarc );
					.and.;
					( cOrdem == aMarcacoes[ nMarc , 3 ] );
			   )
			aAdd( aMDia , { aMarcacoes[ nMarc , 1 ] , aMarcacoes[ nMarc , 2 ], nMarc, aMarcacoes[ nMarc ,AMARC_FLAG] } )
			nMarc++
		End While
		nMarc := 0
	EndIF

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё So Gerar Marcacoes nos Dias em Que Existirem Marcacoes ou seЁ
	Ё Tiver Horas Trabalhadas no Calendario de Marcacoes          Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF (;
			( nTab == 0 );
			.or.;
			(;
				Empty( aMDia );
				.and.;
				!( lAutomSM );  
			 );
		)
		Loop
	EndIF

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё S╒ gera Marca┤oes Autom═ticas se o tipo do dia for "S"im.   Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF !( aTDia[1,4] == "S" )
	    IF ( lAutoSai ) 
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё S╒ gera Marca┤oes Autom═ticas se o tipo do dia for "C"-Compensado Ё
			Ё ou "D" - Descanso ou Dia marcacao for Feriado					    Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF !(;
					( aTDia[1,4] $ cAutoSai );
					.or.;
					( aTDia[1,8] );
				 )
				Loop
			EndIF
		Else
			Loop
		EndIF			
	EndIF

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Verifica Qual Horario da Tabela Esta Sem Marcacao           Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	aTab_Marc := StuffMarcTab( aTDia , aMDia )

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Inverte Marcacao de Entrada de Intervalo com Marcacao de  EnЁ
	Ё trada Quando Marcacao de Intervalo for Menor que Marcacao daЁ
	Ё tabela													  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	AjustMarc( aTDia , NIL , aTab_Marc , NIL , cNewMarcAut , .T. , aClone( aMDia ) , lAutoSai )

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Insere a marcacao lida e nao incluida no aTab_Marc qdo. se  Ё
	Ё tratar da ultima saida (situacao nao contemplada na aproxim.Ё
	Ё de horarios de StuffMarcTab).								  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	nTab_Marc := Len( aTab_Marc )
	
	For nMarc := 1 To Len( aMDia )
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica se a marcacao ja foi incluida em aTabMarc.         Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( aScan( aTab_Marc, { |x| If( !Empty( x[ 2 ] ), x[ 2, 1 ] == aMDia[ nMarc , 1 ] .And. x[ 2 , 2 ] == aMDia[ nMarc , 2 ], .F. ) } ) == 0 )
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Nao encontrou ultima saida e a marcacao nao lida e nao      Ё
			Ё incluida eh maior que a ultima saida prevista no calendario,Ё
			Ё entao assume como sendo a ultima saida.                     Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF Empty( aTab_Marc[ nTab_Marc , 2 ] ) .And. DataHora2Str( aMDia[ nMarc , 1 ] , aMDia[ nMarc , 2 ] ) > aTab_Marc[ nTab_Marc , 4 ]
				aTab_Marc[ nTab_Marc , 2 ] := { aMDia[ nMarc , 1 ], aMDia[ nMarc , 2 ] }
				aTab_Marc[ nTab_Marc , 3 ] := nMarc
				aTab_Marc[ nTab_Marc , 4 ] := DataHora2Str( aTab_Marc[ nTab_Marc , 1 , 1 ] , aTab_Marc[ nTab_Marc , 1 , 2 ] )
				aTab_Marc[ nTab_Marc , 5 ] := aMDia[ nMarc , 3 ]
			EndIF
		EndIF
	Next nMarc                     

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Ponto de Entrada para Remanejamento dos Horarios de         Ё
	Ё Tabela X Marcacoes realizadas.						      Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	If lPnMcAut01                                                     
		If ( ValType( uRet := ExecBlock("PNMCAUT01" , .F. , .F. , {aTab_Marc, aTDia, aMdia,  cNewMarcAut  } ) ) == "A" )
		   aTab_Marc:= aClone(uRet)
		Endif
	Endif
	

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Totaliza o Numero de Marcacoes ja Efetuadas                 Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	nMarcsEfe := 0
	cMarcsEfe := ""
	MarcEfetuadas(aTab_Marc, lSobrepoe,  cTipMarcDia,  cMarcsObriga, @nMarcsEfe, @cMarcsEfe) 
	        
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Verifica se as Marcacoes Obrigatorias foram efetuadas       Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
    IF !( lMarcsObriga := ( Empty( cMarcsObriga ) .and. Empty( cMarcsEfe ) ) )
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё So verifica as Marcacoes Obrigatorias se nao for   CompletarЁ
		Ё as Marcacoes que Faltam 									  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
    	IF !( lCompletaMar )
    		For nMarc := 1 To Len( cMarcsObriga ) Step 3
       			IF !( lMarcsObriga := ( SubStr( cMarcsObriga , nMarc , 3 ) $ cMarcsEfe ) )
       				Exit
				EndIF
       		Next nX
       	EndIF	
    ElseIF (;
    			( lCompletaMar );
    			.and.;
    			( lAutomSM );
    		 )
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Deixar a Carga de Todas as Marcacoes, quando estas nao  exisЁ
		Ё tirem, para lAutomSM     									  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
    	lCompletaMar := .F.
    EndIF

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Gera as Marcacoes Automaticas                               Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF (;
			(;
				( lMarcsObriga );
				.or.;
				( lCompletaMar );
			);
			.and.;
			( ( nFornY := Len( aTab_Marc ) ) > 0 );
		 )            
		 
		 If !( lSobrepoe )
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁRecalcula as marcacoes a serem geradas subtraindo as marca-  Ё
			Ёcoes efetuadas.											  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			For nMarc := 1 To Len(cMarcsEfe) Step 3
				
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				ЁDiminue as marcacoes geradas a cada marcacao ja efetuada     Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	       		IF SubStr( cMarcsEfe , nMarc , 3 )$ cNewMarcAut
					nMarcsGer--
	       		EndIF
	       	Next nX
	
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Se todas as marcacoes a gerar ja foram efetuadas vai para a Ё
			Ё proxima ordem.											  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/		       	
			If Empty(nMarcsGer)
			   Loop
			Endif
		Endif
		
		//-- Inicializa todas as marcacoes do dia (Antigas e Geradas)
		aMarcDia	:= aclone(aMDia)
		
		nPosInt := 0
		
		For nY := 1 To nFornY

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё So Gera Quando Nao Existir Marcacoes ou se Sobrescreve      Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF (;
					!Empty( aTab_Marc[ nY , 02 ] );
					.and.;
					!( lSobrepoe );
				) 
				 //-- Altera o estado do flag para nao demonstra-lo como automatico ("A") no caso de log de
                 //-- geracao de marcacoes impares. 
                 If !Empty(aMarcDia)
                    If !Empty(aTab_Marc[nY, 03])
		                 aMarcDia[aTab_Marc[nY, 03],4] := "E"				
		            Endif
		         Endif        
				Loop
			EndIF

			IF ( nPos := aScan( aTDia , { |x|	x[1] == aTab_Marc[ nY , 01 , 01 ] .and. ;
			   									x[2] == aTab_Marc[ nY , 01 , 02 ]		;
									    };
						      );
				) > 0 
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				ЁVerifica se Devera Gerar a Marcacao Automatica para o Tipo deЁ
				ЁMarcacao em questao. Se o Tipo Nao Estiver Selecionado e a DiЁ
				Ёferenca de Horas Entre o Tipo Selecionado e um Tipo  ImediataЁ
				Ёmente Anterior ou Posterior Que Tenha Sido Selecionado    forЁ
				Ёigual, tambem Gera a Marcacao Automatica. Pois Neste caso naoЁ
				Ёda Para Identificar a Quem Pertence a Marcacao Efetuada.     Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF (;
						(;
							AjustMarc( aTDia , nPos , aTab_Marc , nY , cNewMarcAut );
							.or.;
							( aTDia[nPos,3] $ cNewMarcAut );
						 );
						.and.;
				   		( Len( aTDia ) - nMarcsGer >= nMarcsEfe );
				   	)	
                Else
                    //-- Altera o estado do flag para nao demonstra-lo como automatico ("A") no caso de log de
                    //-- geracao de marcacoes impares.
                    If !Empty(aMarcDia)
	                    If !Empty(aTab_Marc[nY, 03])
			                 aMarcDia[aTab_Marc[nY, 03],4] := "E"				
			            Endif
			        Endif   
                	Loop
                EndIF
			Else
					 //-- Altera o estado do flag para nao demonstra-lo como automatico ("A") no caso de log de
                    //-- geracao de marcacoes impares.
                    If !Empty(aMarcDia)
	                    If !Empty(aTab_Marc[nY, 03])
			                 aMarcDia[aTab_Marc[nY, 03],4] := "E"				
			            Endif
			        Endif  
				Loop
			EndIF

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁRetorna as Horas Maximas Para a Geracao Aleatoria. Os MinutosЁ
			ЁAleatorios nao  podem Exceder `a metada da Jornada.		  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF ( lAleat ) //Marcacao Aleatoria
				IF ( nTab := aScan( aTabCalend, { |x| x[CALEND_POS_TIPO_MARC] == aTDia[nPos,3] .and. x[CALEND_POS_DATA] == aTDia[nPos,1] } ) ) > 0
					IF ( aTabCalend[ nTab , CALEND_POS_HRS_INTER ] > 0 .or. SubStr(aTDia[nPos,3],-1) == "E" )
						IF ( lInterv := ( aTabCalend[ nTab , CALEND_POS_HRS_INTER ] > 0 ) )
						    nInterv := Min( ( __Hrs2Min( aTabCalend[ nTab , CALEND_POS_HRS_INTER ] ) / 2 ) , nMinuto )
						ElseIF ( lInterv := ( aTabCalend[ Max( 1 , nTab - 1 ) , CALEND_POS_HRS_INTER ] > 0 ) )
							nInterv := Min( ( __Hrs2Min( aTabCalend[ Max( 1 , nTab - 1  ) , CALEND_POS_HRS_INTER ] ) / 2 ) , nMinuto )
						EndIF
					EndIF
					IF ( aTabCalend[ nTab , CALEND_POS_HRS_TRABA ] > 0 .or. SubStr(aTDia[nPos,3],-1) == "S" )
						IF ( aTabCalend[ nTab , CALEND_POS_HRS_TRABA ] > 0 )
						    nHrTrab := Min( ( __Hrs2Min( aTabCalend[ nTab , CALEND_POS_HRS_TRABA ] ) / 2 ) , nMinuto )
						ElseIF ( aTabCalend[ Max( 1 , nTab - 1 ) , CALEND_POS_HRS_TRABA ] > 0 )
							nHrTrab := Min( ( __Hrs2Min( aTabCalend[ nTab - 1 , CALEND_POS_HRS_TRABA ] ) / 2 ) , nMinuto )
						EndIF
					EndIF	
				EndIF
				dDtMarc	:= aTDia[nPos,1]
				nMarc	:= aTDia[nPos,2]
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Gera minutos aleatorios									  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF ( SubStr(aTDia[nPos,3],-1) == "E" ) //-- Marcacoes de entrada
					IF lInterv
						If lSumIntAleat
							//Se houve marcacao anterior soma a diferenca entre o realizado e o programado
							If Len(aMarcGer) > 0
								nMarc := aTDia[nPos,2] + (aMarcGer[Len( aMarcGer ),2] - aTDia[nPos-1,2])
							EndIf						
							nMarc := DataHora2Ale(@dDtMarc,nMarc,nInterv,@nAleato,"S")
						Else
							nMarc := DataHora2Ale(@dDtMarc,nMarc,nInterv,@nAleato,"E")
						EndIf					
					Else
						nMarc := DataHora2Ale(@dDtMarc,nMarc,nHrTrab,@nAleato,"E")
					EndIF	
				Else //-- Marcacoes de saida
					IF lInterv
						nMarc := DataHora2Ale(@dDtMarc,nMarc,nInterv,@nAleato,"S")
					Else
						nMarc := DataHora2Ale(@dDtMarc,nMarc,nHrTrab,@nAleato,"S")
					EndIF	
				EndIF
      			lInterv := .F.
      		Else
      			dDtMarc	:= aTDia[nPos,1]
      			nMarc	:= aTDia[nPos,2]
      		EndIF	
            
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Obtem o Tipo de Marcacao a Ser Gerada						  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			cTpMarc := aTDia[nPos,3]

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Carrega as Marcacoes Automaticas							  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			aAdd( aMarcGer , Array( ELEMENTOS_AMARC + 1 ) )
			nLenMAuto := Len( aMarcGer )
			aMarcGer[ nLenMAuto , AMARC_DATA		] := dDtMarc											// 01 - Data
			aMarcGer[ nLenMAuto , AMARC_HORA		] := nMarc												// 02 - Hora
			aMarcGer[ nLenMAuto , AMARC_ORDEM		] := cOrdem												// 03 - Ordem
			aMarcGer[ nLenMAuto , AMARC_FLAG		] := "A"												// 04 - Flag
			aMarcGer[ nLenMAuto , AMARC_RECNO		] := 0													// 05 - Recno
			aMarcGer[ nLenMAuto , AMARC_TURNO		] := aTDia[nPos,6]										// 06 - Turno
			aMarcGer[ nLenMAuto , AMARC_FUNCAO		] := _cSpceFuncao              							// 07 - Funcao
			aMarcGer[ nLenMAuto , AMARC_GIRO		] := _cSpceGiro               							// 08 - Giro
			aMarcGer[ nLenMAuto , AMARC_CC			] := IF(!Empty(aTDia[nPos,7]),aTDia[nPos,7],cCusto )	// 09 - Centro Custo
			aMarcGer[ nLenMAuto , AMARC_APONTA		] := "N"												// 10 - Flag de Apontamento
			aMarcGer[ nLenMAuto , AMARC_RELOGIO		] := _cSpceRelogi               						// 11 - Relogio
			aMarcGer[ nLenMAuto , AMARC_TIPOMARC	] := cTpMarc											// 12 - Tipo da Marcacao
			aMarcGer[ nLenMAuto , AMARC_L_ORIGEM	] := .F.												// 13 - Logico
			aMarcGer[ nLenMAuto , AMARC_DTHR2STR	] := DataHora2Str(;                                          
																	aMarcGer[ nLenMAuto , AMARC_DATA ] ,;
																	aMarcGer[ nLenMAuto , AMARC_HORA ]  ;
																  )                                    		//14 - String de Data/Hora para aSort
			aMarcGer[ nLenMAuto , AMARC_PERAPONTA	] := cPerAponta											//15 - String de Data com o Periodo de Apontamento
			If lPort1510
	            If( aTDia[nPos,3] $ cIntPreDet )
	            	lIntPreDet := .T.
	            Else
	            	lIntPreDet := .F.
	            EndIf
    			
				aMarcGer[ nLenMAuto , AMARC_DATAAPO	] := dDtApo												//25 - Data de Apontamento
				aMarcGer[ nLenMAuto , AMARC_NUMREP	] := cSpaceNumRep										//26 - Numero do REP
				aMarcGer[ nLenMAuto , AMARC_TPMCREP	] := cSpaceTpMar										//27 - Tipo de Marcacao no REP
				aMarcGer[ nLenMAuto , AMARC_TIPOREG	] := If(lIntPreDet,"P","I")								//28 - Tipo de Registro
				aMarcGer[ nLenMAuto , AMARC_MOTIVRG	] := If(lIntPreDet,cMotivoAut,cMotivoInc)  				//29 - Motivo da inclusao
				aMarcGer[ nLenMAuto , AMARC_SEQ		] := aTDia[nPos,10]										// 06 - Semana/Sequencia do Turno
			EndIf
			aMarcGer[ nLenMAuto , ELEMENTOS_AMARC  + 1 ] := If( !EMPTY( aTab_Marc[ nY, 02 ] ), aTab_Marc[ nY , 05 ], 0 ) //16 - Ponteiro para a marcacao a ser subsituida (se possuir hora correspondente) ou incluida (o trabalhador nao realizou a marcacao)

			//-- Marcacoes do dia (Antigas e Geradas)
			 If !EMPTY( aTab_Marc[ nY, 02 ] ) 
			 	If !Empty(aMarcDia)
				    If !Empty(aTab_Marc[nY, 03]) 
					    aMarcDia[ aTab_Marc[ nY , 03 ],1 ]:= dDtMarc
					    aMarcDia[ aTab_Marc[ nY , 03 ],2 ]:= nMarc
					    aMarcDia[ aTab_Marc[ nY , 03 ],4 ]:= "A"
				    Endif
				Endif    
			 Else
			    aAdd(aMarcDia, { dDtMarc, nMarc,0, "A"	}  )
			 Endif
			    
		Next nY
        
        //-- Verifica se serao geradas marcacoes em quantidade impar
        If ( Len(aMarcDia) % 2 ) > 0                                         
       		aSort( @aMarcDia , NIL , NIL , { |x,y| ( Dtoc(x[1]) + StrZero( x[2] , 5 , 2 ) ) <  ( Dtoc(y[1]) + StrZero( y[2] , 5 , 2 ) ) } )
            AADD(aMarcNoGer, {dDtApo, aClone( aMarcDia ), "IMPAR" } )
        Else                                        
            //-- Adiciona cada uma das marcaГУes geradas para a ordem lida
            Aeval(aMarcGer, {|x| AADD(aMAuto, aClone(x) ) } )
        Endif
        
	EndIF

Next nOrdem

/*/                  
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё As Marca┤oes Autom═ticas s└o Transferidas para o aMarcacoes.Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( ( nLenMarc := Len( aMAuto ) ) > 0 )

	For nMarc := 1 To nLenMarc
        If Empty( aMAuto[ nMarc , ELEMENTOS_AMARC  + 1 ] ) 
		    nPos := aScan(	aMarcacoes, { |x|;
		    									x[ AMARC_DATA  		] == aMAuto[ nMarc , AMARC_DATA  		];
		    									.and.;
												x[ AMARC_TIPOMARC  	] == aMAuto[ nMarc , AMARC_TIPOMARC  	];
												.and.;
												x[ AMARC_ORDEM 		] == aMAuto[ nMarc , AMARC_ORDEM 		];
								  		};
					 	  )
        Else 
        	nPos :=  aMAuto[ nMarc , ELEMENTOS_AMARC  + 1 ] 
        Endif
		IF ( nPos > 0 )

			IF !( lSobrepoe ) .or. ( lPort1510 .and. aMarcacoes[ nPos , AMARC_TIPOREG] == "O" )
		    	Loop
		    EndIF

			nSvRecno 						:= aMarcacoes[ nPos , AMARC_RECNO ]
			aMarcacoes[ nPos ]				:= aClone( aMAuto[ nMarc ] ) 
			aMarcacoes[ nPos , AMARC_RECNO]	:= nSvRecno

		Else

			aAdd( aMarcacoes , aClone( aMAuto[ nMarc ] ) )

		EndIF

	Next nMarc

EndIF

/*/	
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё O Array aMarcacoes ┌ indexado por Ordem + Data + Hora.      Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( lAuto := !ArrayCompare( aMarcacoes , aCloneMarc ) )
	aSort( @aMarcacoes , NIL , NIL , { |x,y|	(x[AMARC_ORDEM]+x[AMARC_DTHR2STR]);
								 				<;
								     			(y[AMARC_ORDEM]+y[AMARC_DTHR2STR]);
						     		  };
		  )
EndIF

Return( lAuto )

/*/
зддддддддддбддддддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁMarcEfetuadas Ё Autor ЁMauricio MR			  Ё Data Ё17/06/2005Ё
цддддддддддеддддддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁCalcula o numero de marcacoes efetuadas	                       	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL																Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function MarcEfetuadas(aTab_Marc, lSobrepoe,  cTipMarcDia,  cMarcsObriga, nMarcsEfe, cMarcsEfe)
Local cTipMarc	:= ""
Local nX		:= 0     
Local nFor 		:= Len(aTab_Marc)

For nX:=1 to nFor
    //-- Se Existir marcacao 
	If !Empty( aTab_Marc[ nX, 2 ] ) 
		If !lSobrepoe
		    //-- Acumula todas as marcacoes efetuadas
		    nMarcsEfe++
		    cMarcsEfe+= SubStr(cTipMarcDia, Getfxy( 3, nX ), 3 ) 	
		Else                                               
		    //-- Acumula como efetuadas apenas as marcacoes que devem existir (as nao selecionadas para gerar)
		    cTipMarc := SubStr(cTipMarcDia, Getfxy( 3, nX ), 3 )
		    If cTipMarc  $ cMarcsObriga
				cMarcsEfe+= cTipMarc
			    nMarcsEfe++
			Endif 
		Endif		 	
	Endif 
Next nX 		 
REturn ( NIL )

/*/
зддддддддддбддддддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁRstMarcAuto	  Ё Autor ЁMarinaldo de Jesus     Ё Data Ё05/10/2004Ё
цддддддддддеддддддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁReinicializa as Statics em PutMarcAuto()                       	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL																Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RstMarcAuto()

_aSpaHeader		:= NIL
_aSr6Header		:= NIL

_cSr6LastTno	:= NIL
_cSpaLastReg	:= NIL
_cSpceFuncao	:= NIL
_cSpceGiro		:= NIL
_cSpceRelogi	:= NIL

lPa_CompMar		:= NIL

_nSpaHeader		:= NIL
_nSr6Header		:= NIL

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁStuffMarcTab ЁAutorЁ Marinaldo de Jesus   Ё Data Ё13/08/2001Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁUnir Array de Marcacoes x Tabela para verificar a Marcacao  Ё
Ё          Ёque falta.													Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁStuffMarcTab( aTab , aMarc )     						    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁPutMarcAuto()                                               Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁArray com os Respectivos pares Marcacoes x Tabela           Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ aTab  = Array com os Horarios da Tabela                    Ё
Ё          Ё aMarc = Array com as Marcacoes do Funcionario              Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function StuffMarcTab( aTab , aMarc )

Local aUnion		:= {}
Local aTemp			:= {}
Local aTemp1		:= {}
Local cDtHr1		:= ""
Local cDtHr2		:= ""
Local nHora1		:= 0
Local nHora2		:= 0
Local nTab   		:= 0
Local nForTab		:= Len( aTab )
Local nMarc	 		:= 0
Local nForMarc		:= Len( aMarc )

For nTab  := 1 To nForTab
	aTemp := {}
	For nMarc := 1 To nForMarc
		aAdd( aTemp , { nMarc , DataHora2Val(	aTab[  nTab , 01  ]		,;
											 	aTab[  nTab , 02  ]		,;
											 	aMarc[ nMarc , 01 ]		,;
											 	aMarc[ nMarc , 02 ]		,;
											 	"H"						 ;
											  ),;
											 	aMarc[ nMarc , 03 ]     ;
						};											  
			 )
	Next nMarc
	aSort( @aTemp , NIL , NIL , { |x,y| x[2] < y[2] } )
	IF !Empty( aTemp )
		aAdd( aUnion , { { aTab[ nTab , 01 ] , aTab[ nTab , 02 ] }							 ,;
						 { aMarc[ aTemp[ 01 , 01 ] , 01 ] , aMarc[ aTemp[ 01 , 01 ] , 02 ] } ,;
						 aTemp[ 01 , 01 ],;
						 DataHora2Str( aTab[ nTab , 01 ] , aTab[ nTab , 02 ] ),;
						 aTemp[01,03];
					    };
	     	)
	Else
		aAdd( aUnion , { { aTab[ nTab , 01 ] , aTab[ nTab , 02 ] }	 ,;
						 {}											 ,;
						 0,;
						 DataHora2Str( aTab[ nTab , 01 ] , aTab[ nTab , 02 ] ),;
						 0;
					    };
	     	)
	EndIF	
Next nTab

IF !Empty( aUnion )
	aSort( @aUnion , NIL , NIL , { |x,y| x[4] < y[4] } )
EndIF

IF !Empty( aMarc )

	aTemp := {}
	
	nForTab := Len( aUnion )
	For nTab := 1 To nForTab
		For nMarc := 1 To nForTab
			IF ( ( aUnion[ nTab , 3 ] == aUnion[ nMarc , 3 ] ) .and. !ArrayCompare( aUnion[ nTab ] , aUnion[ nMarc ] ) )
				IF ( aScan( aTemp , { |x| x[4] == aUnion[ nTab , 4 ] } ) == 0 )
					aAdd( aTemp , aClone( aUnion[ nTab ] ) )
					aTemp[ Len( aTemp ) , 03 ] := nTab
				EndIF	
			EndIF   
		Next nMarc
	Next nTab
	
	IF !Empty( aTemp )
	
		aSort( @aTemp , NIL , NIL , { |x,y| x[4] < y[4] } )
	
		nForTab := Len( aTemp )
		For nTab := 1 To nForTab
			cDtHr1 := DataHora2Str( aTemp[ nTab , 02 , 01 ] , aTemp[ nTab , 02 , 02 ] )
			nHora1 := DataHora2Val( aTemp[ nTab , 01 , 01 ] ,;
									aTemp[ nTab , 01 , 02 ] ,;
									aTemp[ nTab , 02 , 01 ] ,;
									aTemp[ nTab , 02 , 02 ] ,;
									"H";
								   )
			IF ( aScan( aTemp1 , { |x| x[1] == cDtHr1 .and. x[2] == aTemp[ nTab , 03 ] .and. x[3] == nHora1 } ) == 0 )
				aAdd( aTemp1 , { cDtHr1 , aTemp[ nTab , 03 ] , nHora1, aTemp[ nTab, 04 ] } )
			EndIF
			For nMarc := nTab + 1 To nForTab
				IF ( cDtHr2 := DataHora2Str( aTemp[ nMarc , 02 , 01 ] , aTemp[ nMarc , 02 , 02 ] ) ) == cDtHr1
					nHora2 := DataHora2Val( aTemp[ nMarc , 01 , 01 ] ,;
											aTemp[ nMarc , 01 , 02 ] ,;
											aTemp[ nMarc , 02 , 01 ] ,;
											aTemp[ nMarc , 02 , 02 ] ,;
											"H";
										   )
					IF ( aScan( aTemp1 , { |x| x[1] == cDtHr2 .and. x[2] == aTemp[ nMarc , 03 ] .and. x[3] == nHora2 } ) == 0 )
						aAdd( aTemp1 , { cDtHr2 , aTemp[ nMarc , 03 ] , nHora2, aTemp[ nMarc, 04 ] } )
					EndIF
					nTab := nMarc
				Else
					Exit
				EndIF
			Next nMarc
		Next nTab
		
		aSort( @aTemp1 , NIL , NIL , { |x,y| x[1] + StrZero( x[3] , 5 , 2 ) < y[1] + StrZero( y[3] , 5 , 2 ) } )
		
		nForTab := Len( aTemp1 )
		For nTab := 1 To nForTab
			For nMarc := nTab + 1 To nForTab
				IF aTemp1[ nMarc , 1 ] == aTemp1[ nTab , 1 ]
					aUnion[ aTemp1[ nMarc , 2 ] , 02 ] := {}
					nTab := nMarc
				Else
					Exit
				EndIF	
			Next nMarc	
		Next nTab
	
	EndIF

EndIF

Return( aUnion )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁAjustMarc()  ЁAutorЁ Marinaldo de Jesus   Ё Data Ё14/08/2001Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁAjustMarc()													Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁAjustMarc(aTDia,nPos,<@>aTab_Marc,nY,cMarcAut,lInverte)		Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁPutMarcAuto()                                               Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁTrue se a Diferenca for Igual                               Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ aTDia    	= Array com as Marcacoes da Tabela de Horario	Ё
Ё          Ё nPos     	= Indice de aTDia								Ё
Ё          Ё aTab_Marc	= Array com Horarios da Tabela x Marcacoes 		Ё
Ё          Ё nY       	= Indice para aTab_Marc                    		Ё
Ё          Ё cMarcaut	= Marcacoes a Serem Geradas						Ё
Ё          Ё lInverte	= Inverter Marcacao de Entrada de Intervalo  comЁ
Ё          Ё              Entrada do Expediente							Ё
Ё          Ё aMDia      = Array com as Reais Marcacoes do Dia			Ё
Ё          Ё lAutoSai   = Se Gera Marcacoes de Intervalo Para Dias N.T. Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function AjustMarc( aTDia , nPos , aTab_Marc , nY , cMarcAut , lInverte , aMDia , lAutoSai )

Local cTipMarc		:= ""
Local dDtTab		:= Ctod("//")
Local dDtMar		:= Ctod("//")
Local lRet			:= .F.
Local nHrTab		:= 0
Local nHrMar		:= 0
Local nLenDia		:= Len( aTDia )
Local nLenTma		:= Len( aTab_Marc )
Local nHora1		:= 0
Local nHora2		:= 0.01
Local nMarcs		:= 0
Local nMarc			:= 0
Local nLenMarcs		:= 0

DEFAULT nPos		:= 0
DEFAULT nY			:= 0
DEFAULT lInverte	:= .F.
DEFAULT aMDia		:= {}

lInverte := IF( lInverte , ( Len( cMarcAut ) == 6 .and. SubStr( cMarcAut , 2 , 1 ) == "S" .and. SubStr( cMarcAut , 5 , 1 ) == "E" ) , lInverte )

IF ( nLenDia > 0 )

	IF !( lInverte ) .and. Len( cMarcAut ) == 3.00 .and. !Empty( nPos ) .and. !( aTDia[ nPos , 3 ] $ cMarcAut )

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁVerifica se Devera Gerar a Marcacao Automatica para o Tipo deЁ
		ЁMarcacao em questao. Se o Tipo Nao Estiver Selecionado e a DiЁ
		Ёferenca de Horas Entre o Tipo Selecionado e um Tipo  ImediataЁ
		Ёmente Anterior ou Posterior Que Tenha Sido Selecionado    forЁ
		Ёigual, tambem Gera a Marcacao Automatica. Pois Neste caso naoЁ
		Ёda Para Identificar a Quem Pertence a Marcacao Efetuada.     Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( "E" $ aTDia[ nPos , 3 ] )
			cTipMarc := StrZero( Val( SubStr( aTDia[ nPos , 3 ] , 1 , 1 ) ) - 1 , 1 ) + SubStr( aTDia[ nPos , 3 ] , -1 )
		ElseIF ( "S" $ aTDia[ nPos , 3 ] )
			cTipMarc := StrZero( Val( SubStr( aTDia[ nPos , 3 ] , 1 , 1 ) ) + 1 , 1 ) + SubStr( aTDia[ nPos , 3 ] , -1 )
		EndIF
	
		IF ( SubStr( cTipMarc , 1 , 1 ) + SubStr( cMarcAut , 2 , 1 ) ) $ cMarcAut
	
			IF ( "E" $ aTDia[ nPos , 3 ] )
	
				IF !Empty( aTab_Marc[ Max( 1 , nY - 1 ) , 2 ] ) .and. !Empty( aTDia[ Max( 1 , nPos - 1 ) ] )
				
					dDtMar := aTab_Marc[ Max( 1 , nY - 1 ) , 2 , 1 ]
					nHrMar := aTab_Marc[ Max( 1 , nY - 1 ) , 2 , 2 ]
		
					dDtTab := aTDia[ nPos , 1 ]
					nHrTab := aTDia[ nPos , 2 ]
					nHora1 := DataHora2Val( dDtTab , nHrTab , dDtMar , nHrMar , "H" )
		
					dDtTab := aTDia[ Max( 1 , nPos - 1 ) , 1 ]
					nHrTab := aTDia[ Max( 1 , nPos - 1 ) , 2 ]
					nHora2 := DataHora2Val( dDtTab , nHrTab , dDtMar , nHrMar , "H" )
				
				EndIF
	
			ElseIF ( "S" $ aTDia[ nPos , 3 ] )
	
				IF !Empty( aTab_Marc[ Min( nLenTma , nY  + 1 ) , 2 ] ) .and. !Empty( aTDia[ Min( nLenDia , nPos + 1 ) ] )
	
					dDtMar := aTab_Marc[ Min( nLenTma , nY  + 1 ) , 2 , 1 ]
					nHrMar := aTab_Marc[ Min( nLenTma , nY  + 1 ) , 2 , 2 ]
		
					dDtTab := aTDia[ nPos , 1 ]
					nHrTab := aTDia[ nPos , 2 ]
					nHora1 := DataHora2Str( dDtTab , nHrTab , dDtMar , nHrMar )
		
					dDtTab := aTDia[ Min( nLenDia , nPos + 1 ) , 1 ]
					nHrTab := aTDia[ Min( nLenDia , nPos + 1 ) , 2 ]
					nHora2 := DataHora2Str( dDtTab , nHrTab , dDtMar , nHrMar )
	
				EndIF	
		
			EndIF
	
			lRet := ( nHora1 == nHora2 )
	
		EndIF
	
	ElseIF ( lInverte )

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Apenas Quando Existirem Marcacoes Efetivas 				  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( nLenMarcs := Len( aMDia ) ) > 0 
		
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Ajusta a Saida  ( Quando nao for a ultima )				  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			For nY := 1 To nLenTma
	
				IF ( Empty( aTab_Marc[ nY , 02 ] ) .or. ( nY == nLenTma )  )
					Loop
				EndIF
				
				IF ( nPos := aScan( aTDia , { |x|	x[1] == aTab_Marc[ nY , 01 , 01 ] .and. ;
					   								x[2] == aTab_Marc[ nY , 01 , 02 ]		;
										    };
								   );
					) > 0 .and. aTDia[nPos,3] $ cMarcAut .and. SubStr( aTDia[nPos,3] , -1 ) == "S"
					
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Se Marcacao de Encaixe for menor que marcacao da Tabela ZeraЁ
					Ё a Marcacao de Encaixe										  Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					IF Empty( aTab_Marc[ nY - 1 , 02 ] ) .and. ;
					   DataHora2Str(aTab_Marc[nY,02,01],aTab_Marc[nY,02,02]) < DataHora2Str(aTab_Marc[nY,01,01],aTab_Marc[nY,01,02])
						aTab_Marc[ nY - 1 , 02 ]	:= aClone( aTab_Marc[ nY , 02 ] )
						aTab_Marc[ nY , 02 ]		:= {}
						Exit
					Else
						Loop
					EndIF
	        	
	        	EndIF
			
			Next nY

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Ajusta a Saida  ( Quando for a Ultima e Numero de  MarcacoesЁ
			Ё da Tabela for igual a 2 )									  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
            IF ( ( nLenTma == 2 ) .and. ( nLenMarcs == nLenTma ) )
            	IF ( Empty( aTab_Marc[ nLenTma , 02 ] ) .and. !Empty( aTab_Marc[ nLenTma - 1 , 02 ] ) )
            		aTab_Marc[ nLenTma , 02 ]		:= aClone( aTab_Marc[ nLenTma - 1 , 02 ] )
            		aTab_Marc[ nLenTma , 02 , 01 ]	:= aMDia[ nLenMarcs , 01 ]
            		aTab_Marc[ nLenTma , 02 , 02 ]	:= aMDia[ nLenMarcs , 02 ]
            	EndIF
            EndIF
	
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Ajusta a Entrada ( Quando nao for a Primeira ) 			  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			For nY := 1 To nLenTma
	
				IF ( Empty( aTab_Marc[ nY , 02 ] ) .or. ( nY == 1 )  )
					Loop
				EndIF
				
				IF ( nPos := aScan( aTDia , { |x|	x[1] == aTab_Marc[ nY , 01 , 01 ] .and. ;
					   								x[2] == aTab_Marc[ nY , 01 , 02 ]		;
										    };
								   );
					) > 0 .and. aTDia[nPos,3] $ cMarcAut .and. SubStr( aTDia[nPos,3] , -1 ) == "E"
					
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Se Marcacao de Encaixe for maior que marcacao da Tabela ZeraЁ
					Ё a Marcacao de Encaixe										  Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					IF DataHora2Str(aTab_Marc[nY,02,01],aTab_Marc[nY,02,02]) > DataHora2Str(aTab_Marc[nY,01,01],aTab_Marc[nY,01,02])
						/*/
						зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Apenas Quando for formar Pares de Marcacoes ou Quando o Dia Ё
						Ё Nao For Trabalhado e Gerar Marcacoes para Dias Nao Trabalha Ё
						Ё dos ( lAutoSai ) ou Ainda Quando a Marcacao de Entrada  for Ё
						Ё a Ultima Marcacao do Dia.									  Ё
						юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			    		IF ( nMarc := aScan( aMDia , { |x| x[1] == aTab_Marc[nY,02,01] .and. x[2] == aTab_Marc[nY,02,02] } ) ) > 0
					        IF ( ( nMarcs := ( nLenMarcs - ( nMarc + 1 ) ) % 2 ) > 0 .or. ( nMarc == nLenMarcs ) )
								IF ( nMarc == nLenMarcs )
									IF ( nY + 1 ) <= Len( aTab_Marc )
										aTab_Marc[ nY + 1 , 02 ]	:= aClone( aTab_Marc[ nY , 02 ] )
										aTab_Marc[ nY , 02 ]		:= {}
									EndIF
								Else
									aTab_Marc[ nY , 02 ] := {}
								EndIF
							ElseIF ( lAutoSai .and. ( aTDia[ nPos , 04 ] != "S" ) )
								IF ( nY + 1 ) <= Len( aTab_Marc )
									aTab_Marc[ nY + 1 , 02 ]	:= aClone( aTab_Marc[ nY , 02 ] )
									aTab_Marc[ nY , 02 ]		:= {}
								EndIF
							EndIF	
						EndIF	
						Exit
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					ЁNeste Caso a Marcacao foi Encaixada como Entrada de IntervaloЁ
					ЁSimula a Saida no Expediente para Poder Gerar a Saida do   InЁ
					Ёtervalo													  Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					ElseIF ( nY + 1 ) <= Len( aTab_Marc ) .and. Empty( aTab_Marc[ nY + 1 , 02 ] )
						aTab_Marc[ nY + 1 , 02 ] := aClone( aTab_Marc[ nY , 02 ] )
						Exit
					Else
						Loop
					EndIF
	        	
	        	EndIF
			
			Next nY
		
		EndIF
	
	EndIF
	
EndIF

Return( lRet )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁPonDestroyStaticЁAutorЁMarinaldo de Jesus Ё Data Ё26/11/2001Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁReinicializar as Variaveis Staticas do SIGAPON    			Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁPonDestroyStatic( <aDestroy> )								Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁSIGAPON                                                     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ aDestroy -> Pilha com as Funcoes que terao Statics ReiniciaЁ
Ё          Ё 			 lizadas       									Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PonDestroyStatic( aDestroy )

Begin Sequence

	DEFAULT aDestroy := {}
	IF ( Empty( aDestroy ) .or. ( ValType( aDestroy ) != "A" ) )
		aDestroy := Array( 21 )
		aDestroy[01] := "RstAponta()"
		aDestroy[02] := "RstfFeriado()"
		aDestroy[03] := "RstGetTabExtra()"
		aDestroy[04] := "RstGetTabArred()"
		aDestroy[05] := "SuperGetMv()"
		aDestroy[06] := "RstToScheduleOverTime()"
		aDestroy[07] := "RstTimeRemaining()"
		aDestroy[08] := "RstPosAlias()"
		aDestroy[09] := "ResetSqlName()"
		aDestroy[10] := "RstCalendCria()"
		aDestroy[11] := "RstCriaCalend()"
		aDestroy[12] := "RstTabPadrao()"
		aDestroy[13] := "RstEnchoVlds()"
		aDestroy[14] := "RstfEventos()"
		aDestroy[15] := "RstCheckSx9()"
		aDestroy[16] := "RstfCargaId()"
		aDestroy[17] := "RstMarcAuto()"
		aDestroy[18] := "RstExistField()"
		aDestroy[19] := "RstFilExistField()"
		aDestroy[20] := "RstGetCache()"
		aDestroy[21] := "RstGetAdsLckRec()"
		aEval( aDestroy , { |x| IF( !Empty(x) .and. FindFunction(x) , &(x) , NIL ) } )
	ElseIF ( ValType( aDestroy ) == "A" )
		aEval( aDestroy , { |x| IF( !Empty(x) .and. FindFunction(x) , IF( SubStr( ( x := StrTran( x ," ","") ) , -2 )!="()",&(x+"()"),&(x)) , NIL ) } )
	EndIF

	//Inicio do bloco a ser excluido para a fase 3
	IF FindFunction( "SPJSxbAcerta" )
		SPJSxbAcerta()
	EndIF
	
	//Ajusta descricao dos afastamentos.
	SR8Sx5Acerta()
		
	lRF0ChkTable := NIL //Verifica a Existencia do Arquivo de Pre-Abonos ( Nao devera constar em versoes Futuras )
	//Final do Bloco a ser excluido na para a fase 3

    //-- Descarta Variavel para uso em Query
	__cLimpaMotAbo := NIL
End Sequence
	
Return( NIL )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGetPonMesDat    ЁAutorЁMarinaldo de Jesus Ё Data Ё10/12/2001Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRetorna a Data Inicial e Final do Parametro MV_PONMES		Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGetPonMes( @dPerIni , @dPerFim , cFil )						Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁSIGAPON                                                     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁdPerIni  -> Data Inicial do Periodo de Apontamento em AbertoЁ
Ё          ЁdPerFim  -> Data Final   do Periodo de Apontamento em AbertoЁ
Ё          ЁcFil     -> Filial para GetMv()								Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetPonMesDat( dPerIni , dPerFim , cFil )
         
Local cPonMes		:= ""
Local cPerAponta	:= ""
Local cSvFilAnt		:= cFilAnt
Local lRet			:= .T.

DEFAULT dPerIni		:= Ctod("//")
DEFAULT dPerFim		:= Ctod("//")
DEFAULT cFil		:= cSvFilAnt

cFilAnt := IF( !Empty( cFil ) , cFil , cFilAnt )

Begin Sequence

	IF !( lRet := CheckModSPO() )
		Break
	EndIF
	
	IF Empty( cPonMes := GetPonMes( cFil ) )
		cPerAponta := GetPaponta( cFil )
		IF ( PerCompleto( cPerAponta ) )
	    	cPonMes := cPerAponta
    		PutMvFil( "MV_PONMES" , cPonMes , cFilAnt )
	    EndIF
	EndIF

	IF !( lRet := !Empty( dPerIni := Stod( Left( cPonMes , 08 ) ) ) )
		Break
	EndIF
	
	IF !( lRet := !Empty( dPerFim := Stod( Right( cPonMes , 08 ) ) ) )
		Break
    EndIF

	IF !( lRet := MaxP8PGOrdVld( dPerIni , dPerFim ) )
		Break
	EndIF

End Sequence

cFilAnt := cSvFilAnt

Return( lRet )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁValidPonData    ЁAutorЁMarinaldo de Jesus Ё Data Ё10/12/2001Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁValida as Datas Digitadas nos Lancamentos do SIGAPON		Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁSIGAPON                                                     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais 									Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function ValidPonData(	dData		,;	//01 -> Data a Ser Validada
						cTipValid	,;	//02 -> Tipo da Validacao "G" - GetDados (Periodo) ; "P" - Validar o MV_PONMES
						dPerIni		,;	//03 -> Periodo Inicial
						dPerFim		,;	//04 -> Periodo Final
						lAcumulado	,;	//05 -> Se Informacao de Arquivo Acumulado
						lShowHelp	,;  //06 -> Mostrar ou Nao o Help
						cFil		 ;	//07 -> Filial para PerAponta
					  )

Local cHelp	:= ""
Local lRet	:= .T.

DEFAULT dData		:= Ctod("//")
DEFAULT cTipValid	:= "G"
DEFAULT dPerIni 	:= Ctod("//")
DEFAULT dPerFim		:= Ctod("//")
DEFAULT lAcumulado	:= .F.
DEFAULT lShowHelp	:= .T.
DEFAULT cFil		:= cFilAnt

cTipValid := Upper( AllTrim( cTipValid ) )

Begin Sequence

	IF ( Empty( dPerIni ) .or. Empty( dPerFim ) )
		IF !( lRet := PerAponta( @dPerIni , @dPerFim , NIL , lShowHelp , cFil ) )
			Break
		EndIF
	EndIF

	IF ( cTipValid == "G" )
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Nao Podem Haver Lancamentos Fora do Periodo em Aberto		   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( ( dData < dPerIni ) .or. ( dData > dPerFim ) )
			lRet := .F.
			cHelp += ( OemToAnsi( STR0108 ) + Space(50) + Chr(13) )								//'A Data Informada e Invalida.'
			cHelp += OemToAnsi( STR0106 )														//'Per║odo em Aberto: '
			cHelp += ( Dtoc( dPerIni ) + STR0104 +  Dtoc( dPerFim )  ) + Space(50) + Chr(13)	//' a '
			cHelp += Space(50) + Chr(13)
			cHelp += Space(50) + Chr(13)
		EndIF
		Break
	EndIF

	IF ( cTipValid == "P" )
		IF ( lAcumulado )
			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Nao Podem Haver Lancamentos para Periodos Posteriores ao PeriЁ
			Ё odo de Apontamento em Aberto.						   		   Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			lRet := !( dData >= dPerIni )
			cHelp += ( OemToAnsi( STR0105 ) + Space(50) + Chr(13) )								//'N└o Podem Haver Lan┤amentos Acumulados'
			cHelp += ( OemToAnsi( STR0107 ) + Space(50) + Chr(13) )								//'Para Este Per║odo: '
			cHelp += OemToAnsi( STR0106 )														//'Per║odo em Aberto: '
			cHelp += ( Dtoc( dPerIni ) + STR0104 +  Dtoc( dPerFim )  ) + Space(50) + Chr(13)	//' a '
			cHelp += Space(50) + Chr(13)
			cHelp += Space(50) + Chr(13)
		Else
			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Nao Podem Haver Lancamentos para Periodo Anteriores ao  PerioЁ
			Ё do de Apontamento em Aberto.							   	   Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			lRet := !( dData < dPerIni )
			cHelp += ( OemToAnsi( STR0102 ) + Space(50) + Chr(13) )								//'N└o Podem Haver Lan┤amentos para Per║odo'
			cHelp += ( OemToAnsi( STR0103 ) + Space(50) + Chr(13) )								//'Posterior ao Periodo em Aberto: '
			cHelp += OemToAnsi( STR0106 )														//'Per║odo em Aberto: '
			cHelp += ( Dtoc( dPerIni ) + STR0104 +  Dtoc( dPerFim )  ) + Space(50) + Chr(13)	//' a '
		EndIF	
		Break
	EndIF
	
End Sequence
	
IF ( !( lRet ) .and. ( lShowHelp ) )
	IF !Empty( cHelp )
		Help( " " , 1 , "NOVALIDPER" , , cHelp , 1 , 0 )
	EndIF	
EndIF

Return( lRet )

/*/
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁDescPdPon Ё Autor Ё Equipe Advanced RH    Ё Data Ё23/02/1995Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Retorna a Descricao do Codigo de Provento / Desconto       Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё Generico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ/*/
Function DescPdPon( cEvento , cFil , nBytes )

Local cRet		:= ""
Local nSvOrder	:= SP9->( IndexOrd() )
Local nOrder	:= RetOrdem( "SP9" , "P9_FILIAL+P9_CODIGO" )

DEFAULT nBytes := 20

IF ( nBytes > 20 )
	nBytes := 20
EndIF

cFil := xFilial( "SP9" , cFil )

IF !( nOrder == nSvOrder )
	SP9->( dbSetOrder( nOrder ) )
EndIF
	
IF SP9->( MsSeek( cFil + cEvento ) )
	cRet := Left( SP9->P9_DESC + Space( nBytes ) , nBytes )
Else
	cRet := Left( STR0001 + Space( nBytes ) , nBytes ) // '** Nao Cadastrado **'
EndIF

SP9->( dbSetOrder( nSvOrder ) )

Return( cRet )

/*/
зддддддддддбддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁShowTipoDia Ё Autor ЁMarinaldo de Jesus    Ё Data Ё19/07/2002Ё
цддддддддддеддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁValidar a multipla escolha de tipo de Dia              		 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁShowTipoDia( cTipo , l1Elem )								 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ                                                     		 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   Ё.T.                                                  	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁApontamento                                                  Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function ShowTipoDia( cTipoDia , l1Elem , lDisplay )

Local aTpDia		:= {}
Local aOpc			:= {}
Local cTitulo		:= ""
Local cMvParDef		:= ""
Local cMvPar		:= ""
Local nTpDia		:= 0
Local nTpDias		:= 0
Local nPosTpDia		:= 0
Local uRet			:= NIL

DEFAULT cTipoDia	:= "CDFNS"
DEFAULT l1Elem		:= .F.
DEFAULT lDisplay	:= .T.

aAdd( aTpDia , { "C" , STR0109	} )	//"Compensado"
aAdd( aTpDia , { "D" , STR0110	} )	//"DSR"
aAdd( aTpDia , { "F" , STR0111	} )	//"Feriado"
aAdd( aTpDia , { "N" , STR0112	} )	//"Nao Trabalhado"
aAdd( aTpDia , { "S" , STR0113 	} )	//"Trabalhado"

IF ( lDisplay )  

	CursorWait()

	    cMvPar				:= &( Alltrim( ReadVar() ) )
		cTipoDia			:= Upper( AllTrim( cTipoDia ) )
		l1Elem				:= IF( ValType( l1Elem ) != "L" , .F. , l1Elem )
		MvRet				:= Alltrim( ReadVar() )

		nTpDias := Len( cTipoDia )
		For nTpDia := 1 To nTpDias
			IF ( nPosTpDia := aScan( aTpDia , { |x| x[1] == SubStr( cTipoDia , nTpDia , 1 ) } ) ) > 0
				cMvParDef += aTpDia[ nPosTpDia , 01 ]
				aAdd( aOpc , aTpDia[ nPosTpDia , 01 ] += ( "-" + aTpDia[ nPosTpDia , 02 ] ) )
			EndIF
		Next nX

	CursorArrow()

	IF ( uRet := ( cMvPar != NIL ) )
		IF f_Opcoes(@cMvPar,cTitulo,aOpc,cMvParDef,12,49,l1Elem,1)
			&(MvRet) := cMvPar
		EndIF	
	EndIF

Else

	IF ( nPosTpDia := aScan( aTpDia , { |x| x[1] == cTipoDia } ) ) > 0
		uRet := aTpDia[ nPosTpDia , 02 ]
	EndIF

EndIF
	
Return( uRet )

/*/
зддддддддддбддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁValidPerSPO Ё Autor ЁMarinaldo de Jesus    Ё Data Ё29/07/2002Ё
цддддддддддеддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁValidar as Datas no Cadastro de Periodos de Apontamento		 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais >									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais >									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlRet                                                 	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                     Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function ValidPerSPO(	cFil		,;	//Filial de Referencia Para Pesquisa no SPO
						dPerIni 	,;	//Periodo Inicial para Valiadacao
						dPerFim		,;	//Periodo Final Para Validacao
						lNotInclui	,;	//Quando Inclui nao Estiver Definido, qual sera o seu valor
						lShowHelp	,;	//Se deve Mostrar Help
						aPeriodos	,;	//Periodos que foram carregados
						lValidPer	 ;	//Se deve validar os Periodos
					)

Local aAreaSPO		:= SPO->( GetArea() )
Local cAlias		:= "SPO"
Local lRet			:= .T.
Local nPosDataIni	:= ( cAlias )->( FieldPos( "PO_DATAINI" ) )
Local nPosDataFim	:= ( cAlias )->( FieldPos( "PO_DATAFIM" ) )

Local dPoDataIni
Local dPoDataFim
Local dFirstDate
Local dLastDate
Local nRecno

DEFAULT dPerIni		:= IF( IsMemVar("PO_DATAINI") , GetMemVar( "PO_DATAINI" ) , Ctod("//") )
DEFAULT dPerFim		:= IF( IsMemVar("PO_DATAFIM") , GetMemVar( "PO_DATAFIM" ) , Ctod("//") )
DEFAULT lNotInclui	:= .F.
DEFAULT lShowHelp	:= .T.
DEFAULT lValidPer	:= .T.

aPeriodos := {}

Begin Sequence

	IF !( lRet := MaxP8PGOrdVld( dPerIni , dPerFim , lShowHelp ) )
		Break
	EndIF

	IF !( lRet := ( nPosDataIni > 0 ) )
		Break
	EndIF

	IF !( lRet := ( nPosDataFim > 0 ) )
		Break
	EndIF

	Inclui	:= IF( ( Type( "Inclui" ) == "U" ) , lNotInclui , Inclui )
	cFil	:= xFilial( cAlias , cFil )

	SPO->( dbSetOrder( RetOrdem( "SPO" , "PO_FILIAL+DTOS(PO_DATAINI)" ) ) )
	IF ( cAlias )->( dbSeek( cFil , .F. ) )
		While ( cAlias )->( !Eof() .and. PO_FILIAL == cFil )
			IF IF( Inclui , Inclui , !( nRecno := ( cAlias )->( Recno() ) == aAreaSPO[ 3 ] ) )
				dPoDataIni	:= ( cAlias )->( FieldGet( nPosDataIni ) )
				IF Empty( dFirstDate )
					dFirstDate	:= dPoDataIni
				EndIF
				dPoDataFim	:= ( cAlias )->( FieldGet( nPosDataFim ) )
				dLastDate	:= dPoDataFim
				IF ( lValidPer )
					IF ConflictDate( dPerIni , dPerFim , dPoDataIni , dPoDataFim )
						lRet := .F.
						Break
					EndIF
				EndIF
				aAdd( aPeriodos , { dPoDataIni , dPoDataFim , nRecno } )
			EndIF
			( cAlias )->( dbSkip() )
		End While
	EndIF

	IF ( lValidPer )

		IF ( !Empty( dFirstDate ) .and. !Empty( dLastDate ) )
			IF ConflictDate( dPerIni , dPerFim , dFirstDate , dLastDate )
				lRet := .F.
				Break
			EndIF
		EndIF	

	EndIF

End Sequence

IF ( ( lShowHelp ) .and. !( lRet ) )
	Help(" ",1,"PONA290PER")
EndIF

Return( lRet )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁPutPerSPO	  ЁAutorЁ Marinaldo de Jesus  Ё Data Ё09/08/2002Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁGravar Periodo de Apontamento na Tabela de Periodos de  AponЁ
Ё          ЁTamento														Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais> 									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>                                   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   Ё Generico 												    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PutPerSPO( cFil , dPerIni , dPerFim , cFlag , cRespon )

Local aArea		:= GetArea()
Local cAlias	:= "SPO"
Local lRet		:= .F.

DEFAULT cFil	:= ""
DEFAULT dPerIni	:= Ctod("//")
DEFAULT dPerFim	:= Ctod("//")
DEFAULT cFlag	:= "0"
DEFAULT cRespon	:= "S"

IF !( cFlag $ "01" )
	cFlag := "0"
EndIF

IF !( cRespon $ "US" )
	cRespon := "U"
EndIF

IF ( lRet := ValidPerSPO( @cFil , dPerIni , dPerFim , .T. , .F. ) )
	IF ( lRet := ( cAlias )->( RecLock( cAlias , .T. , .F. ) ) )
		( cAlias )->( FieldPut( FieldPos( "PO_FILIAL"  ) , cFil		) )
		( cAlias )->( FieldPut( FieldPos( "PO_DATAINI" ) , dPerIni	) )
		( cAlias )->( FieldPut( FieldPos( "PO_DATAFIM" ) , dPerFim	) )
		( cAlias )->( FieldPut( FieldPos( "PO_FLAGFEC" ) , cFlag   	) )
		( cAlias )->( FieldPut( FieldPos( "PO_RESPONS" ) , cRespon 	) )
		( cAlias )->( MsUnLock() )
	EndIF
EndIF

RestArea( aArea )

Return( lRet )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁRetPerSPO	  ЁAutorЁ Marinaldo de Jesus  Ё Data Ё29/08/2002Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetornar Periodos de Apontamento do SPO                     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais> 									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>                                   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   Ё Generico 												    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RetPerSPO( cFil )

Local aArea		:= GetArea()
Local aAreaSPO	:= SPO->( GetArea() )
Local aPerSPO	:= {}

cFil := xFilial( "SPO" , cFil )

SPO->( dbSeek( xFilial( "SPO" , cFil ) ) )

While SPO->( !Eof() .and. cFil == PO_FILIAL )
	SPO->( aAdd( aPerSPO , { PO_DATAINI , PO_DATAFIM } ) , dbSkip() )
End While

( RestArea( aAreaSPO ) , RestArea( aArea ) )

Return( aPerSPO )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁCheckModSPO   ЁAutorЁ Marinaldo de Jesus  Ё Data Ё09/08/2002Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica o Modo de Acesso do SPO e,se nao for compartilhado,Ё
Ё          ЁDuplica os Parametros MV_PONMES e MV_PAPONTA				Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais> 									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>                                   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   Ё Generico 												    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function CheckModSPO()

Local aArea		:= GetArea()
Local aAreaSMO	:= SM0->( GetArea() )
Local lRet		:= .T.

Begin Sequence

	IF ( lRet := Empty( xFilial( "SPO" ) ) )
		Break
	EndIF
	
	IF ( lRet := SM0->( dbSeek( cEmpAnt , .F. ) ) )
		While SM0->( !Eof() .and. M0_CODIGO == cEmpAnt )
			IF ( lRet := DuplicaMv(FWGETCODFILIAL, "MV_PONMES" ) )
				IF !( lRet := DuplicaMv(FWGETCODFILIAL, "MV_PAPONTA" ) )
					Break
				EndIF
			Else
				Break
			EndIF
			SM0->( dbSkip() )
		End While
	EndIF

End Sequence

IF !( lRet )
	Help( "" , 1 , "NOEXISTMVS" )
EndIF

( RestArea(  aAreaSMO ) , RestArea(  aArea ) )

Return( lRet )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁPerApoConPad  ЁAutorЁ Marinaldo de Jesus  Ё Data Ё12/08/2002Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁMonta Consulta Padrao para o Periodo de Apontamento  baseadaЁ
Ё          Ёno SPO                                      				Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais> 									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<void>                                                      Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerico 												    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PerApoConPad()
Return( ConPad1( NIL , NIL , NIL , "SPO" , NIL , NIL , .F. ) ) 

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁPutPerMvPar	  ЁAutorЁ Marinaldo de Jesus  Ё Data Ё26/08/2002Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁCarregar o Periodo de Apontamento nas Variaveis dos   ParameЁ
Ё          Ёtros                                        				Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais> 									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais> 									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerico 												    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PutPerMvPar( cParGroup , cParDt1 , cParDt2 )

Local aArea			:= GetArea()
Local aAreaSX1		:= SX1->( GetArea() )
Local lRet			:= .T.
Local lConPad		:= .T.

DEFAULT cParGroup	:= ""
DEFAULT cParDt1		:= ""
DEFAULT cParDt2 	:= ""

dbSelectArea("SX1")
SX1->( dbSetOrder(1) )
IF ( lConPad := PerApoConPad() )
nTam:=Len(SX1->X1_GRUPO)
	IF SX1->(  dbSeek( PADR(cPerg,nTam) + cParDt1 , .F. ) )
		IF ( Type( SX1->X1_VAR01 ) == "D" )
        	&( SX1->X1_VAR01 ) := SPO->PO_DATAINI
		EndIF
	EndIF
 
		nTam:=Len(SX1->X1_GRUPO)
	IF SX1->(  dbSeek( PADR(cPerg,nTam) + cParDt2 , .F. ) )
		IF ( Type( SX1->X1_VAR01 ) == "D" )
        	&( SX1->X1_VAR01 ) := SPO->PO_DATAFIM
		EndIF
	EndIF
EndIF	 

( RestArea( aAreaSX1 ) , RestArea( aArea ) )

Return( lRet )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁPonRetOpcBox  ЁAutorЁ Marinaldo de Jesus  Ё Data Ё10/09/2002Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetornar as Opcoes para o X3_BOX                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё#PonRetOpcBox( nOpcBox )									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais> 									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁSX3->X3_BOX   												Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PonRetOpcBox( nOpcBox )

Local cOpcBox	:= ""

DEFAULT nOpcBox	:= 0

IF ( nOpcBox == 01 )
	cOpcBox += ( "S=" + STR0113 + ";"	)	//"Trabalhado"
	cOpcBox += ( "C=" + STR0109	+ ";"	)	//"Compensado"
	cOpcBox	+= ( "D=" + STR0110 + ";"	)	//"D.S.R"
	cOpcBox += ( "N=" + STR0112	     	)	//"Nao Trabalhado"
ElseIF ( nOpcBox == 02 )
	cOpcBox += ( "S=" + STR0113 + ";"	)	//"Trabalhado"
	cOpcBox += ( "C=" + STR0109	+ ";"	)	//"Compensado"
	cOpcBox	+= ( "D=" + STR0110 + ";"	)	//"D.S.R"
	cOpcBox += ( "N=" + STR0112	+ ";"	)	//"Nao Trabalhado"
	cOpcBox += ( "F=" + STR0111	   		)	//"Feriado"	
ElseIF ( nOpcBox == 03 )
	cOpcBox += ( "1=" + STR0120 + ";"	)	//"Normal"
	cOpcBox += ( "2=" + STR0110	+ ";"	)	//"D.S.R"
	cOpcBox	+= ( "3=" + STR0109 + ";"	)	//"Compensada"
	cOpcBox += ( "4=" + STR0111	+ ";"	)	//"Feriado"
	cOpcBox += ( "5=" + STR0121	+ ";"	)	//"Noturna Normal"
	cOpcBox += ( "6=" + STR0122	+ ";"	)	//"Noturna D.S.R"
	cOpcBox += ( "7=" + STR0123	+ ";"	)	//"Noturna Compensada"
	cOpcBox += ( "8=" + STR0124	     	)	//"Noturna Feriado"
ElseIF ( nOpcBox == 04 )
	cOpcBox += ( "1=" + STR0120 + ";"	)	//"Normal"
	cOpcBox += ( "2=" + STR0110	+ ";"	)	//"D.S.R"
	cOpcBox	+= ( "3=" + STR0109 + ";"	)	//"Compensada"
	cOpcBox += ( "4=" + STR0111	+ ";"	)	//"Feriado"
	cOpcBox += ( "5=" + STR0121	+ ";"	)	//"Noturna Normal"
	cOpcBox += ( "6=" + STR0122	+ ";"	)	//"Noturna D.S.R"
	cOpcBox += ( "7=" + STR0123	+ ";"	)	//"Noturna Compensada"
	cOpcBox += ( "8=" + STR0124	+ ";"  	)	//"Noturna Feriado"
	cOpcBox += ( "A=" + STR0078	+ ";"	)	//"Intervalo Normal"
	cOpcBox += ( "B=" + STR0079	+ ";"   )	//"Intervalo Noturna"
	cOpcBox += ( "C=" + STR0195	+ ";"   )	//"Intervalo DSR"
	cOpcBox += ( "D=" + STR0196	+ ";"   )	//"Intervalo Noturna DSR"
	cOpcBox += ( "E=" + STR0197	+ ";"   )	//"Intervalo Compensado"
	cOpcBox += ( "F=" + STR0198	+ ";"   )	//"Intervalo Noturna Compensado"
	cOpcBox += ( "G=" + STR0199	+ ";"   )	//"Intervalo Feriado"
	cOpcBox += ( "H=" + STR0200         )	//"Intervalo Noturna Feriado"
ElseIF ( nOpcBox == 05 )
	cOpcBox += ( "S=" + STR0125 + ";"	)	//'Sim'
	cOpcBox += ( "N=" + STR0126      	)	//'Nao'
ElseIF ( nOpcBox == 06 )
	cOpcBox += ( "1E=" + STR0080 + ";"	)	//'1a. Entrada'
	cOpcBox += ( "1S=" + STR0081 + ";"	)	//'1a. Saida  '
	cOpcBox += ( "2E=" + STR0082 + ";"	)	//'2a. Entrada'
	cOpcBox += ( "2S=" + STR0083 + ";"	)	//'2a. Saida  '
	cOpcBox += ( "3E=" + STR0084 + ";"	)	//'3a. Entrada'
	cOpcBox += ( "3S=" + STR0085 + ";"	)	//'3a. Saida  '
	cOpcBox += ( "4E=" + STR0086 + ";"	)	//'4a. Entrada'
	cOpcBox += ( "4S=" + STR0087      	)	//'4a. Saida  '
ElseIF ( nOpcBox == 07 )
	 cOpcBox += ( "1I=" + STR0088 + ";"	)	//'1o. Intervalo '
	 cOpcBox += ( "2I=" + STR0089 + ";"	)	//'2o. Intervalo '
	 cOpcBox += ( "3I=" + STR0090       )	//'3o. Intervalo '
ElseIF ( nOpcBox == 08 )
	 cOpcBox += ( "S=" + STR0125 + ";"	)	//'Sim'
	 cOpcBox += ( "N=" + STR0126 + ";" 	)	//'Nao'
	 cOpcBox += ( "D=" + STR0110 + ";"	)	//"D.S.R"
	 cOpcBox += ( "C=" + STR0109      	)	//"Compensado"
ElseIF ( nOpcBox == 09 )
	 cOpcBox += ( "T=" + STR0127 + ";"	)	//"Total"
	 cOpcBox += ( "P=" + STR0128      	)	//"Parcial"
ElseIF ( nOpcBox == 10 )
	 cOpcBox += ( "1=" + STR0129 + ";"	)	//"Provento"
	 cOpcBox += ( "2=" + STR0130 + ";"	)	//"Desconto"
	 cOpcBox += ( "3=" + STR0131      	)	//"Base"
ElseIF ( nOpcBox == 11 )
	 cOpcBox += ( "S=" + STR0132 + ";"	)	//"Semanal"
	 cOpcBox += ( "Q=" + STR0133 + ";"	)	//"Quinzenal"
	 cOpcBox += ( "M=" + STR0134      	)	//"Mensal"
ElseIF ( nOpcBox == 12 )
	 cOpcBox += ( "D=" + STR0135 + ";"	)	//"Diario"	 
	 cOpcBox += ( "S=" + STR0132 + ";"	)	//"Semanal"
	 cOpcBox += ( "Q=" + STR0133 + ";"	)	//"Quinzenal"
	 cOpcBox += ( "M=" + STR0134      	)	//"Mensal"
ElseIF ( nOpcBox == 13 )
	 cOpcBox += ( "A=" + STR0136 + ";"	)	//"Anterior"	 
	 cOpcBox += ( "P=" + STR0137 + ";"	)	//"Posteior"
	 cOpcBox += ( "T=" + STR0138		)	//"Todos"
ElseIF ( nOpcBox == 14 )
	 cOpcBox += ( "H=" + STR0139 + ";"	)	//"Horas"	 
	 cOpcBox += ( "V=" + STR0140 + ";"	)	//"Valor"
	 cOpcBox += ( "D=" + STR0141		)	//"Dias"
ElseIF ( nOpcBox == 15 )
	 cOpcBox += ( "A=" + STR0142 + ";"	)	//"Atrasos"	 
	 cOpcBox += ( "S=" + STR0143 + ";"	)	//"Saidas Antecipadas"
	 cOpcBox += ( "H=" + STR0144 + ";"	)	//"Horas Extras"
	 cOpcBox += ( "D=" + STR0145 + ";"	)	//"Descanso Semanal Remunerado"
	 cOpcBox += ( "F=" + STR0146 + ";"	)	//"Faltas"
	 cOpcBox += ( "N=" + STR0147 + ";"	)	//"Adicional Noturno"
	 cOpcBox += ( "9=" + STR0148      	)	//"Nona Hora"
ElseIF ( nOpcBox == 16 )
	 cOpcBox += ( "0=" + STR0149 + ";"	)	//"Fechado"
	 cOpcBox += ( "1=" + STR0150      	)	//"Aberto"
ElseIF ( nOpcBox == 17 )
	 cOpcBox += ( "S=" + STR0151 + ";"	)	//"Sistema"
	 cOpcBox += ( "U=" + STR0152     	)	//"Usuario"
ElseIF ( nOpcBox == 18 )
	 cOpcBox += ( "1=" + STR0129 + ";"	)	//"Provento"
	 cOpcBox += ( "2=" + STR0130 + ";"	)	//"Desconto"
	 cOpcBox += ( "3=" + STR0216 + ";"	)	//"Base ( Provento )"
	 cOpcBox += ( "4=" + STR0217        )	//"Base ( Desconto )"
EndIF

Return( cOpcBox )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁMaxP8PGOrdVld	ЁAutorЁMarinaldo de Jesus Ё Data Ё24/01/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁValidar o Numero de Ordens possiveis para o SP8 e SPG conforЁ
Ё          Ёme Periodo de Apontamento									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function MaxP8PGOrdVld( dPerIni , dPerFim , lShowHelp , nOrdens )
         
Local cMsg			:= ""
Local lOrdensOk		:= .F.
Local nDias			:= 0

DEFAULT dPerIni		:= Ctod("//")
DEFAULT dPerFim		:= Ctod("//")
DEFAULT lShowHelp	:= .T.

nDias 	:= ( ( dPerFim - dPerIni ) + 1 )
nOrdens	:= Val( Replicate( "9" , __nTamP8Ordem ) )
Begin Sequence
	IF !( lOrdensOk := ( nDias <= nOrdens ) )
		cMsg := STR0160 //"O numero de dias do periodo ultrapassou o numero de ordens permitidas para o SP8"
		Break
	EndIF
	nOrdens	:= Val( Replicate( "9" , __nTamPGOrdem ) )
	IF !( lOrdensOk := ( nDias <= nOrdens ) )
		cMsg := STR0161 //"O numero de dias do periodo ultrapassou o numero de ordens permitidas para o SPG"
		Break
	EndIF
End Sequence	

IF ( lShowHelp )
	IF ( !( lOrdensOk ) .and. !Empty( cMsg ) )
		cMsg += CRLF
		cMsg += STR0162 + AllTrim( Str( nDias ) )	//'Numero de dias do Periodo:'
	 	cMsg += CRLF
	 	cMsg += STR0163 + AllTrim( Str( nOrdens ) )	//'Numero Maximo de Ordens:
		MsgInfo( OemToAnsi( cMsg ) , OemToAnsi( STR0159 ) ) //"Aten┤└o!"
	EndIF
EndIF

Return( lOrdensOk  )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁPonIncDate		ЁAutorЁMarinaldo de Jesus Ё Data Ё28/01/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁIncrementa Periodo de Acordo com os dias do Periodo AnteriorЁ
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PonIncDate( dPerIni , dPerFim  )

Local dDateAux
Local nDias

DEFAULT dPerIni	:= Ctod("//")
DEFAULT dPerFim	:= Ctod("//")

IF ( dPerFim < dPerIni )
	dDateAux	:= dPerIni
	dPerIni		:= dPerFim
	dPerFim		:= dDateAux
EndIF

nDias		:= ( dPerFim - dPerIni )
dPerIni 	:= ( dPerFim + 1  )
dPerFim 	:= ( dPerIni + nDias )

Return( nDias )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁPonDecDate		ЁAutorЁMarinaldo de Jesus Ё Data Ё22/01/2004Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁDecrementa Periodo de Acordo com os dias do Periodo AnteriorЁ
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PonDecDate( dPerIni , dPerFim  )

Local dDateAux
Local nDias

DEFAULT dPerIni	:= Ctod("//")
DEFAULT dPerFim	:= Ctod("//")

IF ( dPerFim < dPerIni )
	dDateAux	:= dPerIni
	dPerIni		:= dPerFim
	dPerFim		:= dDateAux
EndIF

nDias		:= ( dPerFim - dPerIni )
dPerFim 	:= ( dPerIni - 1 )
dPerIni 	:= ( dPerFim - nDias )

Return( nDias )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁPonDelRecnos	ЁAutorЁMarinaldo de Jesus Ё Data Ё12/03/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁDeletar Registros conforme Alias e Array aRecnos            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PonDelRecnos(	cAlias			,;	//01 -> Alias
						aRecnos 		,;	//02 -> Array com os Recnos
						bCondDele		,;	//03 -> Bloco com a Condicao para Delecao
						uParbCondDele	,;	//04 -> Parametro para o Bloco 
						aMsMmCpos		,;	//05 -> Array com os campos Memo para Delecao
						cAliasMsMm		 ;	//06 -> Alias para a MsMm
					)
Return(DelRecnos(@cAlias,@aRecnos,@bCondDele,@uParbCondDele,@aMsMmCpos,@cAliasMsMm))

/*/
зддддддддддбддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁPonModPer	Ё Autor ЁMarinaldo de Jesus    Ё Data Ё06/09/2002Ё
цддддддддддеддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁPossibilitar a Alteracao do parametro MV_PERAPONTA e a  conseЁ
Ё          Ёsequente atualizacao do MV_PONMES							 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL															 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico													 Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PonModPer( lModPer , cFil )

DEFAULT lModPer := .T.

IF ( lModPer )
	lModPer := PonActModPer( cFil )
EndIF

Return( MbrChgLoop( .F. ) )

/*/
зддддддддддбддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁPonActModPerЁ Autor ЁMarinaldo de Jesus    Ё Data Ё06/09/2002Ё
цддддддддддеддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁPossibilitar a Alteracao do parametro MV_PERAPONTA e a  conseЁ
Ё          Ёsequente atualizacao do MV_PONMES							 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL															 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁSIGAPON     												 Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function PonActModPer( cFil )

Local aSvKeys		:= GetKeys()
Local aAdvSize		:= MsAdvSize( .F. , .T. , 50 )
Local bSet15		:= { || NIL }
Local bSet24		:= { || NIL }
Local cAntDiaIniFim	:= Space( 05 )
Local cAtuDiaIniFim	:= Space( 05 )
Local cNewPerPutMv	:= ""
Local cSvFilAnt		:= cFilAnt
Local cMsgPaponta	:= ""
Local dAntIniPer	:= Ctod("//")
Local dAntFimPer	:= Ctod("//")
Local dAtuIniPer	:= Ctod("//")
Local dAtuFimPer	:= Ctod("//")
Local dIniPonMes	:= Ctod("//")
Local dFimPonMes	:= Ctod("//")
Local lModPerOk		:= .F.
Local lModPonMes	:= .F.
Local lPapontaPer	:= .F.
Local lVisualizar	:= .F.
Local nOpcModPer	:= 0
Local oDlg 			:= NIL
Local oFont			:= NIL
Local oGroup1		:= NIL
Local oGroup2		:= NIL
Local oGroup3		:= NIL

DEFAULT cFil		:= cSvFilAnt

cFilAnt := IF( !Empty( cFil ) , cFil , cFilAnt )
       
IF ( Type( "Inclui" ) == "L" )
	Inclui := .F.
EndIF

IF !( Type( "cCadastro" ) == "C" )
	Private cCadastro := ""
EndIF

IF !( ( nOpcModPer := PonOpcModPer() ) == 0 )

	cAntDiaIniFim := GetPaponta( cFil )

	GetPonMesDat( @dIniPonMes , @dFimPonMes , cFilAnt )

	lModPonMes	:= ( nOpcModPer == 2 )
	lVisualizar	:= ( nOpcModPer == 3 )

	IF ( lPapontaPer := PerCompleto( cAntDiaIniFim ) )
		dAntIniPer		:= Stod( Left(	cAntDiaIniFim , 08 ) )
		dAntFimPer		:= Stod( Right( cAntDiaIniFim , 08 ) )
		cAntDiaIniFim	:= Space( 05 )
	Else
		cAntDiaIniFim	:= Left( cAntDiaIniFim, 02 ) + '/' + Right( cAntDiaIniFim , 02 )
	EndIF
	
	DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
	DEFINE MSDIALOG oDlg TITLE OemToAnsi( cCadastro + " - " + STR0167 ) From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF GetWndDefault() PIXEL	//"Modificar Periodo de Apontamento"

		If lVisualizar
			@ 015 , 003	GROUP oGroup1 TO 050,315 LABEL OemToAnsi(STR0218) OF oDlg PIXEL		//""Periodo Atual do Parametro MV_PAPONTA"
			oGroup1:oFont:=oFont
		Else
			@ 015 , 003	GROUP oGroup1 TO 050,315 LABEL OemToAnsi(STR0168) OF oDlg PIXEL		//""Periodo Anterior do Parametro MV_PAPONTA"
			oGroup1:oFont:=oFont
		EndIf
	
		IF !( lPapontaPer )
			@ 034 , 007 SAY OemToAnsi( STR0164 )	SIZE	100,10 OF oDlg PIXEL FONT oFont	//"Dia Inicial/Final"
			@ 030 , 060 GET cAntDiaIniFim			SIZE	100,10 OF oDlg PIXEL FONT oFont WHEN ( .F. ) PICTURE "99/99" 
	    Else
			@ 034 , 007 SAY OemToAnsi( STR0165 )	SIZE	100,10 OF oDlg PIXEL FONT oFont	//"Anterior"
			@ 030 , 060 GET dAntIniPer				SIZE	100,10 OF oDlg PIXEL FONT oFont	WHEN ( .F. )
			@ 030 , 170 GET dAntFimPer				SIZE	100,10 OF oDlg PIXEL FONT oFont	WHEN ( .F. )
	    EndIF
	    
		IF !( lVisualizar )

			IF !( lModPonMes )
				@ 055 , 003	GROUP oGroup2 TO 090,315 LABEL OemToAnsi(STR0169) OF oDlg PIXEL			//"Novo Periodo para o Parametro MV_PAPONTA"
			Else
				@ 055 , 003	GROUP oGroup2 TO 090,315 LABEL OemToAnsi("Novo Periodo para o Parametro MV_PONMES") OF oDlg PIXEL			//"Novo Periodo para o Parametro MV_PONMES"			
			EndIf
			oGroup2:oFont:=oFont
		
			IF !( lModPonMes )
				@ 074 , 007 SAY OemToAnsi( STR0164 )	SIZE	100,10 OF oDlg PIXEL FONT oFont	//"Dia Inicial/Final"
				@ 070 , 060 GET cAtuDiaIniFim			SIZE	100,10 OF oDlg PIXEL FONT oFont	WHEN( IF( !( lModPonMes ) , IF( lVisualizar , !( lVisualizar ) , !( lModPonMes ) ) , .F. ) ) PICTURE "99/99"
			Else
				@ 064 , 007 SAY OemToAnsi( STR0165 )	SIZE	100,10 OF oDlg PIXEL FONT oFont	//"Periodo"
				@ 070 , 060 GET dAtuIniPer				SIZE	100,10 OF oDlg PIXEL FONT oFont	WHEN( IF( lModPonMes , IF( lVisualizar , !( lVisualizar ) , lModPonMes ) , .F. ) )	
				@ 070 , 170 GET dAtuFimPer				SIZE	100,10 OF oDlg PIXEL FONT oFont	WHEN( IF( lModPonMes , IF( lVisualizar , !( lVisualizar ) , lModPonMes ) , .F. ) )	
			EndIF

		EndIF
	
		@ 095 , 003	GROUP oGroup3 TO 130,315 LABEL OemToAnsi(STR0178) OF oDlg PIXEL			//"Periodo Atual do parametro MV_PONMES"
		oGroup3:oFont:=oFont

		@ 110 , 060 GET dIniPonMes				SIZE	100,10 OF oDlg PIXEL FONT oFont	WHEN( .F. )	
		@ 110 , 170 GET dFimPonMes				SIZE	100,10 OF oDlg PIXEL FONT oFont	WHEN( .F. )	
			
		IF ( lVisualizar )
			bSet15	:= { || oDlg:End() }
		Else
			bSet15	:= { || IF( lModPerOk := PonOkModPer( StrTran( cAtuDiaIniFim , "/" , "" ) , dAtuIniPer , dAtuFimPer , lModPonMes ) , oDlg:End() , lModPerOk ) }
		EndIF
		bSet24		:= { || oDlg:End() }
	
	ACTIVATE MSDIALOG oDlg CENTERED ON INIT EnchoiceBar( oDlg , bSet15 , bSet24  ) 
	
	IF ( ( lModPerOk ) .and. !( lVisualizar ) )
	    IF ( lModPonMes )
			cNewPerPutMv := ( Dtos( dAtuIniPer ) + "/" + Dtos( dAtuFimPer ) )
			PutMvFil( "MV_PONMES"	, cNewPerPutMv  , cFilAnt )
	    Else
	    	cNewPerPutMv := cAtuDiaIniFim
	    	PutMvFil( "MV_PAPONTA"	, cNewPerPutMv  , cFilAnt )
	    	PutMvFil( "MV_PONMES"	, "" , cFilAnt )
	    	lModPerOk := CheckPonMes( @dAtuIniPer , @dAtuFimPer , .F. , .F. , .T. , cFilAnt , .F. , NIL )
	    	IF ( lModPerOk )
	    		cMsgPaponta := MsgPaponta( cNewPerPutMv , dAtuIniPer , dAtuFimPer , cFilAnt )
	    	EndIF
	    	If !Empty(cMsgPaponta) //Caso exista inconsistencia, retorna parametros aos valores antigos
				PutMvFil( "MV_PAPONTA"	, cAntDiaIniFim  , cFilAnt )
				PutMvFil( "MV_PONMES" , "" , cFilAnt )
				CheckPonMes( @dAntIniPer , @dAntFimPer , .F. , .F. , .F. , cFilAnt , .F. , NIL )
				cMsgPaponta += CRLF + CRLF + STR0228 
	    	EndIf
	    EndIF
		//"Caso as Marca┤■es j═ tenham sido apontadas, ser═ necess═rio for┤ar o Reapontamento para ajust═-las ao novo periodo."
		IF Empty( cMsgPaponta )
			cMsgPaponta := ( Dtoc( dAtuIniPer ) + " - " + Dtoc( dAtuFimPer ) + CRLF + CRLF + STR0177 )
			MsgInfo( OemToAnsi( cMsgPaponta ) , OemToAnsi( STR0176 ) )	//"Novo Periodo do Ponto em Aberto"
		Else
			cMsgPaponta := ( Dtoc( dAtuIniPer ) + " - " + Dtoc( dAtuFimPer ) + CRLF + CRLF + cMsgPaponta )
			MsgInfo( OemToAnsi( cMsgPaponta ) , OemToAnsi( STR0229 ) )	//"ConfiguraГЦo Incorreta do Pe╢riodo"
		EndIF
		
	EndIF
	
	IF ( Type( "Inclui" ) == "L" )
		Inclui := .F.
	EndIF

EndIF

RestKeys( aSvKeys , .T. )

cFilAnt := cSvFilAnt

Return( lModPerOk )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁPonOpcModPer 	ЁAutorЁMarinaldo de Jesus Ё Data Ё04/03/2002Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁDialogo com as Opcoes para Modificacao do Periodo 			Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁPonOpcModPer()												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ 															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNumero da Opcao da Mudanca do Periodo:1 -> Dia Inicial/FinalЁ
Ё          Ё                                      2 -> Periodo          Ё
Ё          Ё                                      3 -> Visualizar		Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁPonModPer()											    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function PonOpcModPer()

Local aSvKeys		:= GetKeys()
Local bSet15		:= { || lOpcOk := .T. , RestKeys( aSvKeys , .T. ) ,  oDlg:End() }
Local bSet24		:= { || RestKeys( aSvKeys , .T. ) , oDlg:End() }
Local nOpcModPer	:= 1
Local lOpcOk		:= .F.
Local oRadio		:= NIL
Local oDlg			:= NIL
Local oGroup		:= NIL
Local oFont			:= NIL

DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
DEFINE MSDIALOG oDlg FROM  094,001 TO 250,350 TITLE OemToAnsi( STR0167 ) OF GetWndDefault() PIXEL	//"Modificar Periodo de Apontamento"

	@ 015,005	GROUP oGroup TO 075,170 LABEL OemToAnsi(STR0166) OF oDlg PIXEL	//"Escolha a Op┤└o para a Modifica┤└o do Parametro:"
	oGroup:oFont:=oFont
	
	@ 025,010	RADIO oRadio VAR nOpcModPer ITEMS 	OemToAnsi(STR0164)	,;			//"Dia Inicial/Final"
										   			OemToAnsi(STR0165)	,;			//"Periodo"
										   			OemToAnsi(STR0179)	 ;			//'Apenas Visualizar'
				SIZE 115,010 OF oDlg PIXEL
	
	oDlg:lEscClose := .F. //Nao permite sair ao se pressionar a tecla ESC.	

ACTIVATE MSDIALOG oDlg CENTERED ON INIT EnchoiceBar( oDlg , bSet15 , bSet24 )
RestKeys( aSvKeys , .T. )

IF !( lOpcOk )
	nOpcModPer := 0
EndIF

Return( nOpcModPer )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁPonOkModPer  	ЁAutorЁMarinaldo de Jesus Ё Data Ё04/03/2002Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁValidar o Novo Periodo de Apontamento             			Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁPonOkModPer()												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁPonModPer()											    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function PonOkModPer( cPeriodo , dPerIni , dPerFim , lPeriodo )

Local cMsg			:= ""
Local lOK			:= .F.

Begin Sequence

	IF ( lPeriodo )
		IF !( lOk := ( !Empty( dPerIni ) .and. !Empty( dPerFim ) ) )
			cMsg := STR0173	// "Data Inicial ou Data Final em Branco"
			Break
		EndIF
		IF !( lOk := ( dPerFim >= dPerIni ) )
			cMsg := STR0172 //"Data Inicial maior que Data Final"
			Break
		EndIF
		IF !( lOk := MaxP8PGOrdVld( dPerIni , dPerFim ) )
			cMsg := ""
			Break
		EndIF
		IF !( lOk := ValidPerSPO( cFilAnt , dPerIni , dPerFim , .T. , .F. ) )
			cMsg := STR0171	//"Periodo Ja Cadastrado no SPO ( Cadastro de Periodos )"
			Break
		EndIF
	Else
		IF !( lOk := ( !Empty( cPeriodo ) ) )
			cMsg := STR0170	//"O Periodo nao pode ficar em Branco"
			Break
		EndIF
	EndIF

End Sequence

IF ( !( lOk ) .and. !Empty( cMsg ) )
	MsgInfo( OemToAnsi( cMsg ) , OemToAnsi( STR0174 + " - " + STR0175  ) ) //"Aten┤└o!"###"Existem Inconsistencias a serem verificadas."
EndIF

Return( lOk )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁMsgPaponta  	ЁAutorЁMarinaldo de Jesus Ё Data Ё01/07/2004Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica se Existe Alguma Inconsistencia no preenchimento doЁ
Ё          ЁMV_PAPONTA e Emite Mensagem correspondente				    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<vide parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁPonModPer()											    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function MsgPaponta( cPerAponta , dAtuIniPer , dAtuFimPer , cFil )

Local cMsgPaponta	:= ""
Local lMaisDias		:= .F.

Local cMsgIniPer
Local cMsgFimPer
Local cMesAux
Local cAnoAux
Local dDataAux
Local nDiaAux
Local nMesAux
Local nAnoAux
Local nUltDiaMes
Local nDiaIni
Local nDiaFim
Local nIniDif
Local nFimDif

Begin Sequence

	IF PerCompleto( @cPerAponta , cFil )
		Break
	EndIF

	IF !PapontaOk( cPerAponta , NIL , NIL , cFil )
		Help( "" , 1 , "PERNCAD" )
		Break
	EndIF

	nDiaIni := Day( dAtuIniPer )
	nDiaFim := Day( dAtuFimPer )

	IF ( AnoMes( dAtuIniPer ) == AnoMes( dAtuFimPer ) )

 		IF ( nDiaIni > 1 )
			nIniDif := ( nDiaIni - 1 )
			IF ( nIniDif > 0 )
				cMsgIniPer	:= Day2Str( nIniDif )
				cMsgIniPer	+= " "
				cMsgIniPer	+= STR0210	//"dia(s), no Inicio do perМodo,"
			EndIF
		EndIF

 		nUltDiaMes := f_UltDia( Ctod( "01/" + Month2Str( dAtuFimPer ) + "/" + Year2Str( dAtuFimPer ) , "DDMMYYYY" ) )
 		IF ( nDiaFim < nUltDiaMes )
			nFimDif := ( nUltDiaMes - nDiaFim )
			IF ( nFimDif > 0 )
				IF !Empty( cMsgIniPer )
					cMsgIniPer += " "
					cMsgIniPer += STR0211 //"e"
					cMsgIniPer += " "
				EndIF
				cMsgFimPer := Day2Str( nFimDif )
				cMsgFimPer += " "
				cMsgFimPer += STR0212	//"dia(s), no Final do perМodo,"
			EndIF
		EndIF

 		Break

 	EndIF

	IF ( nDiaIni > nDiaFim )

		nFimDif := ( ( nDiaIni - nDiaFim ) - 1 )
		IF ( nFimDif > 0 )
			cMsgFimPer := Day2Str( nFimDif )
			cMsgFimPer += " "
			cMsgFimPer += STR0212	//"dia(s), no Final do perМodo,"
		EndIF
		
		Break

	EndIF

	IF ( nDiaIni < nDiaFim )

		nUltDiaMes	:= f_UltDia( Ctod( "01/" + Month2Str( dAtuIniPer ) + "/" + Year2Str( dAtuIniPer ) , "DDMMYYYY" ) )
		nIniDif		:= ( ( nUltDiaMes - nDiaIni ) + 1 )
		nFimDif		:= nDiaFim
		IF ( lMaisDias := ( ( nIniDif + nFimDif ) > nUltDiaMes ) )
			nFimDif := ( ( nIniDif + nFimDif ) - nUltDiaMes )
			cMsgFimPer := STR0214 //"mais"
			cMsgFimPer += " "
			cMsgFimPer += Day2Str( nFimDif )
			cMsgFimPer += " "
			cMsgFimPer += STR0212	//"dia(s), no Final do perМodo,"
			Break
		EndIF

		nDiaAux		:= ( nDiaIni - 1 )
		nMesAux		:= ( Month( dAtuFimPer ) + 1 )
		nAnoAux		:= Year( dAtuFimPer )
		IF ( nMesAux > 12 )
			nMesAux := 1
			++nAnoAux
		EndIF
		cMesAux		:= Month2Str( nMesAux )
		cAnoAux		:= Year2Str( nAnoAux )
		dDataAux	:= Ctod( Day2Str( nDiaAux ) + "/" + cMesAux + "/" + cAnoAux , "DDMMYYYY" )
		While Empty( dDataAux )
			dDataAux := Ctod( Day2Str( --nDiaAux ) + "/" + cMesAux + "/" + cAnoAux , "DDMMYYYY" )
		End While
		nUltDiaMes	:= f_UltDia( Ctod( "01/" + Month2Str( dAtuFimPer ) + "/" + Year2Str( dAtuFimPer ) , "DDMMYYYY" ) )
		nFimDif		:= ( nUltDiaMes - nDiaFim )
		nFimDif		+= Day( dDataAux )
		IF ( nFimDif > 0 )
			cMsgFimPer := Day2Str( nFimDif )
			cMsgFimPer += " "
			cMsgFimPer += STR0212	//"dia(s), no Final do perМodo,"
		EndIF
		
		Break

	EndIF

End Sequence

IF !Empty( cMsgIniPer ) .or. !Empty( cMsgFimPer )
	cMsgPaponta := STR0209	//"A ConfiguraГЦo Atual do MV_PAPONTA farА com que"
	cMsgPaponta += " "
	IF !Empty( cMsgIniPer )
		cMsgPaponta += cMsgIniPer
	EndIF	
	IF !Empty( cMsgFimPer )
		cMsgPaponta += cMsgFimPer
	EndIF	
	cMsgPaponta += " "
	IF !( lMaisDias )
		cMsgPaponta += STR0213	//"seja(m) desconsiderado(s) pelo sistema."
	Else
		cMsgPaponta += STR0215	//"seja(m) considerados(s) pelo sistema."
	EndIF	
	cMsgPaponta := ( STR0208 + CRLF + CRLF + cMsgPaponta ) //"AtenГЦo!!!!"
EndIF	

Return( cMsgPaponta )

/*/
зддддддддддбдддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁInitP8PgOrdSizeЁAutorЁMarinaldo de Jesus   Ё Data Ё03/06/2002Ё
цддддддддддедддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁInicializa as Statics __nTamP8PgOrdSize e __nTamP8PgOrdSize  Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                                                  	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico 													 Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function InitP8PgOrdSize(nOpc)

Local nTam

DEFAULT nOpc := 1

IF ( Select("SX3") > 0 )
	IF ( nOpc == 1 )
		nTam := GetSx3Cache( "P8_ORDEM" , "X3_TAMANHO" )
	Else
		nTam := GetSx3Cache( "PG_ORDEM" , "X3_TAMANHO" )
	EndIF
EndIF
DEFAULT nTam := 2

Return( nTam )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁPonLockRegs		ЁAutorЁMarinaldo de Jesus Ё Data Ё11/06/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁTentativa de Lock em Varios Registros             			Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlLocked                  									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerico   											    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PonLockRegs(	cAlias			,;	//01 -> Alias onde os Registros devera haver Lock dos Registros
						aRegsLock		,;	//02 -> Array com os Recnos para Lock
						aKeysCode		,;	//03 -> Array com as Chaves para MayIUseCode
						nTentaLocks		,;	//04 -> Numero de Tentativas de Lock
						nSecondsWait	,;	//05 -> Segundos a aguardar para nova tentativa
						lMayIUseCode	,;	//06 -> Se ira utilizar MayIUseCode
						nMaxLocks		 ;	//07 -> Numero maximo de Locks
					)
Return(LockRegsCode(@cAlias,@aRegsLock,@aKeysCode,@nTentaLocks,@nSecondsWait,@lMayIUseCode,@nMaxLocks))

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁPonFreeLocks    ЁAutorЁMarinaldo de Jesus Ё Data Ё11/06/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁChamada da FreeLocks                                        Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                        									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerico   											    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PonFreeLocks( cAlias , nReg , lFreeUseCode , cUseCode )
Return( FreeLocks( cAlias , nReg , lFreeUseCode , cUseCode ) )
/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁfDemissao       ЁAutorЁMauricio MR        Ё Data Ё27/01/2005Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica a Situacao de Demissao do Funcionario              Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                        									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁSIGAPON   											    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fDemissao(cSituacao, cRescRais)
Local cRet    
If cRescRais$'30/31'
	cRet:= 'T'
Else 
	cRet:= cSituacao
Endif   
Return( cRet )

/*/
зддддддддддбдддддддддддддбддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁfVerTabRF0   ЁAutor ЁMauricio MR          Ё Data Ё05/10/05  Ё
цддддддддддедддддддддддддаддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica a Existencia da tabela de Pre-abonos e se a mesma  Ё
Ё          Ёpossui registros.                                           Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >								  	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >								  	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
function  fVerTabRF0()
Local lRet		:= .F.
Local lVazio	:= .T.

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁVerifica a Existencia da Tabela RF0 e se a mesma  Ё
Ёpossui conteudo. Somente nessas condicoes sera	   Ё
Ёverficada a existencia de pre-abonos.			   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддды/*/
lRet:= Sx2ChkTable( "RF0",, @lVazio) 	

lRet:= ( lRet .AND. !lVazio)

Return ( lRet )


/*/
зддддддддддбдддддддддддддбддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁSR8Sx5Acerta ЁAutor ЁLeandro Drumond      Ё Data Ё20/05/09  Ё
цддддддддддедддддддддддддаддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁAjusta a descricao dos afastamentos na SX5.                 Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >								  	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >								  	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function SR8Sx5Acerta()

Local aArea		:= GetArea()
Local cDesc		:= "FORA DE USO - APOSENTADORIA SEM RESCISAO DE CONTRATO"
Local cDescSpa  := "INACTIVO - JUBILACION SIN RESCISION DE CONTRATO"
Local cDescEng  := "OBSOLETE - PENSION WITHOUT CONTRACT RESCISSION"

DbSelectArea("SX5")

If dbSeek(xFilial("SX5")+"30"+"V")
	If !( AllTrim(SX5->X5_DESCRI) == cDesc )
		Reclock("SX5",.F.)
		SX5->X5_DESCRI := cDesc
		SX5->X5_DESCSPA:= cDescSpa
		SX5->X5_DESCENG:= cDescEng
		MsUnlock()
	EndIf
Endif
	
RestArea( aArea )
	
Return Nil

/*/
зддддддддддбдддддддддддддбддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁPort1510     ЁAutor ЁLeandro Drumond      Ё Data Ё02/10/09  Ё
цддддддддддедддддддддддддаддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica se Portaria 1510/2009 esta em vigor.               Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >								  	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >								  	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function Port1510()
Local lRet := .F.

If DPORT1510 == "25/11/09" .and. cPaisLoc == "BRA"
	lRet := .T.
EndIf

Return lRet

/*/
зддддддддддбдддддддддддддбддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁfVerBasePort ЁAutor ЁLeandro Drumond      Ё Data Ё02/10/09  Ё
цддддддддддедддддддддддддаддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica se Base foi adequada a Portaria 1510/2009.         Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >								  	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >								  	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fVerBasePort(lShowHelp)
Local aArea		:= GetArea()
Local aSX3Area  := SX3->(GetArea())
Local lRet		:= .F.

DEFAULT lShowHelp := .T.

SX3->(DbSetOrder(2))

//Verifica se existem registros na tabela de Eventos e Relogio para definir se utiliza
// as novas tabelas da Portaria 1.510
If SP9->(LastRec()) > 0 .And. SP0->(LastRec()) > 0

	//Caso campo seja encontrado, admite-se que update foi aplicado.
	If SX3->( dbSeek("P8_NUMREP")) .and. SX3->( dbSeek("RFD_CODIGO")) .and. SX3->( dbSeek("RA_RHEXP"))
		lRet := .T.
	Else
		If lShowHelp
			cMsg := STR0219	//'A Base nЦo foi adequada para trabalhar com a Portaria 1510/2009.'
			cMsg += CRLF
			cMsg += STR0220 //'Execute o Compatibilizador RHUPDPON.'
			MsgInfo( OemToAnsi( cMsg ) , OemToAnsi( STR0208 ) )	//  'Aten┤└o!'
		Else
			ConOut("")
			ConOut( STR0219 ) //'A Base nЦo foi adequada para trabalhar com a Portaria 1510/2009.'
			ConOut( STR0220 ) //'Execute o Compatibilizador RHUPDPON.'
			ConOut("")	
		EndIf
	EndIf
	
	If lRet
		//Caso campo seja encontrado, admite-se que update foi aplicado.
		If !( SX3->( dbSeek("RFE_PIS")) .and. SX3->( dbSeek("P0_NOVO")) )
			lRet := .F.
			If lShowHelp
				cMsg := STR0232	//"NЦo foi aplicada a atualizaГЦo da importaГЦo AFD."
				cMsg += CRLF
				cMsg += STR0220 //'Execute o Compatibilizador RHUPDMOD.'
				MsgInfo( OemToAnsi( cMsg ) , OemToAnsi( STR0208 ) )	//  'Aten┤└o!'
			Else
				ConOut("")
				ConOut( STR0232 ) //NЦo foi aplicada a atualizaГЦo da importaГЦo AFD."
				ConOut( STR0220 ) //'Execute o Compatibilizador RHUPDMOD.'
				ConOut("")	
			EndIf
		EndIf
	EndIf
	
	If lRet
		//Caso campo seja encontrado, admite-se que update foi aplicado.
		If !( SX3->( dbSeek("RFH_PIS") ) )
			lRet := .F.
			If lShowHelp
				cMsg := STR0234	//"NЦo foi aplicada a atualizaГЦo do Fechamento da tabela RFE."
				cMsg += CRLF
				cMsg += STR0220 //'Execute o Compatibilizador RHUPDMOD.'
				MsgInfo( OemToAnsi( cMsg ) , OemToAnsi( STR0208 ) )	//  'Aten┤└o!'
			Else
				ConOut("")
				ConOut( STR0234 ) //"NЦo foi aplicada a atualizaГЦo do Fechamento da tabela RFE."
				ConOut( STR0220 ) //'Execute o Compatibilizador RHUPDMOD.'
				ConOut("")	
			EndIf
		EndIf
	EndIf
Else
	lRet := .T.
Endif

RestArea(aSX3Area)
RestArea(aArea)

Return (lRet)

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁfGetMotivo  Ё Autor Ё Leandro Drumond     Ё Data Ё 05/10/09 Ё╠╠
╠╠цддддддддддеддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Monta dialogo para inclusao de motivo de desconsideracao   Ё╠╠
╠╠Ё			 Ё ou inclusao de marcacao.                                   Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё Manutencoes                                                Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠*/
Function fGetMotivo( cMotivo, cHelp, nOpc, cCodMot )

Local cTitJan := ""
Local lRet    := .F.
Local oDlg
Local oGroup
Local oFont
Local oMotivo
Local aSvKeys		:= GetKeys()

Local bTeclaALT_R := SetKey( K_ALT_R		, NIL )  

// Ajusta Consulta PadrЦo RFD
AjustaSXB()

SetKey( VK_F3  , {||NIL}  )
SetKey( K_ALT_R ,{||NIL}  ) 

cMotivo := fInitMotivo( xFilial("RFD"), "1" , Alltrim(Str(nOpc)) )
cCodMot := fInitCodMot( xFilial("RFD"), "2" , Alltrim(Str(nOpc)) )

M->P8_MOTIVRG:= cMotivo
M->RFD_CODIGO:= cCodMot

cHelp   := ""

If nOpc == 1  //Inclusao
	cTitJan := OemToAnsi(STR0222)  //"Motivo de inclusЦo"
ElseIf nOpc == 2 .or. nOpc == 3//Exclusao
	cTitJan := OemTOAnsi(STR0221)  //"Motivo para desconsideraГЦo"
EndIf

DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
DEFINE MSDIALOG oDlg FROM  094,001 TO 200,250 TITLE OemToAnsi(cTitJan) PIXEL

@ 005,005 GROUP oGroup TO 035,120 OF oDlg PIXEL

//@ 015,010 MSGET oMotivo Var M->P8_MOTIVRG PICTURE GetSx3Cache( "P8_MOTIVRG" , "X3_PICTURE" ) VALID ( !Empty( M->P8_MOTIVRG ) ) WHEN .T. SIZE 100,10 OF oDlg PIXEL 
@ 015,010 MSGET oMotivo Var M->P8_MOTIVRG PICTURE GetSx3Cache( "P8_MOTIVRG", "X3_PICTURE" ) F3 "RFD";
						VALID ( PVldCpoOK(M->P8_MOTIVRG,," ") .And. !Empty( M->P8_MOTIVRG ) .And. fValCodRFD( xFilial("RFD"), M->P8_MOTIVRG ) );
						WHEN .T. SIZE 100,10 OF oDlg PIXEL

DEFINE SBUTTON FROM 40, 035 TYPE 1 ENABLE OF oDlg ACTION ( lRet := .T., oDlg:End() )
DEFINE SBUTTON FROM 40, 070 TYPE 2 ENABLE OF oDlg ACTION ( lRet := .F., oDlg:End() )

ACTIVATE MSDIALOG oDlg CENTERED

//Se cancelou, limpa cMotivo
If !(lRet)
	M->P8_MOTIVRG := ""
	If nOpc == 1 //Inclusao
		cHelp := Space(01) + OEMTOANSI(STR0225) + CRLF //"Para inclusЦo de nova marcaГЦo"
		cHelp += Space(01) + OEMTOANSI(STR0226) + CRLF //"И necessАrio informar um motivo."
	ElseIf nOpc == 2 //Exclusao
		cHelp := Space(01) + OEMTOANSI(STR0223) + CRLF //"Para que a marcaГЦo seja desconsiderada"
		cHelp += Space(01) + OEMTOANSI(STR0226) + CRLF //"И necessАrio informar um motivo."
	ElseIf nOpc == 3 //Exclusao em lote
		cHelp := Space(01) + OEMTOANSI(STR0224) + CRLF //"Para que as marcaГУes sejam desconsiderada"
		cHelp += Space(01) + OEMTOANSI(STR0226) + CRLF //"И necessАrio informar um motivo."
	EndIf	
EndIf

cMotivo:= M->P8_MOTIVRG
RestKeys( aSvKeys , .T. )
SetKey( K_ALT_R		, bTeclaALT_R )

Return( lRet )

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁfInitMotivo Ё Autor Ё Leandro Drumond     Ё Data Ё 07/10/09 Ё╠╠
╠╠цддддддддддеддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Busca motivo padrao da tabela RFD de acordo com o indice   Ё╠╠
╠╠Ё			 Ё Sera exibido o primeiro motivo                             Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё Manutencoes                                                Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠*/
Function fInitMotivo( cFil, cAplic , cTipo )
Local aArea	  := GetArea()
Local cMotivo := Space(GetSx3Cache( "RFD_DESC"	, "X3_TAMANHO" ))

DEFAULT cFil   := xFilial("RFD")
DEFAULT cAplic := "1"
DEFAULT cTipo  := "0"

DbSelectArea("RFD")

RFD->( dbSetOrder( 02 ) )

If RFD->( dbSeek( cFil+cAplic+cTipo , .F.  ) )
	cMotivo := Padr( RFD->RFD_DESC , GetSx3Cache( "RFD_DESC"	, "X3_TAMANHO" ) )
EndIf

RestArea(aArea)

Return (cMotivo)        

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁfInitCodMot Ё Autor Ё Bianca C. Lima      Ё Data Ё 07/10/09 Ё╠╠
╠╠цддддддддддеддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Busca cod. motivo padrao da tabela RFD de acordo c/indice  Ё╠╠
╠╠Ё			 Ё 								                              Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё Manutencoes                                                Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠*/
Function fInitCodMot( cFil, cAplic , cTipo )
Local aArea	  := GetArea()
Local cCodMot := Space(GetSx3Cache( "RFD_CODIGO"	, "X3_TAMANHO" ))

DEFAULT cFil   := xFilial("RFD")
DEFAULT cAplic := "1"
DEFAULT cTipo  := "0"

DbSelectArea("RFD")

RFD->( dbSetOrder( 02 ) )

If RFD->( dbSeek( cFil+cAplic+cTipo , .F.  ) )
	cCodMot := Padr( RFD->RFD_CODIGO , GetSx3Cache( "RFD_CODIGO"	, "X3_TAMANHO" ) )
EndIf

RestArea(aArea)

Return (cCodMot)

/*/
зддддддддддбдддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁfValCodRFD	 Ё Autor ЁIgor Franzoi		   Ё Data Ё29/06/2010Ё
цддддддддддедддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁEnvia mensagem ao usuario em caso de codigo numerico digitadoЁ
Ё		   Ёe o mesmo nao existir na tabela RFD							 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁfValCodRFD( cCodPes ) 										 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁuRet                                                 	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico 													 Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function fValCodRFD( cFilPes, cCodPes )

Local lRet		:= .T.

Local cCodAux	:= GetSx3Cache( "RFD_CODIGO" , "X3_TAMANHO" )
Local cAlias	:= "RFD"

Local aArea	:= GetArea()

DEFAULT	cCodPes	:= ""

If !Empty(cCodPes)

	cCodAux := SubStr( AllTrim(cCodPes),1,2 )
	
	If Empty(SubStr(cCodPes,3,3))
		
		dbSelectArea(cAlias)
		(cAlias)->( dbSetOrder( RetOrdem( "RFD","RFD_FILIAL+RFD_CODIGO+RFD_APLIC+RFD_TIPO" ) ) )
		
		If ( (cAlias)->(dbSeek( cFilPes+cCodAux )) )
			//STR0230 = "Existe Motivo de ManutenГЦo com o cСdigo informado:"
			//STR0231 = "Deseja utilizА-lo?"
			//STR0208 = "AtenГЦo"			
			If MsgNoYes( OemToAnsi( STR0230 ) +" "+AllTrim(cCodAux)+"!"+CRLF+OemToAnsi( STR0231 ),;
						 OemToAnsi( STR0208 ) ) 
				M->P8_MOTIVRG := (cAlias)->(RFD_DESC)
			EndIf
		EndIf
	
	EndIf
		
EndIf

RestArea(aArea)

Return lRet

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁfPortTit    Ё Autor Ё Leandro Drumond     Ё Data Ё 24/11/09 Ё╠╠
╠╠цддддддддддеддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Complementa titulo das telas com dizeres referentes a      Ё╠╠
╠╠Ё			 Ё Portaria 1510/2009.                                        Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё GENERICO                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠*/
Function fPortTit()
Local cTitulo := OEMTOANSI(STR0227) //' - SREP - Portaria 1510/2009 de 21.08.2009'
Return cTitulo                                     

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠иммммммммммяммммммммммкмммммммяммммммммммммммммммммкммммммяммммммммммммм╩╠╠
╠╠╨Programa  ЁAjustaSXB ╨Autor  ЁBianca C. Lima      ╨ Data Ё  18/07/08   ╨╠╠
╠╠лммммммммммьммммммммммймммммммоммммммммммммммммммммйммммммоммммммммммммм╧╠╠
╠╠╨Desc.     ЁAjuste na consulta padrao RFD                               ╨╠╠
╠╠╨          Ё                                                            ╨╠╠
╠╠лммммммммммьмммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╧╠╠
╠╠╨Uso       Ё PONXFUN                                                    ╨╠╠
╠╠хммммммммммомммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╪╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Static Function AjustaSXB()

	Local aCampos 	:= {} 	// Array para receber a Nova Estrutura da SXB
	Local nX	 	:= 0	// Variavel auxiliar utilizada no For-Next 
	Local lFound	:= .F. 
	Local cKey		:= ""
	
	SXB->( DbSetorder(1) )
		
	//******************************************************************************************************************
	// Nova Estrutura da Consutla SXB RFD
	//******************************************************************************************************************
	aAdd( aCampos, {"RFD","1","01","DB"	,"CСdigo" 				,"Codigo"				,"Code"					,"RFD"				,""})
	aAdd( aCampos, {"RFD","2","01","01"	,"CСdigo"				,"Codigo"				,"Code"					,""					,""})
	aAdd( aCampos, {"RFD","4","01","01"	,"Motivo"				,"Motivo"				,"Motivo"				,"RFD_CODIGO"		,""})
	aAdd( aCampos, {"RFD","4","01","02"	,"Descricao"			,"Descricao"			,"Descricao"	   	   	,"RFD_DESC"			,""})	
	aAdd( aCampos, {"RFD","5","01",""	,""						,""						,""						,"RFD->RFD_DESC"	,""})	
			
	For nX := 1 To Len( aCampos )
		
		cKey	:= "RFD   " + aCampos[ nX, 02 ] + aCampos[ nX, 03 ] + aCampos[ nX, 04 ]
		lFound	:= SXB->( dbSeek( cKey ) )
                                                         
		SXB->( Reclock("SXB", !lFound ) )
		SXB->XB_ALIAS   := aCampos[nX, 1]
		SXB->XB_TIPO    := aCampos[nX, 2]
		SXB->XB_SEQ     := aCampos[nX, 3]
		SXB->XB_COLUNA  := aCampos[nX, 4]
		SXB->XB_DESCRI  := aCampos[nX, 5]
		SXB->XB_DESCSPA := aCampos[nX, 6]
		SXB->XB_DESCENG := aCampos[nX, 7]
		SXB->XB_CONTEM  := aCampos[nX, 8]
		SXB->XB_WCONTEM := aCampos[nX, 9]
		SXB->( MsUnlock() )
			
	Next nX

Return (Nil)

//-------------------------------------------------------------------
/*/{Protheus.doc} PonLoadExec

@author		Allyson Mesashi
@since		08/09/2010
@version	1.0
@return		NIL
@obs		Funcao executada no menu do SIGAPON p/ atualizar empresas quando houver integracao com o TSREP. 
/*/
//-------------------------------------------------------------------
Function PonLoadExec()
Local lTSREP	:= SuperGetMv( "MV_TSREP" , NIL , .F. )                             

If lTSREP
	If _nVezes > 0
		_nVezes--
	Else
		_nVezes := 1000
		UpdRFK()		
	EndIf
EndIf

Return(Nil)   

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁPVldCpoOK	  Ё Autor ЁRicardo Berti 	    Ё Data Ё15/09/2011Ё╠╠
╠╠цддддддддддеддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Retira caracteres especiais/invalidos de um campo		  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё PVldCpoOK( cCpo , cLstChar , cNewChar )				 	  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ cCpo 	- variavel para retirar carac. especiais		  Ё╠╠
╠╠Ё          Ё cLstChar - lista de caracteres especiais		 			  Ё╠╠
╠╠Ё          Ё cNewChar - Caracter p/substituir os especiais/Default=vazioЁ╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁRetorno   Ё .T.			 			 							 	  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё Generico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
*/
Function PVldCpoOK( cCpo , cLstChar , cNewChar )

Local nTamCpo
Local nX		 := 0

DEFAULT	cCpo	 := ""
DEFAULT	cLstChar := "`'@#$%╗&*()_+={}[]~^?!/\;:><|" + '"'
DEFAULT	cNewChar := ""

If !Empty(cCpo)

	nTamCpo := Len(cCpo)

	For nX:=1 To Len(cLstChar)
        While SubsTr(cLstChar,nX,1) $ cCpo
			cCpo := StrTran( cCpo , SubsTr(cLstChar,nX,1) , cNewChar )
		EndDo
	Next                
	
	If Len(cCpo) < nTamCpo
		cCpo += Replicate(" ", nTamCpo - Len(Ccpo) )
    EndIf

	If AllTrim(ReadVar()) == "M->P8_MOTIVRG"
		M->P8_MOTIVRG:= cCpo
	EndIf

EndIf

Return (.T.)
                                                                                                            